#include "cuda.h"
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include "device_atomic_functions.h"

#include "Platform.hpp"
#include "Trig.hpp"
#include "WallsFloors.hpp"
#include "vmath.hpp"

#include <fstream>
#include <iostream>
#include <iomanip>

# define M_PI                  3.14159265358979323846  /* pi */
# define MAX_SQUISH_SPOTS      5000
# define MAX_ZONES             2000
# define MAX_COLLISION_SETUPS  2500000
# define MAX_STRAIN_SETUPS     500000
# define MAX_SLIDE_SETUPS      100000000

# define sins(x)              gSineTable[(unsigned short)(int) (x) >> 4]
# define coss(x)              gCosineTable[(unsigned short)(int) (x) >> 4]
# define revAtans(x)          gReverseArctanTable[(unsigned short)(int) (x)]

# define sinsG(x)              gSineTableG[(unsigned short)(int) (x) >> 4]
# define cossG(x)              gCosineTableG[(unsigned short)(int) (x) >> 4]
# define revAtansG(x)          gReverseArctanTableG[(unsigned short)(int) (x)]

# define sign(x)               (((x) > 0) - ((x) < 0))

__device__ float gSineTableG[4096] = { 0.000000000f, 0.0015339801f, 0.0030679568f, 0.004601926f, 0.0061358847f, 0.007669829f, 0.009203754f, 0.010737659f, 0.012271538f, 0.0138053885f, 0.015339206f, 0.016872987f, 0.018406730f, 0.019940428f, 0.021474080f, 0.023007682f, 0.024541229f, 0.026074719f, 0.027608145f, 0.029141508f, 0.030674804f, 0.032208025f, 0.033741172f, 0.035274237f, 0.036807224f, 0.038340122f, 0.039872926f, 0.041405641f, 0.042938258f, 0.044470772f, 0.046003181f, 0.047535483f, 0.049067676f, 0.050599750f, 0.052131705f, 0.053663537f, 0.055195246f, 0.056726821f, 0.058258265f, 0.059789572f, 0.061320737f, 0.062851757f, 0.064382628f, 0.065913349f, 0.067443922f, 0.068974331f, 0.070504576f, 0.072034650f, 0.073564567f, 0.075094298f, 0.076623864f, 0.078153245f, 0.079682440f, 0.081211448f, 0.082740262f, 0.084268890f, 0.085797310f, 0.087325536f, 0.088853553f, 0.090381362f, 0.091908954f, 0.093436338f, 0.094963498f, 0.096490428f, 0.098017141f, 0.099543616f, 0.101069860f, 0.102595866f, 0.104121633f, 0.105647154f, 0.107172422f, 0.108697444f, 0.110222206f, 0.111746714f, 0.113270953f, 0.114794925f, 0.116318628f, 0.117842063f, 0.119365215f, 0.120888084f, 0.122410677f, 0.123932973f, 0.125454977f, 0.126976699f, 0.128498107f, 0.130019218f, 0.131540030f, 0.133060530f, 0.134580702f, 0.136100575f, 0.137620121f, 0.139139339f, 0.140658244f, 0.142176807f, 0.143695027f, 0.145212919f, 0.146730468f, 0.148247674f, 0.149764538f, 0.151281044f, 0.152797192f, 0.154312968f, 0.155828401f, 0.157343462f, 0.158858150f, 0.160372451f, 0.161886394f, 0.163399950f, 0.164913118f, 0.166425899f, 0.167938292f, 0.169450298f, 0.170961887f, 0.172473088f, 0.173983872f, 0.175494254f, 0.177004218f, 0.178513765f, 0.180022895f, 0.181531608f, 0.183039889f, 0.184547737f, 0.186055154f, 0.187562123f, 0.189068660f, 0.190574750f, 0.192080393f, 0.193585590f, 0.195090324f, 0.196594596f, 0.198098406f, 0.199601755f, 0.201104641f, 0.202607036f, 0.204108968f, 0.205610409f, 0.207111374f, 0.208611846f, 0.210111842f, 0.211611331f, 0.213110313f, 0.214608818f, 0.216106802f, 0.217604280f, 0.219101235f, 0.220597684f, 0.222093627f, 0.223589033f, 0.225083917f, 0.226578265f, 0.228072077f, 0.229565367f, 0.231058106f, 0.232550308f, 0.234041959f, 0.235533059f, 0.237023607f, 0.238513589f, 0.240003020f, 0.241491884f, 0.242980182f, 0.244467899f, 0.245955050f, 0.247441620f, 0.248927608f, 0.250413001f, 0.251897812f, 0.253382027f, 0.254865646f, 0.256348670f, 0.257831097f, 0.259312928f, 0.260794103f, 0.262274712f, 0.263754666f, 0.265234023f, 0.266712755f, 0.268190861f, 0.269668311f, 0.271145165f, 0.272621363f, 0.274096906f, 0.275571823f, 0.277046084f, 0.278519690f, 0.279992640f, 0.281464934f, 0.282936573f, 0.284407526f, 0.285877824f, 0.287347466f, 0.288816422f, 0.290284663f, 0.291752249f, 0.293219149f, 0.294685364f, 0.296150893f, 0.297615707f, 0.299079835f, 0.300543249f, 0.302005947f, 0.303467959f, 0.304929227f, 0.306389809f, 0.307849646f, 0.309308767f, 0.310767144f, 0.312224805f, 0.313681751f, 0.315137923f, 0.316593379f, 0.318048090f, 0.319502026f, 0.320955247f, 0.322407693f, 0.323859364f, 0.325310290f, 0.326760441f, 0.328209847f, 0.329658449f, 0.331106305f, 0.332553357f, 0.333999664f, 0.335445136f, 0.336889863f, 0.338333756f, 0.339776874f, 0.341219217f, 0.342660725f, 0.344101429f, 0.345541328f, 0.346980423f, 0.348418683f, 0.349856138f, 0.351292759f, 0.352728546f, 0.354163527f, 0.355597675f, 0.357030958f, 0.358463407f, 0.359895051f, 0.361325800f, 0.362755716f, 0.364184797f, 0.365612984f, 0.367040336f, 0.368466824f, 0.369892448f, 0.371317208f, 0.372741073f, 0.374164075f, 0.375586182f, 0.377007425f, 0.378427744f, 0.379847199f, 0.381265759f, 0.382683426f, 0.384100199f, 0.385516047f, 0.386931002f, 0.388345033f, 0.389758170f, 0.391170382f, 0.392581671f, 0.393992037f, 0.395401478f, 0.396809995f, 0.398217559f, 0.399624199f, 0.401029885f, 0.402434647f, 0.403838456f, 0.405241311f, 0.406643212f, 0.408044159f, 0.409444153f, 0.410843164f, 0.412241220f, 0.413638324f, 0.415034413f, 0.416429549f, 0.417823702f, 0.419216901f, 0.420609087f, 0.422000259f, 0.423390478f, 0.424779683f, 0.426167876f, 0.427555084f, 0.428941280f, 0.430326492f, 0.431710660f, 0.433093816f, 0.434475958f, 0.435857087f, 0.437237173f, 0.438616246f, 0.439994276f, 0.441371262f, 0.442747235f, 0.444122136f, 0.445496023f, 0.446868837f, 0.448240608f, 0.449611336f, 0.450980991f, 0.452349573f, 0.453717113f, 0.455083579f, 0.456448972f, 0.457813293f, 0.459176540f, 0.460538715f, 0.461899787f, 0.463259786f, 0.464618683f, 0.465976506f, 0.467333198f, 0.468688816f, 0.470043331f, 0.471396744f, 0.472749025f, 0.474100202f, 0.475450277f, 0.476799220f, 0.478147060f, 0.479493767f, 0.480839342f, 0.482183784f, 0.483527064f, 0.484869242f, 0.486210287f, 0.487550169f, 0.488888890f, 0.490226477f, 0.491562903f, 0.492898196f, 0.494232297f, 0.495565265f, 0.496897042f, 0.498227656f, 0.499557108f, 0.500885367f, 0.502212465f, 0.503538370f, 0.504863083f, 0.506186664f, 0.507508993f, 0.508830130f, 0.510150075f, 0.511468828f, 0.512786388f, 0.514102757f, 0.515417874f, 0.516731799f, 0.518044531f, 0.519356012f, 0.520666242f, 0.521975279f, 0.523283124f, 0.524589658f, 0.525895000f, 0.527199149f, 0.528501987f, 0.529803634f, 0.531104028f, 0.532403111f, 0.533701003f, 0.534997642f, 0.536292970f, 0.537587047f, 0.538879931f, 0.540171444f, 0.541461766f, 0.542750776f, 0.544038534f, 0.545324981f, 0.546610177f, 0.547894061f, 0.549176633f, 0.550457954f, 0.551737964f, 0.553016722f, 0.554294109f, 0.555570245f, 0.556845009f, 0.558118522f, 0.559390724f, 0.560661554f, 0.561931133f, 0.563199341f, 0.564466238f, 0.565731823f, 0.566996038f, 0.568258941f, 0.569520533f, 0.570780754f, 0.572039604f, 0.573297143f, 0.574553370f, 0.575808167f, 0.577061653f, 0.578313768f, 0.579564571f, 0.580813944f, 0.582062006f, 0.583308637f, 0.584553957f, 0.585797846f, 0.587040365f, 0.588281572f, 0.589521289f, 0.590759695f, 0.591996670f, 0.593232274f, 0.594466507f, 0.595699310f, 0.596930683f, 0.598160684f, 0.599389315f, 0.600616455f, 0.601842225f, 0.603066623f, 0.604289532f, 0.605511069f, 0.606731117f, 0.607949793f, 0.609167039f, 0.610382795f, 0.611597180f, 0.612810075f, 0.614021540f, 0.615231574f, 0.616440177f, 0.617647290f, 0.618852973f, 0.620057225f, 0.621259987f, 0.622461259f, 0.623661101f, 0.624859512f, 0.626056373f, 0.627251804f, 0.628445745f, 0.629638255f, 0.630829215f, 0.632018745f, 0.633206785f, 0.634393275f, 0.635578334f, 0.636761844f, 0.637943923f, 0.639124453f, 0.640303493f, 0.641481042f, 0.642657042f, 0.643831551f, 0.645004511f, 0.646176040f, 0.647345960f, 0.648514390f, 0.649681330f, 0.650846660f, 0.652010560f, 0.653172851f, 0.654333591f, 0.655492842f, 0.656650543f, 0.657806695f, 0.658961296f, 0.660114348f, 0.661265850f, 0.662415802f, 0.663564146f, 0.664710999f, 0.665856242f, 0.666999936f, 0.668142021f, 0.669282615f, 0.670421541f, 0.671558976f, 0.672694743f, 0.673829019f, 0.674961627f, 0.676092684f, 0.677222192f, 0.678350031f, 0.679476321f, 0.680601001f, 0.681724072f, 0.682845533f, 0.683965385f, 0.685083687f, 0.686200321f, 0.687315345f, 0.688428760f, 0.689540565f, 0.690650702f, 0.691759229f, 0.692866147f, 0.693971455f, 0.695075095f, 0.696177125f, 0.697277486f, 0.698376238f, 0.699473321f, 0.700568795f, 0.701662600f, 0.702754736f, 0.703845263f, 0.704934061f, 0.706021249f, 0.707106769f, 0.708190620f, 0.709272802f, 0.710353374f, 0.711432219f, 0.712509394f, 0.713584840f, 0.714658678f, 0.715730846f, 0.716801286f, 0.717870057f, 0.718937099f, 0.720002532f, 0.721066177f, 0.722128212f, 0.723188460f, 0.724247098f, 0.725303948f, 0.726359129f, 0.727412641f, 0.728464365f, 0.729514420f, 0.730562747f, 0.731609404f, 0.732654274f, 0.733697414f, 0.734738886f, 0.735778570f, 0.736816585f, 0.737852812f, 0.738887310f, 0.739920080f, 0.740951121f, 0.741980433f, 0.743007958f, 0.744033754f, 0.745057762f, 0.746080101f, 0.747100592f, 0.748119354f, 0.749136388f, 0.750151634f, 0.751165152f, 0.752176821f, 0.753186822f, 0.754194975f, 0.755201399f, 0.756205976f, 0.757208824f, 0.758209884f, 0.759209216f, 0.760206699f, 0.761202395f, 0.762196302f, 0.763188422f, 0.764178753f, 0.765167236f, 0.766153991f, 0.767138898f, 0.768122017f, 0.769103348f, 0.770082831f, 0.771060526f, 0.772036374f, 0.773010433f, 0.773982704f, 0.774953127f, 0.775921702f, 0.776888490f, 0.777853429f, 0.778816521f, 0.779777765f, 0.780737221f, 0.781694829f, 0.782650590f, 0.783604503f, 0.784556568f, 0.785506845f, 0.786455214f, 0.787401736f, 0.788346410f, 0.789289236f, 0.790230215f, 0.791169345f, 0.792106569f, 0.793041945f, 0.793975472f, 0.794907153f, 0.795836926f, 0.796764791f, 0.797690868f, 0.798614979f, 0.799537241f, 0.800457656f, 0.801376164f, 0.802292824f, 0.803207517f, 0.804120362f, 0.805031359f, 0.805940390f, 0.806847572f, 0.807752848f, 0.808656156f, 0.809557617f, 0.810457170f, 0.811354876f, 0.812250614f, 0.813144386f, 0.814036310f, 0.814926326f, 0.815814435f, 0.816700578f, 0.817584813f, 0.818467140f, 0.819347501f, 0.820225954f, 0.821102500f, 0.821977139f, 0.822849810f, 0.823720515f, 0.824589312f, 0.825456142f, 0.826321065f, 0.827184021f, 0.828045070f, 0.828904092f, 0.829761207f, 0.830616415f, 0.831469595f, 0.832320869f, 0.833170176f, 0.834017515f, 0.834862888f, 0.835706294f, 0.836547732f, 0.837387204f, 0.838224709f, 0.839060247f, 0.839893818f, 0.840725362f, 0.841554999f, 0.842382610f, 0.843208253f, 0.844031870f, 0.844853580f, 0.845673263f, 0.846490920f, 0.847306609f, 0.848120332f, 0.848932028f, 0.849741757f, 0.850549459f, 0.851355195f, 0.852158904f, 0.852960587f, 0.853760302f, 0.854557991f, 0.855353653f, 0.856147349f, 0.856938958f, 0.857728601f, 0.858516216f, 0.859301805f, 0.860085368f, 0.860866964f, 0.861646473f, 0.862423956f, 0.863199413f, 0.863972843f, 0.864744246f, 0.865513623f, 0.866280973f, 0.867046237f, 0.867809474f, 0.868570685f, 0.869329870f, 0.870086968f, 0.870842040f, 0.871595085f, 0.872346044f, 0.873094976f, 0.873841822f, 0.874586642f, 0.875329375f, 0.876070082f, 0.876808703f, 0.877545297f, 0.878279805f, 0.879012227f, 0.879742622f, 0.880470872f, 0.881197095f, 0.881921291f, 0.882643342f, 0.883363366f, 0.884081244f, 0.884797096f, 0.885510862f, 0.886222541f, 0.886932135f, 0.887639642f, 0.888345063f, 0.889048338f, 0.889749587f, 0.890448749f, 0.891145766f, 0.891840696f, 0.892533541f, 0.893224299f, 0.893912971f, 0.894599497f, 0.895283937f, 0.895966232f, 0.896646500f, 0.897324562f, 0.898000598f, 0.898674488f, 0.899346232f, 0.900015891f, 0.900683403f, 0.901348829f, 0.902012169f, 0.902673304f, 0.903332353f, 0.903989315f, 0.904644072f, 0.905296743f, 0.905947268f, 0.906595707f, 0.907242000f, 0.907886088f, 0.908528090f, 0.909168005f, 0.909805715f, 0.910441279f, 0.911074758f, 0.911706030f, 0.912335157f, 0.912962198f, 0.913587034f, 0.914209783f, 0.914830327f, 0.915448725f, 0.916064978f, 0.916679084f, 0.917290986f, 0.917900801f, 0.918508410f, 0.919113874f, 0.919717133f, 0.920318305f, 0.920917213f, 0.921514034f, 0.922108650f, 0.922701120f, 0.923291445f, 0.923879504f, 0.924465477f, 0.925049245f, 0.925630808f, 0.926210225f, 0.926787496f, 0.927362502f, 0.927935421f, 0.928506076f, 0.929074585f, 0.929640889f, 0.930205047f, 0.930766940f, 0.931326687f, 0.931884289f, 0.932439625f, 0.932992816f, 0.933543801f, 0.934092522f, 0.934639156f, 0.935183525f, 0.935725689f, 0.936265647f, 0.936803460f, 0.937339008f, 0.937872350f, 0.938403547f, 0.938932478f, 0.939459205f, 0.939983726f, 0.940506041f, 0.941026151f, 0.941544056f, 0.942059755f, 0.942573190f, 0.943084419f, 0.943593442f, 0.944100261f, 0.944604814f, 0.945107222f, 0.945607305f, 0.946105242f, 0.946600914f, 0.947094381f, 0.947585583f, 0.948074579f, 0.948561370f, 0.949045897f, 0.949528158f, 0.950008273f, 0.950486064f, 0.950961649f, 0.951435030f, 0.951906145f, 0.952374995f, 0.952841640f, 0.953306019f, 0.953768194f, 0.954228103f, 0.954685748f, 0.955141187f, 0.955594361f, 0.956045270f, 0.956493914f, 0.956940353f, 0.957384527f, 0.957826436f, 0.958266079f, 0.958703458f, 0.959138632f, 0.959571540f, 0.960002124f, 0.960430503f, 0.960856616f, 0.961280465f, 0.961702049f, 0.962121427f, 0.962538481f, 0.962953269f, 0.963365793f, 0.963776052f, 0.964184046f, 0.964589775f, 0.964993238f, 0.965394437f, 0.965793371f, 0.966189981f, 0.966584384f, 0.966976464f, 0.967366278f, 0.967753828f, 0.968139112f, 0.968522072f, 0.968902826f, 0.969281256f, 0.969657362f, 0.970031261f, 0.970402837f, 0.970772147f, 0.971139133f, 0.971503913f, 0.971866310f, 0.972226501f, 0.972584367f, 0.972939968f, 0.973293245f, 0.973644257f, 0.973992944f, 0.974339366f, 0.974683523f, 0.975025356f, 0.975364864f, 0.975702107f, 0.976037085f, 0.976369739f, 0.976700068f, 0.977028131f, 0.977353871f, 0.977677345f, 0.977998495f, 0.978317380f, 0.978633940f, 0.978948176f, 0.979260147f, 0.979569793f, 0.979877114f, 0.980182111f, 0.980484843f, 0.980785251f, 0.981083393f, 0.981379211f, 0.981672704f, 0.981963873f, 0.982252717f, 0.982539296f, 0.982823551f, 0.983105481f, 0.983385086f, 0.983662426f, 0.983937442f, 0.984210074f, 0.984480441f, 0.984748483f, 0.985014260f, 0.985277653f, 0.985538721f, 0.985797524f, 0.986053944f, 0.986308098f, 0.986559927f, 0.986809373f, 0.987056553f, 0.987301409f, 0.987543941f, 0.987784147f, 0.988022029f, 0.988257587f, 0.988490820f, 0.988721669f, 0.988950253f, 0.989176512f, 0.989400446f, 0.989621997f, 0.989841282f, 0.990058184f, 0.990272820f, 0.990485072f, 0.990695000f, 0.990902662f, 0.991107941f, 0.991310835f, 0.991511464f, 0.991709769f, 0.991905689f, 0.992099285f, 0.992290616f, 0.992479563f, 0.992666125f, 0.992850423f, 0.993032336f, 0.993211925f, 0.993389189f, 0.993564129f, 0.993736744f, 0.993906975f, 0.994074881f, 0.994240463f, 0.994403660f, 0.994564593f, 0.994723141f, 0.994879305f, 0.995033205f, 0.995184720f, 0.995333910f, 0.995480776f, 0.995625257f, 0.995767415f, 0.995907247f, 0.996044695f, 0.996179819f, 0.996312618f, 0.996443033f, 0.996571124f, 0.996696889f, 0.996820271f, 0.996941328f, 0.997060061f, 0.997176409f, 0.997290432f, 0.997402132f, 0.997511446f, 0.997618437f, 0.997723043f, 0.997825325f, 0.997925282f, 0.998022854f, 0.998118103f, 0.998211026f, 0.998301566f, 0.998389721f, 0.998475552f, 0.998559058f, 0.998640239f, 0.998719037f, 0.998795450f, 0.998869538f, 0.998941302f, 0.999010682f, 0.999077737f, 0.999142408f, 0.999204755f, 0.999264777f, 0.999322355f, 0.999377668f, 0.999430597f, 0.999481201f, 0.999529421f, 0.999575317f, 0.999618828f, 0.999660015f, 0.999698818f, 0.999735296f, 0.999769390f, 0.999801159f, 0.999830604f, 0.999857664f, 0.999882340f, 0.999904692f, 0.999924719f, 0.999942362f, 0.999957621f, 0.999970615f, 0.999981165f, 0.999989390f, 0.999995291f, 0.999998808f, 1.000000000f, 0.999998808f, 0.999995291f, 0.999989390f, 0.999981165f, 0.999970615f, 0.999957621f, 0.999942362f, 0.999924719f, 0.999904692f, 0.999882340f, 0.999857664f, 0.999830604f, 0.999801159f, 0.999769390f, 0.999735296f, 0.999698818f, 0.999660015f, 0.999618828f, 0.999575317f, 0.999529421f, 0.999481201f, 0.999430597f, 0.999377668f, 0.999322355f, 0.999264777f, 0.999204755f, 0.999142408f, 0.999077737f, 0.999010682f, 0.998941302f, 0.998869538f, 0.998795450f, 0.998719037f, 0.998640239f, 0.998559058f, 0.998475552f, 0.998389721f, 0.998301566f, 0.998211026f, 0.998118103f, 0.998022854f, 0.997925282f, 0.997825325f, 0.997723043f, 0.997618437f, 0.997511446f, 0.997402132f, 0.997290432f, 0.997176409f, 0.997060061f, 0.996941328f, 0.996820271f, 0.996696889f, 0.996571124f, 0.996443033f, 0.996312618f, 0.996179819f, 0.996044695f, 0.995907247f, 0.995767415f, 0.995625257f, 0.995480776f, 0.995333910f, 0.995184720f, 0.995033205f, 0.994879305f, 0.994723141f, 0.994564593f, 0.994403660f, 0.994240463f, 0.994074881f, 0.993906975f, 0.993736744f, 0.993564129f, 0.993389189f, 0.993211925f, 0.993032336f, 0.992850423f, 0.992666125f, 0.992479563f, 0.992290616f, 0.992099285f, 0.991905689f, 0.991709769f, 0.991511464f, 0.991310835f, 0.991107941f, 0.990902662f, 0.990695000f, 0.990485072f, 0.990272820f, 0.990058184f, 0.989841282f, 0.989621997f, 0.989400446f, 0.989176512f, 0.988950253f, 0.988721669f, 0.988490820f, 0.988257587f, 0.988022029f, 0.987784147f, 0.987543941f, 0.987301409f, 0.987056553f, 0.986809373f, 0.986559927f, 0.986308098f, 0.986053944f, 0.985797524f, 0.985538721f, 0.985277653f, 0.985014260f, 0.984748483f, 0.984480441f, 0.984210074f, 0.983937442f, 0.983662426f, 0.983385086f, 0.983105481f, 0.982823551f, 0.982539296f, 0.982252717f, 0.981963873f, 0.981672704f, 0.981379211f, 0.981083393f, 0.980785251f, 0.980484843f, 0.980182111f, 0.979877114f, 0.979569793f, 0.979260147f, 0.978948176f, 0.978633940f, 0.978317380f, 0.977998495f, 0.977677345f, 0.977353871f, 0.977028131f, 0.976700068f, 0.976369739f, 0.976037085f, 0.975702107f, 0.975364864f, 0.975025356f, 0.974683523f, 0.974339366f, 0.973992944f, 0.973644257f, 0.973293245f, 0.972939968f, 0.972584367f, 0.972226501f, 0.971866310f, 0.971503913f, 0.971139133f, 0.970772147f, 0.970402837f, 0.970031261f, 0.969657362f, 0.969281256f, 0.968902826f, 0.968522072f, 0.968139112f, 0.967753828f, 0.967366278f, 0.966976464f, 0.966584384f, 0.966189981f, 0.965793371f, 0.965394437f, 0.964993238f, 0.964589775f, 0.964184046f, 0.963776052f, 0.963365793f, 0.962953269f, 0.962538481f, 0.962121427f, 0.961702049f, 0.961280465f, 0.960856616f, 0.960430503f, 0.960002124f, 0.959571540f, 0.959138632f, 0.958703458f, 0.958266079f, 0.957826436f, 0.957384527f, 0.956940353f, 0.956493914f, 0.956045270f, 0.955594361f, 0.955141187f, 0.954685748f, 0.954228103f, 0.953768194f, 0.953306019f, 0.952841640f, 0.952374995f, 0.951906145f, 0.951435030f, 0.950961649f, 0.950486064f, 0.950008273f, 0.949528158f, 0.949045897f, 0.948561370f, 0.948074579f, 0.947585583f, 0.947094381f, 0.946600914f, 0.946105242f, 0.945607305f, 0.945107222f, 0.944604814f, 0.944100261f, 0.943593442f, 0.943084419f, 0.942573190f, 0.942059755f, 0.941544056f, 0.941026151f, 0.940506041f, 0.939983726f, 0.939459205f, 0.938932478f, 0.938403547f, 0.937872350f, 0.937339008f, 0.936803460f, 0.936265647f, 0.935725689f, 0.935183525f, 0.934639156f, 0.934092522f, 0.933543801f, 0.932992816f, 0.932439625f, 0.931884289f, 0.931326687f, 0.930766940f, 0.930205047f, 0.929640889f, 0.929074585f, 0.928506076f, 0.927935421f, 0.927362502f, 0.926787496f, 0.926210225f, 0.925630808f, 0.925049245f, 0.924465477f, 0.923879504f, 0.923291445f, 0.922701120f, 0.922108650f, 0.921514034f, 0.920917213f, 0.920318305f, 0.919717133f, 0.919113874f, 0.918508410f, 0.917900801f, 0.917290986f, 0.916679084f, 0.916064978f, 0.915448725f, 0.914830327f, 0.914209783f, 0.913587034f, 0.912962198f, 0.912335157f, 0.911706030f, 0.911074758f, 0.910441279f, 0.909805715f, 0.909168005f, 0.908528090f, 0.907886088f, 0.907242000f, 0.906595707f, 0.905947268f, 0.905296743f, 0.904644072f, 0.903989315f, 0.903332353f, 0.902673304f, 0.902012169f, 0.901348829f, 0.900683403f, 0.900015891f, 0.899346232f, 0.898674488f, 0.898000598f, 0.897324562f, 0.896646500f, 0.895966232f, 0.895283937f, 0.894599497f, 0.893912971f, 0.893224299f, 0.892533541f, 0.891840696f, 0.891145766f, 0.890448749f, 0.889749587f, 0.889048338f, 0.888345063f, 0.887639642f, 0.886932135f, 0.886222541f, 0.885510862f, 0.884797096f, 0.884081244f, 0.883363366f, 0.882643342f, 0.881921291f, 0.881197095f, 0.880470872f, 0.879742622f, 0.879012227f, 0.878279805f, 0.877545297f, 0.876808703f, 0.876070082f, 0.875329375f, 0.874586642f, 0.873841822f, 0.873094976f, 0.872346044f, 0.871595085f, 0.870842040f, 0.870086968f, 0.869329870f, 0.868570685f, 0.867809474f, 0.867046237f, 0.866280973f, 0.865513623f, 0.864744246f, 0.863972843f, 0.863199413f, 0.862423956f, 0.861646473f, 0.860866964f, 0.860085368f, 0.859301805f, 0.858516216f, 0.857728601f, 0.856938958f, 0.856147349f, 0.855353653f, 0.854557991f, 0.853760302f, 0.852960587f, 0.852158904f, 0.851355195f, 0.850549459f, 0.849741757f, 0.848932028f, 0.848120332f, 0.847306609f, 0.846490920f, 0.845673263f, 0.844853580f, 0.844031870f, 0.843208253f, 0.842382610f, 0.841554999f, 0.840725362f, 0.839893818f, 0.839060247f, 0.838224709f, 0.837387204f, 0.836547732f, 0.835706294f, 0.834862888f, 0.834017515f, 0.833170176f, 0.832320869f, 0.831469595f, 0.830616415f, 0.829761207f, 0.828904092f, 0.828045070f, 0.827184021f, 0.826321065f, 0.825456142f, 0.824589312f, 0.823720515f, 0.822849810f, 0.821977139f, 0.821102500f, 0.820225954f, 0.819347501f, 0.818467140f, 0.817584813f, 0.816700578f, 0.815814435f, 0.814926326f, 0.814036310f, 0.813144386f, 0.812250614f, 0.811354876f, 0.810457170f, 0.809557617f, 0.808656156f, 0.807752848f, 0.806847572f, 0.805940390f, 0.805031359f, 0.804120362f, 0.803207517f, 0.802292824f, 0.801376164f, 0.800457656f, 0.799537241f, 0.798614979f, 0.797690868f, 0.796764791f, 0.795836926f, 0.794907153f, 0.793975472f, 0.793041945f, 0.792106569f, 0.791169345f, 0.790230215f, 0.789289236f, 0.788346410f, 0.787401736f, 0.786455214f, 0.785506845f, 0.784556568f, 0.783604503f, 0.782650590f, 0.781694829f, 0.780737221f, 0.779777765f, 0.778816521f, 0.777853429f, 0.776888490f, 0.775921702f, 0.774953127f, 0.773982704f, 0.773010433f, 0.772036374f, 0.771060526f, 0.770082831f, 0.769103348f, 0.768122017f, 0.767138898f, 0.766153991f, 0.765167236f, 0.764178753f, 0.763188422f, 0.762196302f, 0.761202395f, 0.760206699f, 0.759209216f, 0.758209884f, 0.757208824f, 0.756205976f, 0.755201399f, 0.754194975f, 0.753186822f, 0.752176821f, 0.751165152f, 0.750151634f, 0.749136388f, 0.748119354f, 0.747100592f, 0.746080101f, 0.745057762f, 0.744033754f, 0.743007958f, 0.741980433f, 0.740951121f, 0.739920080f, 0.738887310f, 0.737852812f, 0.736816585f, 0.735778570f, 0.734738886f, 0.733697414f, 0.732654274f, 0.731609404f, 0.730562747f, 0.729514420f, 0.728464365f, 0.727412641f, 0.726359129f, 0.725303948f, 0.724247098f, 0.723188460f, 0.722128212f, 0.721066177f, 0.720002532f, 0.718937099f, 0.717870057f, 0.716801286f, 0.715730846f, 0.714658678f, 0.713584840f, 0.712509394f, 0.711432219f, 0.710353374f, 0.709272802f, 0.708190620f, 0.707106769f, 0.706021249f, 0.704934061f, 0.703845263f, 0.702754736f, 0.701662600f, 0.700568795f, 0.699473321f, 0.698376238f, 0.697277486f, 0.696177125f, 0.695075095f, 0.693971455f, 0.692866147f, 0.691759229f, 0.690650702f, 0.689540565f, 0.688428760f, 0.687315345f, 0.686200321f, 0.685083687f, 0.683965385f, 0.682845533f, 0.681724072f, 0.680601001f, 0.679476321f, 0.678350031f, 0.677222192f, 0.676092684f, 0.674961627f, 0.673829019f, 0.672694743f, 0.671558976f, 0.670421541f, 0.669282615f, 0.668142021f, 0.666999936f, 0.665856242f, 0.664710999f, 0.663564146f, 0.662415802f, 0.661265850f, 0.660114348f, 0.658961296f, 0.657806695f, 0.656650543f, 0.655492842f, 0.654333591f, 0.653172851f, 0.652010560f, 0.650846660f, 0.649681330f, 0.648514390f, 0.647345960f, 0.646176040f, 0.645004511f, 0.643831551f, 0.642657042f, 0.641481042f, 0.640303493f, 0.639124453f, 0.637943923f, 0.636761844f, 0.635578334f, 0.634393275f, 0.633206785f, 0.632018745f, 0.630829215f, 0.629638255f, 0.628445745f, 0.627251804f, 0.626056373f, 0.624859512f, 0.623661101f, 0.622461259f, 0.621259987f, 0.620057225f, 0.618852973f, 0.617647290f, 0.616440177f, 0.615231574f, 0.614021540f, 0.612810075f, 0.611597180f, 0.610382795f, 0.609167039f, 0.607949793f, 0.606731117f, 0.605511069f, 0.604289532f, 0.603066623f, 0.601842225f, 0.600616455f, 0.599389315f, 0.598160684f, 0.596930683f, 0.595699310f, 0.594466507f, 0.593232274f, 0.591996670f, 0.590759695f, 0.589521289f, 0.588281572f, 0.587040365f, 0.585797846f, 0.584553957f, 0.583308637f, 0.582062006f, 0.580813944f, 0.579564571f, 0.578313768f, 0.577061653f, 0.575808167f, 0.574553370f, 0.573297143f, 0.572039604f, 0.570780754f, 0.569520533f, 0.568258941f, 0.566996038f, 0.565731823f, 0.564466238f, 0.563199341f, 0.561931133f, 0.560661554f, 0.559390724f, 0.558118522f, 0.556845009f, 0.555570245f, 0.554294109f, 0.553016722f, 0.551737964f, 0.550457954f, 0.549176633f, 0.547894061f, 0.546610177f, 0.545324981f, 0.544038534f, 0.542750776f, 0.541461766f, 0.540171444f, 0.538879931f, 0.537587047f, 0.536292970f, 0.534997642f, 0.533701003f, 0.532403111f, 0.531104028f, 0.529803634f, 0.528501987f, 0.527199149f, 0.525895000f, 0.524589658f, 0.523283124f, 0.521975279f, 0.520666242f, 0.519356012f, 0.518044531f, 0.516731799f, 0.515417874f, 0.514102757f, 0.512786388f, 0.511468828f, 0.510150075f, 0.508830130f, 0.507508993f, 0.506186664f, 0.504863083f, 0.503538370f, 0.502212465f, 0.500885367f, 0.499557108f, 0.498227656f, 0.496897042f, 0.495565265f, 0.494232297f, 0.492898196f, 0.491562903f, 0.490226477f, 0.488888890f, 0.487550169f, 0.486210287f, 0.484869242f, 0.483527064f, 0.482183784f, 0.480839342f, 0.479493767f, 0.478147060f, 0.476799220f, 0.475450277f, 0.474100202f, 0.472749025f, 0.471396744f, 0.470043331f, 0.468688816f, 0.467333198f, 0.465976506f, 0.464618683f, 0.463259786f, 0.461899787f, 0.460538715f, 0.459176540f, 0.457813293f, 0.456448972f, 0.455083579f, 0.453717113f, 0.452349573f, 0.450980991f, 0.449611336f, 0.448240608f, 0.446868837f, 0.445496023f, 0.444122136f, 0.442747235f, 0.441371262f, 0.439994276f, 0.438616246f, 0.437237173f, 0.435857087f, 0.434475958f, 0.433093816f, 0.431710660f, 0.430326492f, 0.428941280f, 0.427555084f, 0.426167876f, 0.424779683f, 0.423390478f, 0.422000259f, 0.420609087f, 0.419216901f, 0.417823702f, 0.416429549f, 0.415034413f, 0.413638324f, 0.412241220f, 0.410843164f, 0.409444153f, 0.408044159f, 0.406643212f, 0.405241311f, 0.403838456f, 0.402434647f, 0.401029885f, 0.399624199f, 0.398217559f, 0.396809995f, 0.395401478f, 0.393992037f, 0.392581671f, 0.391170382f, 0.389758170f, 0.388345033f, 0.386931002f, 0.385516047f, 0.384100199f, 0.382683426f, 0.381265759f, 0.379847199f, 0.378427744f, 0.377007425f, 0.375586182f, 0.374164075f, 0.372741073f, 0.371317208f, 0.369892448f, 0.368466824f, 0.367040336f, 0.365612984f, 0.364184797f, 0.362755716f, 0.361325800f, 0.359895051f, 0.358463407f, 0.357030958f, 0.355597675f, 0.354163527f, 0.352728546f, 0.351292759f, 0.349856138f, 0.348418683f, 0.346980423f, 0.345541328f, 0.344101429f, 0.342660725f, 0.341219217f, 0.339776874f, 0.338333756f, 0.336889863f, 0.335445136f, 0.333999664f, 0.332553357f, 0.331106305f, 0.329658449f, 0.328209847f, 0.326760441f, 0.325310290f, 0.323859364f, 0.322407693f, 0.320955247f, 0.319502026f, 0.318048090f, 0.316593379f, 0.315137923f, 0.313681751f, 0.312224805f, 0.310767144f, 0.309308767f, 0.307849646f, 0.306389809f, 0.304929227f, 0.303467959f, 0.302005947f, 0.300543249f, 0.299079835f, 0.297615707f, 0.296150893f, 0.294685364f, 0.293219149f, 0.291752249f, 0.290284663f, 0.288816422f, 0.287347466f, 0.285877824f, 0.284407526f, 0.282936573f, 0.281464934f, 0.279992640f, 0.278519690f, 0.277046084f, 0.275571823f, 0.274096906f, 0.272621363f, 0.271145165f, 0.269668311f, 0.268190861f, 0.266712755f, 0.265234023f, 0.263754666f, 0.262274712f, 0.260794103f, 0.259312928f, 0.257831097f, 0.256348670f, 0.254865646f, 0.253382027f, 0.251897812f, 0.250413001f, 0.248927608f, 0.247441620f, 0.245955050f, 0.244467899f, 0.242980182f, 0.241491884f, 0.240003020f, 0.238513589f, 0.237023607f, 0.235533059f, 0.234041959f, 0.232550308f, 0.231058106f, 0.229565367f, 0.228072077f, 0.226578265f, 0.225083917f, 0.223589033f, 0.222093627f, 0.220597684f, 0.219101235f, 0.217604280f, 0.216106802f, 0.214608818f, 0.213110313f, 0.211611331f, 0.210111842f, 0.208611846f, 0.207111374f, 0.205610409f, 0.204108968f, 0.202607036f, 0.201104641f, 0.199601755f, 0.198098406f, 0.196594596f, 0.195090324f, 0.193585590f, 0.192080393f, 0.190574750f, 0.189068660f, 0.187562123f, 0.186055154f, 0.184547737f, 0.183039889f, 0.181531608f, 0.180022895f, 0.178513765f, 0.177004218f, 0.175494254f, 0.173983872f, 0.172473088f, 0.170961887f, 0.169450298f, 0.167938292f, 0.166425899f, 0.164913118f, 0.163399950f, 0.161886394f, 0.160372451f, 0.158858150f, 0.157343462f, 0.155828401f, 0.154312968f, 0.152797192f, 0.151281044f, 0.149764538f, 0.148247674f, 0.146730468f, 0.145212919f, 0.143695027f, 0.142176807f, 0.140658244f, 0.139139339f, 0.137620121f, 0.136100575f, 0.134580702f, 0.133060530f, 0.131540030f, 0.130019218f, 0.128498107f, 0.126976699f, 0.125454977f, 0.123932973f, 0.122410677f, 0.120888084f, 0.119365215f, 0.117842063f, 0.116318628f, 0.114794925f, 0.113270953f, 0.111746714f, 0.110222206f, 0.108697444f, 0.107172422f, 0.105647154f, 0.104121633f, 0.102595866f, 0.101069860f, 0.099543616f, 0.098017141f, 0.096490428f, 0.094963498f, 0.093436338f, 0.091908954f, 0.090381362f, 0.088853553f, 0.087325536f, 0.085797310f, 0.084268890f, 0.082740262f, 0.081211448f, 0.079682440f, 0.078153245f, 0.076623864f, 0.075094298f, 0.073564567f, 0.072034650f, 0.070504576f, 0.068974331f, 0.067443922f, 0.065913349f, 0.064382628f, 0.062851757f, 0.061320737f, 0.059789572f, 0.058258265f, 0.056726821f, 0.055195246f, 0.053663537f, 0.052131705f, 0.050599750f, 0.049067676f, 0.047535483f, 0.046003181f, 0.044470772f, 0.042938258f, 0.041405641f, 0.039872926f, 0.038340122f, 0.036807224f, 0.035274237f, 0.033741172f, 0.032208025f, 0.030674804f, 0.029141508f, 0.027608145f, 0.026074719f, 0.024541229f, 0.023007682f, 0.021474080f, 0.019940428f, 0.018406730f, 0.016872987f, 0.015339206f, 0.0138053885f, 0.012271538f, 0.010737659f, 0.009203754f, 0.007669829f, 0.0061358847f, 0.004601926f, 0.0030679568f, 0.0015339801f, 0.000000000f, -0.0015339801f, -0.0030679568f, -0.004601926f, -0.0061358847f, -0.007669829f, -0.009203754f, -0.010737659f, -0.012271538f, -0.0138053885f, -0.015339206f, -0.016872987f, -0.018406730f, -0.019940428f, -0.021474080f, -0.023007682f, -0.024541229f, -0.026074719f, -0.027608145f, -0.029141508f, -0.030674804f, -0.032208025f, -0.033741172f, -0.035274237f, -0.036807224f, -0.038340122f, -0.039872926f, -0.041405641f, -0.042938258f, -0.044470772f, -0.046003181f, -0.047535483f, -0.049067676f, -0.050599750f, -0.052131705f, -0.053663537f, -0.055195246f, -0.056726821f, -0.058258265f, -0.059789572f, -0.061320737f, -0.062851757f, -0.064382628f, -0.065913349f, -0.067443922f, -0.068974331f, -0.070504576f, -0.072034650f, -0.073564567f, -0.075094298f, -0.076623864f, -0.078153245f, -0.079682440f, -0.081211448f, -0.082740262f, -0.084268890f, -0.085797310f, -0.087325536f, -0.088853553f, -0.090381362f, -0.091908954f, -0.093436338f, -0.094963498f, -0.096490428f, -0.098017141f, -0.099543616f, -0.101069860f, -0.102595866f, -0.104121633f, -0.105647154f, -0.107172422f, -0.108697444f, -0.110222206f, -0.111746714f, -0.113270953f, -0.114794925f, -0.116318628f, -0.117842063f, -0.119365215f, -0.120888084f, -0.122410677f, -0.123932973f, -0.125454977f, -0.126976699f, -0.128498107f, -0.130019218f, -0.131540030f, -0.133060530f, -0.134580702f, -0.136100575f, -0.137620121f, -0.139139339f, -0.140658244f, -0.142176807f, -0.143695027f, -0.145212919f, -0.146730468f, -0.148247674f, -0.149764538f, -0.151281044f, -0.152797192f, -0.154312968f, -0.155828401f, -0.157343462f, -0.158858150f, -0.160372451f, -0.161886394f, -0.163399950f, -0.164913118f, -0.166425899f, -0.167938292f, -0.169450298f, -0.170961887f, -0.172473088f, -0.173983872f, -0.175494254f, -0.177004218f, -0.178513765f, -0.180022895f, -0.181531608f, -0.183039889f, -0.184547737f, -0.186055154f, -0.187562123f, -0.189068660f, -0.190574750f, -0.192080393f, -0.193585590f, -0.195090324f, -0.196594596f, -0.198098406f, -0.199601755f, -0.201104641f, -0.202607036f, -0.204108968f, -0.205610409f, -0.207111374f, -0.208611846f, -0.210111842f, -0.211611331f, -0.213110313f, -0.214608818f, -0.216106802f, -0.217604280f, -0.219101235f, -0.220597684f, -0.222093627f, -0.223589033f, -0.225083917f, -0.226578265f, -0.228072077f, -0.229565367f, -0.231058106f, -0.232550308f, -0.234041959f, -0.235533059f, -0.237023607f, -0.238513589f, -0.240003020f, -0.241491884f, -0.242980182f, -0.244467899f, -0.245955050f, -0.247441620f, -0.248927608f, -0.250413001f, -0.251897812f, -0.253382027f, -0.254865646f, -0.256348670f, -0.257831097f, -0.259312928f, -0.260794103f, -0.262274712f, -0.263754666f, -0.265234023f, -0.266712755f, -0.268190861f, -0.269668311f, -0.271145165f, -0.272621363f, -0.274096906f, -0.275571823f, -0.277046084f, -0.278519690f, -0.279992640f, -0.281464934f, -0.282936573f, -0.284407526f, -0.285877824f, -0.287347466f, -0.288816422f, -0.290284663f, -0.291752249f, -0.293219149f, -0.294685364f, -0.296150893f, -0.297615707f, -0.299079835f, -0.300543249f, -0.302005947f, -0.303467959f, -0.304929227f, -0.306389809f, -0.307849646f, -0.309308767f, -0.310767144f, -0.312224805f, -0.313681751f, -0.315137923f, -0.316593379f, -0.318048090f, -0.319502026f, -0.320955247f, -0.322407693f, -0.323859364f, -0.325310290f, -0.326760441f, -0.328209847f, -0.329658449f, -0.331106305f, -0.332553357f, -0.333999664f, -0.335445136f, -0.336889863f, -0.338333756f, -0.339776874f, -0.341219217f, -0.342660725f, -0.344101429f, -0.345541328f, -0.346980423f, -0.348418683f, -0.349856138f, -0.351292759f, -0.352728546f, -0.354163527f, -0.355597675f, -0.357030958f, -0.358463407f, -0.359895051f, -0.361325800f, -0.362755716f, -0.364184797f, -0.365612984f, -0.367040336f, -0.368466824f, -0.369892448f, -0.371317208f, -0.372741073f, -0.374164075f, -0.375586182f, -0.377007425f, -0.378427744f, -0.379847199f, -0.381265759f, -0.382683426f, -0.384100199f, -0.385516047f, -0.386931002f, -0.388345033f, -0.389758170f, -0.391170382f, -0.392581671f, -0.393992037f, -0.395401478f, -0.396809995f, -0.398217559f, -0.399624199f, -0.401029885f, -0.402434647f, -0.403838456f, -0.405241311f, -0.406643212f, -0.408044159f, -0.409444153f, -0.410843164f, -0.412241220f, -0.413638324f, -0.415034413f, -0.416429549f, -0.417823702f, -0.419216901f, -0.420609087f, -0.422000259f, -0.423390478f, -0.424779683f, -0.426167876f, -0.427555084f, -0.428941280f, -0.430326492f, -0.431710660f, -0.433093816f, -0.434475958f, -0.435857087f, -0.437237173f, -0.438616246f, -0.439994276f, -0.441371262f, -0.442747235f, -0.444122136f, -0.445496023f, -0.446868837f, -0.448240608f, -0.449611336f, -0.450980991f, -0.452349573f, -0.453717113f, -0.455083579f, -0.456448972f, -0.457813293f, -0.459176540f, -0.460538715f, -0.461899787f, -0.463259786f, -0.464618683f, -0.465976506f, -0.467333198f, -0.468688816f, -0.470043331f, -0.471396744f, -0.472749025f, -0.474100202f, -0.475450277f, -0.476799220f, -0.478147060f, -0.479493767f, -0.480839342f, -0.482183784f, -0.483527064f, -0.484869242f, -0.486210287f, -0.487550169f, -0.488888890f, -0.490226477f, -0.491562903f, -0.492898196f, -0.494232297f, -0.495565265f, -0.496897042f, -0.498227656f, -0.499557108f, -0.500885367f, -0.502212465f, -0.503538370f, -0.504863083f, -0.506186664f, -0.507508993f, -0.508830130f, -0.510150075f, -0.511468828f, -0.512786388f, -0.514102757f, -0.515417874f, -0.516731799f, -0.518044531f, -0.519356012f, -0.520666242f, -0.521975279f, -0.523283124f, -0.524589658f, -0.525895000f, -0.527199149f, -0.528501987f, -0.529803634f, -0.531104028f, -0.532403111f, -0.533701003f, -0.534997642f, -0.536292970f, -0.537587047f, -0.538879931f, -0.540171444f, -0.541461766f, -0.542750776f, -0.544038534f, -0.545324981f, -0.546610177f, -0.547894061f, -0.549176633f, -0.550457954f, -0.551737964f, -0.553016722f, -0.554294109f, -0.555570245f, -0.556845009f, -0.558118522f, -0.559390724f, -0.560661554f, -0.561931133f, -0.563199341f, -0.564466238f, -0.565731823f, -0.566996038f, -0.568258941f, -0.569520533f, -0.570780754f, -0.572039604f, -0.573297143f, -0.574553370f, -0.575808167f, -0.577061653f, -0.578313768f, -0.579564571f, -0.580813944f, -0.582062006f, -0.583308637f, -0.584553957f, -0.585797846f, -0.587040365f, -0.588281572f, -0.589521289f, -0.590759695f, -0.591996670f, -0.593232274f, -0.594466507f, -0.595699310f, -0.596930683f, -0.598160684f, -0.599389315f, -0.600616455f, -0.601842225f, -0.603066623f, -0.604289532f, -0.605511069f, -0.606731117f, -0.607949793f, -0.609167039f, -0.610382795f, -0.611597180f, -0.612810075f, -0.614021540f, -0.615231574f, -0.616440177f, -0.617647290f, -0.618852973f, -0.620057225f, -0.621259987f, -0.622461259f, -0.623661101f, -0.624859512f, -0.626056373f, -0.627251804f, -0.628445745f, -0.629638255f, -0.630829215f, -0.632018745f, -0.633206785f, -0.634393275f, -0.635578334f, -0.636761844f, -0.637943923f, -0.639124453f, -0.640303493f, -0.641481042f, -0.642657042f, -0.643831551f, -0.645004511f, -0.646176040f, -0.647345960f, -0.648514390f, -0.649681330f, -0.650846660f, -0.652010560f, -0.653172851f, -0.654333591f, -0.655492842f, -0.656650543f, -0.657806695f, -0.658961296f, -0.660114348f, -0.661265850f, -0.662415802f, -0.663564146f, -0.664710999f, -0.665856242f, -0.666999936f, -0.668142021f, -0.669282615f, -0.670421541f, -0.671558976f, -0.672694743f, -0.673829019f, -0.674961627f, -0.676092684f, -0.677222192f, -0.678350031f, -0.679476321f, -0.680601001f, -0.681724072f, -0.682845533f, -0.683965385f, -0.685083687f, -0.686200321f, -0.687315345f, -0.688428760f, -0.689540565f, -0.690650702f, -0.691759229f, -0.692866147f, -0.693971455f, -0.695075095f, -0.696177125f, -0.697277486f, -0.698376238f, -0.699473321f, -0.700568795f, -0.701662600f, -0.702754736f, -0.703845263f, -0.704934061f, -0.706021249f, -0.707106769f, -0.708190620f, -0.709272802f, -0.710353374f, -0.711432219f, -0.712509394f, -0.713584840f, -0.714658678f, -0.715730846f, -0.716801286f, -0.717870057f, -0.718937099f, -0.720002532f, -0.721066177f, -0.722128212f, -0.723188460f, -0.724247098f, -0.725303948f, -0.726359129f, -0.727412641f, -0.728464365f, -0.729514420f, -0.730562747f, -0.731609404f, -0.732654274f, -0.733697414f, -0.734738886f, -0.735778570f, -0.736816585f, -0.737852812f, -0.738887310f, -0.739920080f, -0.740951121f, -0.741980433f, -0.743007958f, -0.744033754f, -0.745057762f, -0.746080101f, -0.747100592f, -0.748119354f, -0.749136388f, -0.750151634f, -0.751165152f, -0.752176821f, -0.753186822f, -0.754194975f, -0.755201399f, -0.756205976f, -0.757208824f, -0.758209884f, -0.759209216f, -0.760206699f, -0.761202395f, -0.762196302f, -0.763188422f, -0.764178753f, -0.765167236f, -0.766153991f, -0.767138898f, -0.768122017f, -0.769103348f, -0.770082831f, -0.771060526f, -0.772036374f, -0.773010433f, -0.773982704f, -0.774953127f, -0.775921702f, -0.776888490f, -0.777853429f, -0.778816521f, -0.779777765f, -0.780737221f, -0.781694829f, -0.782650590f, -0.783604503f, -0.784556568f, -0.785506845f, -0.786455214f, -0.787401736f, -0.788346410f, -0.789289236f, -0.790230215f, -0.791169345f, -0.792106569f, -0.793041945f, -0.793975472f, -0.794907153f, -0.795836926f, -0.796764791f, -0.797690868f, -0.798614979f, -0.799537241f, -0.800457656f, -0.801376164f, -0.802292824f, -0.803207517f, -0.804120362f, -0.805031359f, -0.805940390f, -0.806847572f, -0.807752848f, -0.808656156f, -0.809557617f, -0.810457170f, -0.811354876f, -0.812250614f, -0.813144386f, -0.814036310f, -0.814926326f, -0.815814435f, -0.816700578f, -0.817584813f, -0.818467140f, -0.819347501f, -0.820225954f, -0.821102500f, -0.821977139f, -0.822849810f, -0.823720515f, -0.824589312f, -0.825456142f, -0.826321065f, -0.827184021f, -0.828045070f, -0.828904092f, -0.829761207f, -0.830616415f, -0.831469595f, -0.832320869f, -0.833170176f, -0.834017515f, -0.834862888f, -0.835706294f, -0.836547732f, -0.837387204f, -0.838224709f, -0.839060247f, -0.839893818f, -0.840725362f, -0.841554999f, -0.842382610f, -0.843208253f, -0.844031870f, -0.844853580f, -0.845673263f, -0.846490920f, -0.847306609f, -0.848120332f, -0.848932028f, -0.849741757f, -0.850549459f, -0.851355195f, -0.852158904f, -0.852960587f, -0.853760302f, -0.854557991f, -0.855353653f, -0.856147349f, -0.856938958f, -0.857728601f, -0.858516216f, -0.859301805f, -0.860085368f, -0.860866964f, -0.861646473f, -0.862423956f, -0.863199413f, -0.863972843f, -0.864744246f, -0.865513623f, -0.866280973f, -0.867046237f, -0.867809474f, -0.868570685f, -0.869329870f, -0.870086968f, -0.870842040f, -0.871595085f, -0.872346044f, -0.873094976f, -0.873841822f, -0.874586642f, -0.875329375f, -0.876070082f, -0.876808703f, -0.877545297f, -0.878279805f, -0.879012227f, -0.879742622f, -0.880470872f, -0.881197095f, -0.881921291f, -0.882643342f, -0.883363366f, -0.884081244f, -0.884797096f, -0.885510862f, -0.886222541f, -0.886932135f, -0.887639642f, -0.888345063f, -0.889048338f, -0.889749587f, -0.890448749f, -0.891145766f, -0.891840696f, -0.892533541f, -0.893224299f, -0.893912971f, -0.894599497f, -0.895283937f, -0.895966232f, -0.896646500f, -0.897324562f, -0.898000598f, -0.898674488f, -0.899346232f, -0.900015891f, -0.900683403f, -0.901348829f, -0.902012169f, -0.902673304f, -0.903332353f, -0.903989315f, -0.904644072f, -0.905296743f, -0.905947268f, -0.906595707f, -0.907242000f, -0.907886088f, -0.908528090f, -0.909168005f, -0.909805715f, -0.910441279f, -0.911074758f, -0.911706030f, -0.912335157f, -0.912962198f, -0.913587034f, -0.914209783f, -0.914830327f, -0.915448725f, -0.916064978f, -0.916679084f, -0.917290986f, -0.917900801f, -0.918508410f, -0.919113874f, -0.919717133f, -0.920318305f, -0.920917213f, -0.921514034f, -0.922108650f, -0.922701120f, -0.923291445f, -0.923879504f, -0.924465477f, -0.925049245f, -0.925630808f, -0.926210225f, -0.926787496f, -0.927362502f, -0.927935421f, -0.928506076f, -0.929074585f, -0.929640889f, -0.930205047f, -0.930766940f, -0.931326687f, -0.931884289f, -0.932439625f, -0.932992816f, -0.933543801f, -0.934092522f, -0.934639156f, -0.935183525f, -0.935725689f, -0.936265647f, -0.936803460f, -0.937339008f, -0.937872350f, -0.938403547f, -0.938932478f, -0.939459205f, -0.939983726f, -0.940506041f, -0.941026151f, -0.941544056f, -0.942059755f, -0.942573190f, -0.943084419f, -0.943593442f, -0.944100261f, -0.944604814f, -0.945107222f, -0.945607305f, -0.946105242f, -0.946600914f, -0.947094381f, -0.947585583f, -0.948074579f, -0.948561370f, -0.949045897f, -0.949528158f, -0.950008273f, -0.950486064f, -0.950961649f, -0.951435030f, -0.951906145f, -0.952374995f, -0.952841640f, -0.953306019f, -0.953768194f, -0.954228103f, -0.954685748f, -0.955141187f, -0.955594361f, -0.956045270f, -0.956493914f, -0.956940353f, -0.957384527f, -0.957826436f, -0.958266079f, -0.958703458f, -0.959138632f, -0.959571540f, -0.960002124f, -0.960430503f, -0.960856616f, -0.961280465f, -0.961702049f, -0.962121427f, -0.962538481f, -0.962953269f, -0.963365793f, -0.963776052f, -0.964184046f, -0.964589775f, -0.964993238f, -0.965394437f, -0.965793371f, -0.966189981f, -0.966584384f, -0.966976464f, -0.967366278f, -0.967753828f, -0.968139112f, -0.968522072f, -0.968902826f, -0.969281256f, -0.969657362f, -0.970031261f, -0.970402837f, -0.970772147f, -0.971139133f, -0.971503913f, -0.971866310f, -0.972226501f, -0.972584367f, -0.972939968f, -0.973293245f, -0.973644257f, -0.973992944f, -0.974339366f, -0.974683523f, -0.975025356f, -0.975364864f, -0.975702107f, -0.976037085f, -0.976369739f, -0.976700068f, -0.977028131f, -0.977353871f, -0.977677345f, -0.977998495f, -0.978317380f, -0.978633940f, -0.978948176f, -0.979260147f, -0.979569793f, -0.979877114f, -0.980182111f, -0.980484843f, -0.980785251f, -0.981083393f, -0.981379211f, -0.981672704f, -0.981963873f, -0.982252717f, -0.982539296f, -0.982823551f, -0.983105481f, -0.983385086f, -0.983662426f, -0.983937442f, -0.984210074f, -0.984480441f, -0.984748483f, -0.985014260f, -0.985277653f, -0.985538721f, -0.985797524f, -0.986053944f, -0.986308098f, -0.986559927f, -0.986809373f, -0.987056553f, -0.987301409f, -0.987543941f, -0.987784147f, -0.988022029f, -0.988257587f, -0.988490820f, -0.988721669f, -0.988950253f, -0.989176512f, -0.989400446f, -0.989621997f, -0.989841282f, -0.990058184f, -0.990272820f, -0.990485072f, -0.990695000f, -0.990902662f, -0.991107941f, -0.991310835f, -0.991511464f, -0.991709769f, -0.991905689f, -0.992099285f, -0.992290616f, -0.992479563f, -0.992666125f, -0.992850423f, -0.993032336f, -0.993211925f, -0.993389189f, -0.993564129f, -0.993736744f, -0.993906975f, -0.994074881f, -0.994240463f, -0.994403660f, -0.994564593f, -0.994723141f, -0.994879305f, -0.995033205f, -0.995184720f, -0.995333910f, -0.995480776f, -0.995625257f, -0.995767415f, -0.995907247f, -0.996044695f, -0.996179819f, -0.996312618f, -0.996443033f, -0.996571124f, -0.996696889f, -0.996820271f, -0.996941328f, -0.997060061f, -0.997176409f, -0.997290432f, -0.997402132f, -0.997511446f, -0.997618437f, -0.997723043f, -0.997825325f, -0.997925282f, -0.998022854f, -0.998118103f, -0.998211026f, -0.998301566f, -0.998389721f, -0.998475552f, -0.998559058f, -0.998640239f, -0.998719037f, -0.998795450f, -0.998869538f, -0.998941302f, -0.999010682f, -0.999077737f, -0.999142408f, -0.999204755f, -0.999264777f, -0.999322355f, -0.999377668f, -0.999430597f, -0.999481201f, -0.999529421f, -0.999575317f, -0.999618828f, -0.999660015f, -0.999698818f, -0.999735296f, -0.999769390f, -0.999801159f, -0.999830604f, -0.999857664f, -0.999882340f, -0.999904692f, -0.999924719f, -0.999942362f, -0.999957621f, -0.999970615f, -0.999981165f, -0.999989390f, -0.999995291f, -0.999998808f, -1.000000000f, -0.999998808f, -0.999995291f, -0.999989390f, -0.999981165f, -0.999970615f, -0.999957621f, -0.999942362f, -0.999924719f, -0.999904692f, -0.999882340f, -0.999857664f, -0.999830604f, -0.999801159f, -0.999769390f, -0.999735296f, -0.999698818f, -0.999660015f, -0.999618828f, -0.999575317f, -0.999529421f, -0.999481201f, -0.999430597f, -0.999377668f, -0.999322355f, -0.999264777f, -0.999204755f, -0.999142408f, -0.999077737f, -0.999010682f, -0.998941302f, -0.998869538f, -0.998795450f, -0.998719037f, -0.998640239f, -0.998559058f, -0.998475552f, -0.998389721f, -0.998301566f, -0.998211026f, -0.998118103f, -0.998022854f, -0.997925282f, -0.997825325f, -0.997723043f, -0.997618437f, -0.997511446f, -0.997402132f, -0.997290432f, -0.997176409f, -0.997060061f, -0.996941328f, -0.996820271f, -0.996696889f, -0.996571124f, -0.996443033f, -0.996312618f, -0.996179819f, -0.996044695f, -0.995907247f, -0.995767415f, -0.995625257f, -0.995480776f, -0.995333910f, -0.995184720f, -0.995033205f, -0.994879305f, -0.994723141f, -0.994564593f, -0.994403660f, -0.994240463f, -0.994074881f, -0.993906975f, -0.993736744f, -0.993564129f, -0.993389189f, -0.993211925f, -0.993032336f, -0.992850423f, -0.992666125f, -0.992479563f, -0.992290616f, -0.992099285f, -0.991905689f, -0.991709769f, -0.991511464f, -0.991310835f, -0.991107941f, -0.990902662f, -0.990695000f, -0.990485072f, -0.990272820f, -0.990058184f, -0.989841282f, -0.989621997f, -0.989400446f, -0.989176512f, -0.988950253f, -0.988721669f, -0.988490820f, -0.988257587f, -0.988022029f, -0.987784147f, -0.987543941f, -0.987301409f, -0.987056553f, -0.986809373f, -0.986559927f, -0.986308098f, -0.986053944f, -0.985797524f, -0.985538721f, -0.985277653f, -0.985014260f, -0.984748483f, -0.984480441f, -0.984210074f, -0.983937442f, -0.983662426f, -0.983385086f, -0.983105481f, -0.982823551f, -0.982539296f, -0.982252717f, -0.981963873f, -0.981672704f, -0.981379211f, -0.981083393f, -0.980785251f, -0.980484843f, -0.980182111f, -0.979877114f, -0.979569793f, -0.979260147f, -0.978948176f, -0.978633940f, -0.978317380f, -0.977998495f, -0.977677345f, -0.977353871f, -0.977028131f, -0.976700068f, -0.976369739f, -0.976037085f, -0.975702107f, -0.975364864f, -0.975025356f, -0.974683523f, -0.974339366f, -0.973992944f, -0.973644257f, -0.973293245f, -0.972939968f, -0.972584367f, -0.972226501f, -0.971866310f, -0.971503913f, -0.971139133f, -0.970772147f, -0.970402837f, -0.970031261f, -0.969657362f, -0.969281256f, -0.968902826f, -0.968522072f, -0.968139112f, -0.967753828f, -0.967366278f, -0.966976464f, -0.966584384f, -0.966189981f, -0.965793371f, -0.965394437f, -0.964993238f, -0.964589775f, -0.964184046f, -0.963776052f, -0.963365793f, -0.962953269f, -0.962538481f, -0.962121427f, -0.961702049f, -0.961280465f, -0.960856616f, -0.960430503f, -0.960002124f, -0.959571540f, -0.959138632f, -0.958703458f, -0.958266079f, -0.957826436f, -0.957384527f, -0.956940353f, -0.956493914f, -0.956045270f, -0.955594361f, -0.955141187f, -0.954685748f, -0.954228103f, -0.953768194f, -0.953306019f, -0.952841640f, -0.952374995f, -0.951906145f, -0.951435030f, -0.950961649f, -0.950486064f, -0.950008273f, -0.949528158f, -0.949045897f, -0.948561370f, -0.948074579f, -0.947585583f, -0.947094381f, -0.946600914f, -0.946105242f, -0.945607305f, -0.945107222f, -0.944604814f, -0.944100261f, -0.943593442f, -0.943084419f, -0.942573190f, -0.942059755f, -0.941544056f, -0.941026151f, -0.940506041f, -0.939983726f, -0.939459205f, -0.938932478f, -0.938403547f, -0.937872350f, -0.937339008f, -0.936803460f, -0.936265647f, -0.935725689f, -0.935183525f, -0.934639156f, -0.934092522f, -0.933543801f, -0.932992816f, -0.932439625f, -0.931884289f, -0.931326687f, -0.930766940f, -0.930205047f, -0.929640889f, -0.929074585f, -0.928506076f, -0.927935421f, -0.927362502f, -0.926787496f, -0.926210225f, -0.925630808f, -0.925049245f, -0.924465477f, -0.923879504f, -0.923291445f, -0.922701120f, -0.922108650f, -0.921514034f, -0.920917213f, -0.920318305f, -0.919717133f, -0.919113874f, -0.918508410f, -0.917900801f, -0.917290986f, -0.916679084f, -0.916064978f, -0.915448725f, -0.914830327f, -0.914209783f, -0.913587034f, -0.912962198f, -0.912335157f, -0.911706030f, -0.911074758f, -0.910441279f, -0.909805715f, -0.909168005f, -0.908528090f, -0.907886088f, -0.907242000f, -0.906595707f, -0.905947268f, -0.905296743f, -0.904644072f, -0.903989315f, -0.903332353f, -0.902673304f, -0.902012169f, -0.901348829f, -0.900683403f, -0.900015891f, -0.899346232f, -0.898674488f, -0.898000598f, -0.897324562f, -0.896646500f, -0.895966232f, -0.895283937f, -0.894599497f, -0.893912971f, -0.893224299f, -0.892533541f, -0.891840696f, -0.891145766f, -0.890448749f, -0.889749587f, -0.889048338f, -0.888345063f, -0.887639642f, -0.886932135f, -0.886222541f, -0.885510862f, -0.884797096f, -0.884081244f, -0.883363366f, -0.882643342f, -0.881921291f, -0.881197095f, -0.880470872f, -0.879742622f, -0.879012227f, -0.878279805f, -0.877545297f, -0.876808703f, -0.876070082f, -0.875329375f, -0.874586642f, -0.873841822f, -0.873094976f, -0.872346044f, -0.871595085f, -0.870842040f, -0.870086968f, -0.869329870f, -0.868570685f, -0.867809474f, -0.867046237f, -0.866280973f, -0.865513623f, -0.864744246f, -0.863972843f, -0.863199413f, -0.862423956f, -0.861646473f, -0.860866964f, -0.860085368f, -0.859301805f, -0.858516216f, -0.857728601f, -0.856938958f, -0.856147349f, -0.855353653f, -0.854557991f, -0.853760302f, -0.852960587f, -0.852158904f, -0.851355195f, -0.850549459f, -0.849741757f, -0.848932028f, -0.848120332f, -0.847306609f, -0.846490920f, -0.845673263f, -0.844853580f, -0.844031870f, -0.843208253f, -0.842382610f, -0.841554999f, -0.840725362f, -0.839893818f, -0.839060247f, -0.838224709f, -0.837387204f, -0.836547732f, -0.835706294f, -0.834862888f, -0.834017515f, -0.833170176f, -0.832320869f, -0.831469595f, -0.830616415f, -0.829761207f, -0.828904092f, -0.828045070f, -0.827184021f, -0.826321065f, -0.825456142f, -0.824589312f, -0.823720515f, -0.822849810f, -0.821977139f, -0.821102500f, -0.820225954f, -0.819347501f, -0.818467140f, -0.817584813f, -0.816700578f, -0.815814435f, -0.814926326f, -0.814036310f, -0.813144386f, -0.812250614f, -0.811354876f, -0.810457170f, -0.809557617f, -0.808656156f, -0.807752848f, -0.806847572f, -0.805940390f, -0.805031359f, -0.804120362f, -0.803207517f, -0.802292824f, -0.801376164f, -0.800457656f, -0.799537241f, -0.798614979f, -0.797690868f, -0.796764791f, -0.795836926f, -0.794907153f, -0.793975472f, -0.793041945f, -0.792106569f, -0.791169345f, -0.790230215f, -0.789289236f, -0.788346410f, -0.787401736f, -0.786455214f, -0.785506845f, -0.784556568f, -0.783604503f, -0.782650590f, -0.781694829f, -0.780737221f, -0.779777765f, -0.778816521f, -0.777853429f, -0.776888490f, -0.775921702f, -0.774953127f, -0.773982704f, -0.773010433f, -0.772036374f, -0.771060526f, -0.770082831f, -0.769103348f, -0.768122017f, -0.767138898f, -0.766153991f, -0.765167236f, -0.764178753f, -0.763188422f, -0.762196302f, -0.761202395f, -0.760206699f, -0.759209216f, -0.758209884f, -0.757208824f, -0.756205976f, -0.755201399f, -0.754194975f, -0.753186822f, -0.752176821f, -0.751165152f, -0.750151634f, -0.749136388f, -0.748119354f, -0.747100592f, -0.746080101f, -0.745057762f, -0.744033754f, -0.743007958f, -0.741980433f, -0.740951121f, -0.739920080f, -0.738887310f, -0.737852812f, -0.736816585f, -0.735778570f, -0.734738886f, -0.733697414f, -0.732654274f, -0.731609404f, -0.730562747f, -0.729514420f, -0.728464365f, -0.727412641f, -0.726359129f, -0.725303948f, -0.724247098f, -0.723188460f, -0.722128212f, -0.721066177f, -0.720002532f, -0.718937099f, -0.717870057f, -0.716801286f, -0.715730846f, -0.714658678f, -0.713584840f, -0.712509394f, -0.711432219f, -0.710353374f, -0.709272802f, -0.708190620f, -0.707106769f, -0.706021249f, -0.704934061f, -0.703845263f, -0.702754736f, -0.701662600f, -0.700568795f, -0.699473321f, -0.698376238f, -0.697277486f, -0.696177125f, -0.695075095f, -0.693971455f, -0.692866147f, -0.691759229f, -0.690650702f, -0.689540565f, -0.688428760f, -0.687315345f, -0.686200321f, -0.685083687f, -0.683965385f, -0.682845533f, -0.681724072f, -0.680601001f, -0.679476321f, -0.678350031f, -0.677222192f, -0.676092684f, -0.674961627f, -0.673829019f, -0.672694743f, -0.671558976f, -0.670421541f, -0.669282615f, -0.668142021f, -0.666999936f, -0.665856242f, -0.664710999f, -0.663564146f, -0.662415802f, -0.661265850f, -0.660114348f, -0.658961296f, -0.657806695f, -0.656650543f, -0.655492842f, -0.654333591f, -0.653172851f, -0.652010560f, -0.650846660f, -0.649681330f, -0.648514390f, -0.647345960f, -0.646176040f, -0.645004511f, -0.643831551f, -0.642657042f, -0.641481042f, -0.640303493f, -0.639124453f, -0.637943923f, -0.636761844f, -0.635578334f, -0.634393275f, -0.633206785f, -0.632018745f, -0.630829215f, -0.629638255f, -0.628445745f, -0.627251804f, -0.626056373f, -0.624859512f, -0.623661101f, -0.622461259f, -0.621259987f, -0.620057225f, -0.618852973f, -0.617647290f, -0.616440177f, -0.615231574f, -0.614021540f, -0.612810075f, -0.611597180f, -0.610382795f, -0.609167039f, -0.607949793f, -0.606731117f, -0.605511069f, -0.604289532f, -0.603066623f, -0.601842225f, -0.600616455f, -0.599389315f, -0.598160684f, -0.596930683f, -0.595699310f, -0.594466507f, -0.593232274f, -0.591996670f, -0.590759695f, -0.589521289f, -0.588281572f, -0.587040365f, -0.585797846f, -0.584553957f, -0.583308637f, -0.582062006f, -0.580813944f, -0.579564571f, -0.578313768f, -0.577061653f, -0.575808167f, -0.574553370f, -0.573297143f, -0.572039604f, -0.570780754f, -0.569520533f, -0.568258941f, -0.566996038f, -0.565731823f, -0.564466238f, -0.563199341f, -0.561931133f, -0.560661554f, -0.559390724f, -0.558118522f, -0.556845009f, -0.555570245f, -0.554294109f, -0.553016722f, -0.551737964f, -0.550457954f, -0.549176633f, -0.547894061f, -0.546610177f, -0.545324981f, -0.544038534f, -0.542750776f, -0.541461766f, -0.540171444f, -0.538879931f, -0.537587047f, -0.536292970f, -0.534997642f, -0.533701003f, -0.532403111f, -0.531104028f, -0.529803634f, -0.528501987f, -0.527199149f, -0.525895000f, -0.524589658f, -0.523283124f, -0.521975279f, -0.520666242f, -0.519356012f, -0.518044531f, -0.516731799f, -0.515417874f, -0.514102757f, -0.512786388f, -0.511468828f, -0.510150075f, -0.508830130f, -0.507508993f, -0.506186664f, -0.504863083f, -0.503538370f, -0.502212465f, -0.500885367f, -0.499557108f, -0.498227656f, -0.496897042f, -0.495565265f, -0.494232297f, -0.492898196f, -0.491562903f, -0.490226477f, -0.488888890f, -0.487550169f, -0.486210287f, -0.484869242f, -0.483527064f, -0.482183784f, -0.480839342f, -0.479493767f, -0.478147060f, -0.476799220f, -0.475450277f, -0.474100202f, -0.472749025f, -0.471396744f, -0.470043331f, -0.468688816f, -0.467333198f, -0.465976506f, -0.464618683f, -0.463259786f, -0.461899787f, -0.460538715f, -0.459176540f, -0.457813293f, -0.456448972f, -0.455083579f, -0.453717113f, -0.452349573f, -0.450980991f, -0.449611336f, -0.448240608f, -0.446868837f, -0.445496023f, -0.444122136f, -0.442747235f, -0.441371262f, -0.439994276f, -0.438616246f, -0.437237173f, -0.435857087f, -0.434475958f, -0.433093816f, -0.431710660f, -0.430326492f, -0.428941280f, -0.427555084f, -0.426167876f, -0.424779683f, -0.423390478f, -0.422000259f, -0.420609087f, -0.419216901f, -0.417823702f, -0.416429549f, -0.415034413f, -0.413638324f, -0.412241220f, -0.410843164f, -0.409444153f, -0.408044159f, -0.406643212f, -0.405241311f, -0.403838456f, -0.402434647f, -0.401029885f, -0.399624199f, -0.398217559f, -0.396809995f, -0.395401478f, -0.393992037f, -0.392581671f, -0.391170382f, -0.389758170f, -0.388345033f, -0.386931002f, -0.385516047f, -0.384100199f, -0.382683426f, -0.381265759f, -0.379847199f, -0.378427744f, -0.377007425f, -0.375586182f, -0.374164075f, -0.372741073f, -0.371317208f, -0.369892448f, -0.368466824f, -0.367040336f, -0.365612984f, -0.364184797f, -0.362755716f, -0.361325800f, -0.359895051f, -0.358463407f, -0.357030958f, -0.355597675f, -0.354163527f, -0.352728546f, -0.351292759f, -0.349856138f, -0.348418683f, -0.346980423f, -0.345541328f, -0.344101429f, -0.342660725f, -0.341219217f, -0.339776874f, -0.338333756f, -0.336889863f, -0.335445136f, -0.333999664f, -0.332553357f, -0.331106305f, -0.329658449f, -0.328209847f, -0.326760441f, -0.325310290f, -0.323859364f, -0.322407693f, -0.320955247f, -0.319502026f, -0.318048090f, -0.316593379f, -0.315137923f, -0.313681751f, -0.312224805f, -0.310767144f, -0.309308767f, -0.307849646f, -0.306389809f, -0.304929227f, -0.303467959f, -0.302005947f, -0.300543249f, -0.299079835f, -0.297615707f, -0.296150893f, -0.294685364f, -0.293219149f, -0.291752249f, -0.290284663f, -0.288816422f, -0.287347466f, -0.285877824f, -0.284407526f, -0.282936573f, -0.281464934f, -0.279992640f, -0.278519690f, -0.277046084f, -0.275571823f, -0.274096906f, -0.272621363f, -0.271145165f, -0.269668311f, -0.268190861f, -0.266712755f, -0.265234023f, -0.263754666f, -0.262274712f, -0.260794103f, -0.259312928f, -0.257831097f, -0.256348670f, -0.254865646f, -0.253382027f, -0.251897812f, -0.250413001f, -0.248927608f, -0.247441620f, -0.245955050f, -0.244467899f, -0.242980182f, -0.241491884f, -0.240003020f, -0.238513589f, -0.237023607f, -0.235533059f, -0.234041959f, -0.232550308f, -0.231058106f, -0.229565367f, -0.228072077f, -0.226578265f, -0.225083917f, -0.223589033f, -0.222093627f, -0.220597684f, -0.219101235f, -0.217604280f, -0.216106802f, -0.214608818f, -0.213110313f, -0.211611331f, -0.210111842f, -0.208611846f, -0.207111374f, -0.205610409f, -0.204108968f, -0.202607036f, -0.201104641f, -0.199601755f, -0.198098406f, -0.196594596f, -0.195090324f, -0.193585590f, -0.192080393f, -0.190574750f, -0.189068660f, -0.187562123f, -0.186055154f, -0.184547737f, -0.183039889f, -0.181531608f, -0.180022895f, -0.178513765f, -0.177004218f, -0.175494254f, -0.173983872f, -0.172473088f, -0.170961887f, -0.169450298f, -0.167938292f, -0.166425899f, -0.164913118f, -0.163399950f, -0.161886394f, -0.160372451f, -0.158858150f, -0.157343462f, -0.155828401f, -0.154312968f, -0.152797192f, -0.151281044f, -0.149764538f, -0.148247674f, -0.146730468f, -0.145212919f, -0.143695027f, -0.142176807f, -0.140658244f, -0.139139339f, -0.137620121f, -0.136100575f, -0.134580702f, -0.133060530f, -0.131540030f, -0.130019218f, -0.128498107f, -0.126976699f, -0.125454977f, -0.123932973f, -0.122410677f, -0.120888084f, -0.119365215f, -0.117842063f, -0.116318628f, -0.114794925f, -0.113270953f, -0.111746714f, -0.110222206f, -0.108697444f, -0.107172422f, -0.105647154f, -0.104121633f, -0.102595866f, -0.101069860f, -0.099543616f, -0.098017141f, -0.096490428f, -0.094963498f, -0.093436338f, -0.091908954f, -0.090381362f, -0.088853553f, -0.087325536f, -0.085797310f, -0.084268890f, -0.082740262f, -0.081211448f, -0.079682440f, -0.078153245f, -0.076623864f, -0.075094298f, -0.073564567f, -0.072034650f, -0.070504576f, -0.068974331f, -0.067443922f, -0.065913349f, -0.064382628f, -0.062851757f, -0.061320737f, -0.059789572f, -0.058258265f, -0.056726821f, -0.055195246f, -0.053663537f, -0.052131705f, -0.050599750f, -0.049067676f, -0.047535483f, -0.046003181f, -0.044470772f, -0.042938258f, -0.041405641f, -0.039872926f, -0.038340122f, -0.036807224f, -0.035274237f, -0.033741172f, -0.032208025f, -0.030674804f, -0.029141508f, -0.027608145f, -0.026074719f, -0.024541229f, -0.023007682f, -0.021474080f, -0.019940428f, -0.018406730f, -0.016872987f, -0.015339206f, -0.0138053885f, -0.012271538f, -0.010737659f, -0.009203754f, -0.007669829f, -0.0061358847f, -0.004601926f, -0.0030679568f, -0.0015339801f };

__device__ float gCosineTableG[4096] = { 1.000000000f, 0.999998808f, 0.999995291f, 0.999989390f, 0.999981165f, 0.999970615f, 0.999957621f, 0.999942362f, 0.999924719f, 0.999904692f, 0.999882340f, 0.999857664f, 0.999830604f, 0.999801159f, 0.999769390f, 0.999735296f, 0.999698818f, 0.999660015f, 0.999618828f, 0.999575317f, 0.999529421f, 0.999481201f, 0.999430597f, 0.999377668f, 0.999322355f, 0.999264777f, 0.999204755f, 0.999142408f, 0.999077737f, 0.999010682f, 0.998941302f, 0.998869538f, 0.998795450f, 0.998719037f, 0.998640239f, 0.998559058f, 0.998475552f, 0.998389721f, 0.998301566f, 0.998211026f, 0.998118103f, 0.998022854f, 0.997925282f, 0.997825325f, 0.997723043f, 0.997618437f, 0.997511446f, 0.997402132f, 0.997290432f, 0.997176409f, 0.997060061f, 0.996941328f, 0.996820271f, 0.996696889f, 0.996571124f, 0.996443033f, 0.996312618f, 0.996179819f, 0.996044695f, 0.995907247f, 0.995767415f, 0.995625257f, 0.995480776f, 0.995333910f, 0.995184720f, 0.995033205f, 0.994879305f, 0.994723141f, 0.994564593f, 0.994403660f, 0.994240463f, 0.994074881f, 0.993906975f, 0.993736744f, 0.993564129f, 0.993389189f, 0.993211925f, 0.993032336f, 0.992850423f, 0.992666125f, 0.992479563f, 0.992290616f, 0.992099285f, 0.991905689f, 0.991709769f, 0.991511464f, 0.991310835f, 0.991107941f, 0.990902662f, 0.990695000f, 0.990485072f, 0.990272820f, 0.990058184f, 0.989841282f, 0.989621997f, 0.989400446f, 0.989176512f, 0.988950253f, 0.988721669f, 0.988490820f, 0.988257587f, 0.988022029f, 0.987784147f, 0.987543941f, 0.987301409f, 0.987056553f, 0.986809373f, 0.986559927f, 0.986308098f, 0.986053944f, 0.985797524f, 0.985538721f, 0.985277653f, 0.985014260f, 0.984748483f, 0.984480441f, 0.984210074f, 0.983937442f, 0.983662426f, 0.983385086f, 0.983105481f, 0.982823551f, 0.982539296f, 0.982252717f, 0.981963873f, 0.981672704f, 0.981379211f, 0.981083393f, 0.980785251f, 0.980484843f, 0.980182111f, 0.979877114f, 0.979569793f, 0.979260147f, 0.978948176f, 0.978633940f, 0.978317380f, 0.977998495f, 0.977677345f, 0.977353871f, 0.977028131f, 0.976700068f, 0.976369739f, 0.976037085f, 0.975702107f, 0.975364864f, 0.975025356f, 0.974683523f, 0.974339366f, 0.973992944f, 0.973644257f, 0.973293245f, 0.972939968f, 0.972584367f, 0.972226501f, 0.971866310f, 0.971503913f, 0.971139133f, 0.970772147f, 0.970402837f, 0.970031261f, 0.969657362f, 0.969281256f, 0.968902826f, 0.968522072f, 0.968139112f, 0.967753828f, 0.967366278f, 0.966976464f, 0.966584384f, 0.966189981f, 0.965793371f, 0.965394437f, 0.964993238f, 0.964589775f, 0.964184046f, 0.963776052f, 0.963365793f, 0.962953269f, 0.962538481f, 0.962121427f, 0.961702049f, 0.961280465f, 0.960856616f, 0.960430503f, 0.960002124f, 0.959571540f, 0.959138632f, 0.958703458f, 0.958266079f, 0.957826436f, 0.957384527f, 0.956940353f, 0.956493914f, 0.956045270f, 0.955594361f, 0.955141187f, 0.954685748f, 0.954228103f, 0.953768194f, 0.953306019f, 0.952841640f, 0.952374995f, 0.951906145f, 0.951435030f, 0.950961649f, 0.950486064f, 0.950008273f, 0.949528158f, 0.949045897f, 0.948561370f, 0.948074579f, 0.947585583f, 0.947094381f, 0.946600914f, 0.946105242f, 0.945607305f, 0.945107222f, 0.944604814f, 0.944100261f, 0.943593442f, 0.943084419f, 0.942573190f, 0.942059755f, 0.941544056f, 0.941026151f, 0.940506041f, 0.939983726f, 0.939459205f, 0.938932478f, 0.938403547f, 0.937872350f, 0.937339008f, 0.936803460f, 0.936265647f, 0.935725689f, 0.935183525f, 0.934639156f, 0.934092522f, 0.933543801f, 0.932992816f, 0.932439625f, 0.931884289f, 0.931326687f, 0.930766940f, 0.930205047f, 0.929640889f, 0.929074585f, 0.928506076f, 0.927935421f, 0.927362502f, 0.926787496f, 0.926210225f, 0.925630808f, 0.925049245f, 0.924465477f, 0.923879504f, 0.923291445f, 0.922701120f, 0.922108650f, 0.921514034f, 0.920917213f, 0.920318305f, 0.919717133f, 0.919113874f, 0.918508410f, 0.917900801f, 0.917290986f, 0.916679084f, 0.916064978f, 0.915448725f, 0.914830327f, 0.914209783f, 0.913587034f, 0.912962198f, 0.912335157f, 0.911706030f, 0.911074758f, 0.910441279f, 0.909805715f, 0.909168005f, 0.908528090f, 0.907886088f, 0.907242000f, 0.906595707f, 0.905947268f, 0.905296743f, 0.904644072f, 0.903989315f, 0.903332353f, 0.902673304f, 0.902012169f, 0.901348829f, 0.900683403f, 0.900015891f, 0.899346232f, 0.898674488f, 0.898000598f, 0.897324562f, 0.896646500f, 0.895966232f, 0.895283937f, 0.894599497f, 0.893912971f, 0.893224299f, 0.892533541f, 0.891840696f, 0.891145766f, 0.890448749f, 0.889749587f, 0.889048338f, 0.888345063f, 0.887639642f, 0.886932135f, 0.886222541f, 0.885510862f, 0.884797096f, 0.884081244f, 0.883363366f, 0.882643342f, 0.881921291f, 0.881197095f, 0.880470872f, 0.879742622f, 0.879012227f, 0.878279805f, 0.877545297f, 0.876808703f, 0.876070082f, 0.875329375f, 0.874586642f, 0.873841822f, 0.873094976f, 0.872346044f, 0.871595085f, 0.870842040f, 0.870086968f, 0.869329870f, 0.868570685f, 0.867809474f, 0.867046237f, 0.866280973f, 0.865513623f, 0.864744246f, 0.863972843f, 0.863199413f, 0.862423956f, 0.861646473f, 0.860866964f, 0.860085368f, 0.859301805f, 0.858516216f, 0.857728601f, 0.856938958f, 0.856147349f, 0.855353653f, 0.854557991f, 0.853760302f, 0.852960587f, 0.852158904f, 0.851355195f, 0.850549459f, 0.849741757f, 0.848932028f, 0.848120332f, 0.847306609f, 0.846490920f, 0.845673263f, 0.844853580f, 0.844031870f, 0.843208253f, 0.842382610f, 0.841554999f, 0.840725362f, 0.839893818f, 0.839060247f, 0.838224709f, 0.837387204f, 0.836547732f, 0.835706294f, 0.834862888f, 0.834017515f, 0.833170176f, 0.832320869f, 0.831469595f, 0.830616415f, 0.829761207f, 0.828904092f, 0.828045070f, 0.827184021f, 0.826321065f, 0.825456142f, 0.824589312f, 0.823720515f, 0.822849810f, 0.821977139f, 0.821102500f, 0.820225954f, 0.819347501f, 0.818467140f, 0.817584813f, 0.816700578f, 0.815814435f, 0.814926326f, 0.814036310f, 0.813144386f, 0.812250614f, 0.811354876f, 0.810457170f, 0.809557617f, 0.808656156f, 0.807752848f, 0.806847572f, 0.805940390f, 0.805031359f, 0.804120362f, 0.803207517f, 0.802292824f, 0.801376164f, 0.800457656f, 0.799537241f, 0.798614979f, 0.797690868f, 0.796764791f, 0.795836926f, 0.794907153f, 0.793975472f, 0.793041945f, 0.792106569f, 0.791169345f, 0.790230215f, 0.789289236f, 0.788346410f, 0.787401736f, 0.786455214f, 0.785506845f, 0.784556568f, 0.783604503f, 0.782650590f, 0.781694829f, 0.780737221f, 0.779777765f, 0.778816521f, 0.777853429f, 0.776888490f, 0.775921702f, 0.774953127f, 0.773982704f, 0.773010433f, 0.772036374f, 0.771060526f, 0.770082831f, 0.769103348f, 0.768122017f, 0.767138898f, 0.766153991f, 0.765167236f, 0.764178753f, 0.763188422f, 0.762196302f, 0.761202395f, 0.760206699f, 0.759209216f, 0.758209884f, 0.757208824f, 0.756205976f, 0.755201399f, 0.754194975f, 0.753186822f, 0.752176821f, 0.751165152f, 0.750151634f, 0.749136388f, 0.748119354f, 0.747100592f, 0.746080101f, 0.745057762f, 0.744033754f, 0.743007958f, 0.741980433f, 0.740951121f, 0.739920080f, 0.738887310f, 0.737852812f, 0.736816585f, 0.735778570f, 0.734738886f, 0.733697414f, 0.732654274f, 0.731609404f, 0.730562747f, 0.729514420f, 0.728464365f, 0.727412641f, 0.726359129f, 0.725303948f, 0.724247098f, 0.723188460f, 0.722128212f, 0.721066177f, 0.720002532f, 0.718937099f, 0.717870057f, 0.716801286f, 0.715730846f, 0.714658678f, 0.713584840f, 0.712509394f, 0.711432219f, 0.710353374f, 0.709272802f, 0.708190620f, 0.707106769f, 0.706021249f, 0.704934061f, 0.703845263f, 0.702754736f, 0.701662600f, 0.700568795f, 0.699473321f, 0.698376238f, 0.697277486f, 0.696177125f, 0.695075095f, 0.693971455f, 0.692866147f, 0.691759229f, 0.690650702f, 0.689540565f, 0.688428760f, 0.687315345f, 0.686200321f, 0.685083687f, 0.683965385f, 0.682845533f, 0.681724072f, 0.680601001f, 0.679476321f, 0.678350031f, 0.677222192f, 0.676092684f, 0.674961627f, 0.673829019f, 0.672694743f, 0.671558976f, 0.670421541f, 0.669282615f, 0.668142021f, 0.666999936f, 0.665856242f, 0.664710999f, 0.663564146f, 0.662415802f, 0.661265850f, 0.660114348f, 0.658961296f, 0.657806695f, 0.656650543f, 0.655492842f, 0.654333591f, 0.653172851f, 0.652010560f, 0.650846660f, 0.649681330f, 0.648514390f, 0.647345960f, 0.646176040f, 0.645004511f, 0.643831551f, 0.642657042f, 0.641481042f, 0.640303493f, 0.639124453f, 0.637943923f, 0.636761844f, 0.635578334f, 0.634393275f, 0.633206785f, 0.632018745f, 0.630829215f, 0.629638255f, 0.628445745f, 0.627251804f, 0.626056373f, 0.624859512f, 0.623661101f, 0.622461259f, 0.621259987f, 0.620057225f, 0.618852973f, 0.617647290f, 0.616440177f, 0.615231574f, 0.614021540f, 0.612810075f, 0.611597180f, 0.610382795f, 0.609167039f, 0.607949793f, 0.606731117f, 0.605511069f, 0.604289532f, 0.603066623f, 0.601842225f, 0.600616455f, 0.599389315f, 0.598160684f, 0.596930683f, 0.595699310f, 0.594466507f, 0.593232274f, 0.591996670f, 0.590759695f, 0.589521289f, 0.588281572f, 0.587040365f, 0.585797846f, 0.584553957f, 0.583308637f, 0.582062006f, 0.580813944f, 0.579564571f, 0.578313768f, 0.577061653f, 0.575808167f, 0.574553370f, 0.573297143f, 0.572039604f, 0.570780754f, 0.569520533f, 0.568258941f, 0.566996038f, 0.565731823f, 0.564466238f, 0.563199341f, 0.561931133f, 0.560661554f, 0.559390724f, 0.558118522f, 0.556845009f, 0.555570245f, 0.554294109f, 0.553016722f, 0.551737964f, 0.550457954f, 0.549176633f, 0.547894061f, 0.546610177f, 0.545324981f, 0.544038534f, 0.542750776f, 0.541461766f, 0.540171444f, 0.538879931f, 0.537587047f, 0.536292970f, 0.534997642f, 0.533701003f, 0.532403111f, 0.531104028f, 0.529803634f, 0.528501987f, 0.527199149f, 0.525895000f, 0.524589658f, 0.523283124f, 0.521975279f, 0.520666242f, 0.519356012f, 0.518044531f, 0.516731799f, 0.515417874f, 0.514102757f, 0.512786388f, 0.511468828f, 0.510150075f, 0.508830130f, 0.507508993f, 0.506186664f, 0.504863083f, 0.503538370f, 0.502212465f, 0.500885367f, 0.499557108f, 0.498227656f, 0.496897042f, 0.495565265f, 0.494232297f, 0.492898196f, 0.491562903f, 0.490226477f, 0.488888890f, 0.487550169f, 0.486210287f, 0.484869242f, 0.483527064f, 0.482183784f, 0.480839342f, 0.479493767f, 0.478147060f, 0.476799220f, 0.475450277f, 0.474100202f, 0.472749025f, 0.471396744f, 0.470043331f, 0.468688816f, 0.467333198f, 0.465976506f, 0.464618683f, 0.463259786f, 0.461899787f, 0.460538715f, 0.459176540f, 0.457813293f, 0.456448972f, 0.455083579f, 0.453717113f, 0.452349573f, 0.450980991f, 0.449611336f, 0.448240608f, 0.446868837f, 0.445496023f, 0.444122136f, 0.442747235f, 0.441371262f, 0.439994276f, 0.438616246f, 0.437237173f, 0.435857087f, 0.434475958f, 0.433093816f, 0.431710660f, 0.430326492f, 0.428941280f, 0.427555084f, 0.426167876f, 0.424779683f, 0.423390478f, 0.422000259f, 0.420609087f, 0.419216901f, 0.417823702f, 0.416429549f, 0.415034413f, 0.413638324f, 0.412241220f, 0.410843164f, 0.409444153f, 0.408044159f, 0.406643212f, 0.405241311f, 0.403838456f, 0.402434647f, 0.401029885f, 0.399624199f, 0.398217559f, 0.396809995f, 0.395401478f, 0.393992037f, 0.392581671f, 0.391170382f, 0.389758170f, 0.388345033f, 0.386931002f, 0.385516047f, 0.384100199f, 0.382683426f, 0.381265759f, 0.379847199f, 0.378427744f, 0.377007425f, 0.375586182f, 0.374164075f, 0.372741073f, 0.371317208f, 0.369892448f, 0.368466824f, 0.367040336f, 0.365612984f, 0.364184797f, 0.362755716f, 0.361325800f, 0.359895051f, 0.358463407f, 0.357030958f, 0.355597675f, 0.354163527f, 0.352728546f, 0.351292759f, 0.349856138f, 0.348418683f, 0.346980423f, 0.345541328f, 0.344101429f, 0.342660725f, 0.341219217f, 0.339776874f, 0.338333756f, 0.336889863f, 0.335445136f, 0.333999664f, 0.332553357f, 0.331106305f, 0.329658449f, 0.328209847f, 0.326760441f, 0.325310290f, 0.323859364f, 0.322407693f, 0.320955247f, 0.319502026f, 0.318048090f, 0.316593379f, 0.315137923f, 0.313681751f, 0.312224805f, 0.310767144f, 0.309308767f, 0.307849646f, 0.306389809f, 0.304929227f, 0.303467959f, 0.302005947f, 0.300543249f, 0.299079835f, 0.297615707f, 0.296150893f, 0.294685364f, 0.293219149f, 0.291752249f, 0.290284663f, 0.288816422f, 0.287347466f, 0.285877824f, 0.284407526f, 0.282936573f, 0.281464934f, 0.279992640f, 0.278519690f, 0.277046084f, 0.275571823f, 0.274096906f, 0.272621363f, 0.271145165f, 0.269668311f, 0.268190861f, 0.266712755f, 0.265234023f, 0.263754666f, 0.262274712f, 0.260794103f, 0.259312928f, 0.257831097f, 0.256348670f, 0.254865646f, 0.253382027f, 0.251897812f, 0.250413001f, 0.248927608f, 0.247441620f, 0.245955050f, 0.244467899f, 0.242980182f, 0.241491884f, 0.240003020f, 0.238513589f, 0.237023607f, 0.235533059f, 0.234041959f, 0.232550308f, 0.231058106f, 0.229565367f, 0.228072077f, 0.226578265f, 0.225083917f, 0.223589033f, 0.222093627f, 0.220597684f, 0.219101235f, 0.217604280f, 0.216106802f, 0.214608818f, 0.213110313f, 0.211611331f, 0.210111842f, 0.208611846f, 0.207111374f, 0.205610409f, 0.204108968f, 0.202607036f, 0.201104641f, 0.199601755f, 0.198098406f, 0.196594596f, 0.195090324f, 0.193585590f, 0.192080393f, 0.190574750f, 0.189068660f, 0.187562123f, 0.186055154f, 0.184547737f, 0.183039889f, 0.181531608f, 0.180022895f, 0.178513765f, 0.177004218f, 0.175494254f, 0.173983872f, 0.172473088f, 0.170961887f, 0.169450298f, 0.167938292f, 0.166425899f, 0.164913118f, 0.163399950f, 0.161886394f, 0.160372451f, 0.158858150f, 0.157343462f, 0.155828401f, 0.154312968f, 0.152797192f, 0.151281044f, 0.149764538f, 0.148247674f, 0.146730468f, 0.145212919f, 0.143695027f, 0.142176807f, 0.140658244f, 0.139139339f, 0.137620121f, 0.136100575f, 0.134580702f, 0.133060530f, 0.131540030f, 0.130019218f, 0.128498107f, 0.126976699f, 0.125454977f, 0.123932973f, 0.122410677f, 0.120888084f, 0.119365215f, 0.117842063f, 0.116318628f, 0.114794925f, 0.113270953f, 0.111746714f, 0.110222206f, 0.108697444f, 0.107172422f, 0.105647154f, 0.104121633f, 0.102595866f, 0.101069860f, 0.099543616f, 0.098017141f, 0.096490428f, 0.094963498f, 0.093436338f, 0.091908954f, 0.090381362f, 0.088853553f, 0.087325536f, 0.085797310f, 0.084268890f, 0.082740262f, 0.081211448f, 0.079682440f, 0.078153245f, 0.076623864f, 0.075094298f, 0.073564567f, 0.072034650f, 0.070504576f, 0.068974331f, 0.067443922f, 0.065913349f, 0.064382628f, 0.062851757f, 0.061320737f, 0.059789572f, 0.058258265f, 0.056726821f, 0.055195246f, 0.053663537f, 0.052131705f, 0.050599750f, 0.049067676f, 0.047535483f, 0.046003181f, 0.044470772f, 0.042938258f, 0.041405641f, 0.039872926f, 0.038340122f, 0.036807224f, 0.035274237f, 0.033741172f, 0.032208025f, 0.030674804f, 0.029141508f, 0.027608145f, 0.026074719f, 0.024541229f, 0.023007682f, 0.021474080f, 0.019940428f, 0.018406730f, 0.016872987f, 0.015339206f, 0.0138053885f, 0.012271538f, 0.010737659f, 0.009203754f, 0.007669829f, 0.0061358847f, 0.004601926f, 0.0030679568f, 0.0015339801f, 0.000000000f, -0.0015339801f, -0.0030679568f, -0.004601926f, -0.0061358847f, -0.007669829f, -0.009203754f, -0.010737659f, -0.012271538f, -0.0138053885f, -0.015339206f, -0.016872987f, -0.018406730f, -0.019940428f, -0.021474080f, -0.023007682f, -0.024541229f, -0.026074719f, -0.027608145f, -0.029141508f, -0.030674804f, -0.032208025f, -0.033741172f, -0.035274237f, -0.036807224f, -0.038340122f, -0.039872926f, -0.041405641f, -0.042938258f, -0.044470772f, -0.046003181f, -0.047535483f, -0.049067676f, -0.050599750f, -0.052131705f, -0.053663537f, -0.055195246f, -0.056726821f, -0.058258265f, -0.059789572f, -0.061320737f, -0.062851757f, -0.064382628f, -0.065913349f, -0.067443922f, -0.068974331f, -0.070504576f, -0.072034650f, -0.073564567f, -0.075094298f, -0.076623864f, -0.078153245f, -0.079682440f, -0.081211448f, -0.082740262f, -0.084268890f, -0.085797310f, -0.087325536f, -0.088853553f, -0.090381362f, -0.091908954f, -0.093436338f, -0.094963498f, -0.096490428f, -0.098017141f, -0.099543616f, -0.101069860f, -0.102595866f, -0.104121633f, -0.105647154f, -0.107172422f, -0.108697444f, -0.110222206f, -0.111746714f, -0.113270953f, -0.114794925f, -0.116318628f, -0.117842063f, -0.119365215f, -0.120888084f, -0.122410677f, -0.123932973f, -0.125454977f, -0.126976699f, -0.128498107f, -0.130019218f, -0.131540030f, -0.133060530f, -0.134580702f, -0.136100575f, -0.137620121f, -0.139139339f, -0.140658244f, -0.142176807f, -0.143695027f, -0.145212919f, -0.146730468f, -0.148247674f, -0.149764538f, -0.151281044f, -0.152797192f, -0.154312968f, -0.155828401f, -0.157343462f, -0.158858150f, -0.160372451f, -0.161886394f, -0.163399950f, -0.164913118f, -0.166425899f, -0.167938292f, -0.169450298f, -0.170961887f, -0.172473088f, -0.173983872f, -0.175494254f, -0.177004218f, -0.178513765f, -0.180022895f, -0.181531608f, -0.183039889f, -0.184547737f, -0.186055154f, -0.187562123f, -0.189068660f, -0.190574750f, -0.192080393f, -0.193585590f, -0.195090324f, -0.196594596f, -0.198098406f, -0.199601755f, -0.201104641f, -0.202607036f, -0.204108968f, -0.205610409f, -0.207111374f, -0.208611846f, -0.210111842f, -0.211611331f, -0.213110313f, -0.214608818f, -0.216106802f, -0.217604280f, -0.219101235f, -0.220597684f, -0.222093627f, -0.223589033f, -0.225083917f, -0.226578265f, -0.228072077f, -0.229565367f, -0.231058106f, -0.232550308f, -0.234041959f, -0.235533059f, -0.237023607f, -0.238513589f, -0.240003020f, -0.241491884f, -0.242980182f, -0.244467899f, -0.245955050f, -0.247441620f, -0.248927608f, -0.250413001f, -0.251897812f, -0.253382027f, -0.254865646f, -0.256348670f, -0.257831097f, -0.259312928f, -0.260794103f, -0.262274712f, -0.263754666f, -0.265234023f, -0.266712755f, -0.268190861f, -0.269668311f, -0.271145165f, -0.272621363f, -0.274096906f, -0.275571823f, -0.277046084f, -0.278519690f, -0.279992640f, -0.281464934f, -0.282936573f, -0.284407526f, -0.285877824f, -0.287347466f, -0.288816422f, -0.290284663f, -0.291752249f, -0.293219149f, -0.294685364f, -0.296150893f, -0.297615707f, -0.299079835f, -0.300543249f, -0.302005947f, -0.303467959f, -0.304929227f, -0.306389809f, -0.307849646f, -0.309308767f, -0.310767144f, -0.312224805f, -0.313681751f, -0.315137923f, -0.316593379f, -0.318048090f, -0.319502026f, -0.320955247f, -0.322407693f, -0.323859364f, -0.325310290f, -0.326760441f, -0.328209847f, -0.329658449f, -0.331106305f, -0.332553357f, -0.333999664f, -0.335445136f, -0.336889863f, -0.338333756f, -0.339776874f, -0.341219217f, -0.342660725f, -0.344101429f, -0.345541328f, -0.346980423f, -0.348418683f, -0.349856138f, -0.351292759f, -0.352728546f, -0.354163527f, -0.355597675f, -0.357030958f, -0.358463407f, -0.359895051f, -0.361325800f, -0.362755716f, -0.364184797f, -0.365612984f, -0.367040336f, -0.368466824f, -0.369892448f, -0.371317208f, -0.372741073f, -0.374164075f, -0.375586182f, -0.377007425f, -0.378427744f, -0.379847199f, -0.381265759f, -0.382683426f, -0.384100199f, -0.385516047f, -0.386931002f, -0.388345033f, -0.389758170f, -0.391170382f, -0.392581671f, -0.393992037f, -0.395401478f, -0.396809995f, -0.398217559f, -0.399624199f, -0.401029885f, -0.402434647f, -0.403838456f, -0.405241311f, -0.406643212f, -0.408044159f, -0.409444153f, -0.410843164f, -0.412241220f, -0.413638324f, -0.415034413f, -0.416429549f, -0.417823702f, -0.419216901f, -0.420609087f, -0.422000259f, -0.423390478f, -0.424779683f, -0.426167876f, -0.427555084f, -0.428941280f, -0.430326492f, -0.431710660f, -0.433093816f, -0.434475958f, -0.435857087f, -0.437237173f, -0.438616246f, -0.439994276f, -0.441371262f, -0.442747235f, -0.444122136f, -0.445496023f, -0.446868837f, -0.448240608f, -0.449611336f, -0.450980991f, -0.452349573f, -0.453717113f, -0.455083579f, -0.456448972f, -0.457813293f, -0.459176540f, -0.460538715f, -0.461899787f, -0.463259786f, -0.464618683f, -0.465976506f, -0.467333198f, -0.468688816f, -0.470043331f, -0.471396744f, -0.472749025f, -0.474100202f, -0.475450277f, -0.476799220f, -0.478147060f, -0.479493767f, -0.480839342f, -0.482183784f, -0.483527064f, -0.484869242f, -0.486210287f, -0.487550169f, -0.488888890f, -0.490226477f, -0.491562903f, -0.492898196f, -0.494232297f, -0.495565265f, -0.496897042f, -0.498227656f, -0.499557108f, -0.500885367f, -0.502212465f, -0.503538370f, -0.504863083f, -0.506186664f, -0.507508993f, -0.508830130f, -0.510150075f, -0.511468828f, -0.512786388f, -0.514102757f, -0.515417874f, -0.516731799f, -0.518044531f, -0.519356012f, -0.520666242f, -0.521975279f, -0.523283124f, -0.524589658f, -0.525895000f, -0.527199149f, -0.528501987f, -0.529803634f, -0.531104028f, -0.532403111f, -0.533701003f, -0.534997642f, -0.536292970f, -0.537587047f, -0.538879931f, -0.540171444f, -0.541461766f, -0.542750776f, -0.544038534f, -0.545324981f, -0.546610177f, -0.547894061f, -0.549176633f, -0.550457954f, -0.551737964f, -0.553016722f, -0.554294109f, -0.555570245f, -0.556845009f, -0.558118522f, -0.559390724f, -0.560661554f, -0.561931133f, -0.563199341f, -0.564466238f, -0.565731823f, -0.566996038f, -0.568258941f, -0.569520533f, -0.570780754f, -0.572039604f, -0.573297143f, -0.574553370f, -0.575808167f, -0.577061653f, -0.578313768f, -0.579564571f, -0.580813944f, -0.582062006f, -0.583308637f, -0.584553957f, -0.585797846f, -0.587040365f, -0.588281572f, -0.589521289f, -0.590759695f, -0.591996670f, -0.593232274f, -0.594466507f, -0.595699310f, -0.596930683f, -0.598160684f, -0.599389315f, -0.600616455f, -0.601842225f, -0.603066623f, -0.604289532f, -0.605511069f, -0.606731117f, -0.607949793f, -0.609167039f, -0.610382795f, -0.611597180f, -0.612810075f, -0.614021540f, -0.615231574f, -0.616440177f, -0.617647290f, -0.618852973f, -0.620057225f, -0.621259987f, -0.622461259f, -0.623661101f, -0.624859512f, -0.626056373f, -0.627251804f, -0.628445745f, -0.629638255f, -0.630829215f, -0.632018745f, -0.633206785f, -0.634393275f, -0.635578334f, -0.636761844f, -0.637943923f, -0.639124453f, -0.640303493f, -0.641481042f, -0.642657042f, -0.643831551f, -0.645004511f, -0.646176040f, -0.647345960f, -0.648514390f, -0.649681330f, -0.650846660f, -0.652010560f, -0.653172851f, -0.654333591f, -0.655492842f, -0.656650543f, -0.657806695f, -0.658961296f, -0.660114348f, -0.661265850f, -0.662415802f, -0.663564146f, -0.664710999f, -0.665856242f, -0.666999936f, -0.668142021f, -0.669282615f, -0.670421541f, -0.671558976f, -0.672694743f, -0.673829019f, -0.674961627f, -0.676092684f, -0.677222192f, -0.678350031f, -0.679476321f, -0.680601001f, -0.681724072f, -0.682845533f, -0.683965385f, -0.685083687f, -0.686200321f, -0.687315345f, -0.688428760f, -0.689540565f, -0.690650702f, -0.691759229f, -0.692866147f, -0.693971455f, -0.695075095f, -0.696177125f, -0.697277486f, -0.698376238f, -0.699473321f, -0.700568795f, -0.701662600f, -0.702754736f, -0.703845263f, -0.704934061f, -0.706021249f, -0.707106769f, -0.708190620f, -0.709272802f, -0.710353374f, -0.711432219f, -0.712509394f, -0.713584840f, -0.714658678f, -0.715730846f, -0.716801286f, -0.717870057f, -0.718937099f, -0.720002532f, -0.721066177f, -0.722128212f, -0.723188460f, -0.724247098f, -0.725303948f, -0.726359129f, -0.727412641f, -0.728464365f, -0.729514420f, -0.730562747f, -0.731609404f, -0.732654274f, -0.733697414f, -0.734738886f, -0.735778570f, -0.736816585f, -0.737852812f, -0.738887310f, -0.739920080f, -0.740951121f, -0.741980433f, -0.743007958f, -0.744033754f, -0.745057762f, -0.746080101f, -0.747100592f, -0.748119354f, -0.749136388f, -0.750151634f, -0.751165152f, -0.752176821f, -0.753186822f, -0.754194975f, -0.755201399f, -0.756205976f, -0.757208824f, -0.758209884f, -0.759209216f, -0.760206699f, -0.761202395f, -0.762196302f, -0.763188422f, -0.764178753f, -0.765167236f, -0.766153991f, -0.767138898f, -0.768122017f, -0.769103348f, -0.770082831f, -0.771060526f, -0.772036374f, -0.773010433f, -0.773982704f, -0.774953127f, -0.775921702f, -0.776888490f, -0.777853429f, -0.778816521f, -0.779777765f, -0.780737221f, -0.781694829f, -0.782650590f, -0.783604503f, -0.784556568f, -0.785506845f, -0.786455214f, -0.787401736f, -0.788346410f, -0.789289236f, -0.790230215f, -0.791169345f, -0.792106569f, -0.793041945f, -0.793975472f, -0.794907153f, -0.795836926f, -0.796764791f, -0.797690868f, -0.798614979f, -0.799537241f, -0.800457656f, -0.801376164f, -0.802292824f, -0.803207517f, -0.804120362f, -0.805031359f, -0.805940390f, -0.806847572f, -0.807752848f, -0.808656156f, -0.809557617f, -0.810457170f, -0.811354876f, -0.812250614f, -0.813144386f, -0.814036310f, -0.814926326f, -0.815814435f, -0.816700578f, -0.817584813f, -0.818467140f, -0.819347501f, -0.820225954f, -0.821102500f, -0.821977139f, -0.822849810f, -0.823720515f, -0.824589312f, -0.825456142f, -0.826321065f, -0.827184021f, -0.828045070f, -0.828904092f, -0.829761207f, -0.830616415f, -0.831469595f, -0.832320869f, -0.833170176f, -0.834017515f, -0.834862888f, -0.835706294f, -0.836547732f, -0.837387204f, -0.838224709f, -0.839060247f, -0.839893818f, -0.840725362f, -0.841554999f, -0.842382610f, -0.843208253f, -0.844031870f, -0.844853580f, -0.845673263f, -0.846490920f, -0.847306609f, -0.848120332f, -0.848932028f, -0.849741757f, -0.850549459f, -0.851355195f, -0.852158904f, -0.852960587f, -0.853760302f, -0.854557991f, -0.855353653f, -0.856147349f, -0.856938958f, -0.857728601f, -0.858516216f, -0.859301805f, -0.860085368f, -0.860866964f, -0.861646473f, -0.862423956f, -0.863199413f, -0.863972843f, -0.864744246f, -0.865513623f, -0.866280973f, -0.867046237f, -0.867809474f, -0.868570685f, -0.869329870f, -0.870086968f, -0.870842040f, -0.871595085f, -0.872346044f, -0.873094976f, -0.873841822f, -0.874586642f, -0.875329375f, -0.876070082f, -0.876808703f, -0.877545297f, -0.878279805f, -0.879012227f, -0.879742622f, -0.880470872f, -0.881197095f, -0.881921291f, -0.882643342f, -0.883363366f, -0.884081244f, -0.884797096f, -0.885510862f, -0.886222541f, -0.886932135f, -0.887639642f, -0.888345063f, -0.889048338f, -0.889749587f, -0.890448749f, -0.891145766f, -0.891840696f, -0.892533541f, -0.893224299f, -0.893912971f, -0.894599497f, -0.895283937f, -0.895966232f, -0.896646500f, -0.897324562f, -0.898000598f, -0.898674488f, -0.899346232f, -0.900015891f, -0.900683403f, -0.901348829f, -0.902012169f, -0.902673304f, -0.903332353f, -0.903989315f, -0.904644072f, -0.905296743f, -0.905947268f, -0.906595707f, -0.907242000f, -0.907886088f, -0.908528090f, -0.909168005f, -0.909805715f, -0.910441279f, -0.911074758f, -0.911706030f, -0.912335157f, -0.912962198f, -0.913587034f, -0.914209783f, -0.914830327f, -0.915448725f, -0.916064978f, -0.916679084f, -0.917290986f, -0.917900801f, -0.918508410f, -0.919113874f, -0.919717133f, -0.920318305f, -0.920917213f, -0.921514034f, -0.922108650f, -0.922701120f, -0.923291445f, -0.923879504f, -0.924465477f, -0.925049245f, -0.925630808f, -0.926210225f, -0.926787496f, -0.927362502f, -0.927935421f, -0.928506076f, -0.929074585f, -0.929640889f, -0.930205047f, -0.930766940f, -0.931326687f, -0.931884289f, -0.932439625f, -0.932992816f, -0.933543801f, -0.934092522f, -0.934639156f, -0.935183525f, -0.935725689f, -0.936265647f, -0.936803460f, -0.937339008f, -0.937872350f, -0.938403547f, -0.938932478f, -0.939459205f, -0.939983726f, -0.940506041f, -0.941026151f, -0.941544056f, -0.942059755f, -0.942573190f, -0.943084419f, -0.943593442f, -0.944100261f, -0.944604814f, -0.945107222f, -0.945607305f, -0.946105242f, -0.946600914f, -0.947094381f, -0.947585583f, -0.948074579f, -0.948561370f, -0.949045897f, -0.949528158f, -0.950008273f, -0.950486064f, -0.950961649f, -0.951435030f, -0.951906145f, -0.952374995f, -0.952841640f, -0.953306019f, -0.953768194f, -0.954228103f, -0.954685748f, -0.955141187f, -0.955594361f, -0.956045270f, -0.956493914f, -0.956940353f, -0.957384527f, -0.957826436f, -0.958266079f, -0.958703458f, -0.959138632f, -0.959571540f, -0.960002124f, -0.960430503f, -0.960856616f, -0.961280465f, -0.961702049f, -0.962121427f, -0.962538481f, -0.962953269f, -0.963365793f, -0.963776052f, -0.964184046f, -0.964589775f, -0.964993238f, -0.965394437f, -0.965793371f, -0.966189981f, -0.966584384f, -0.966976464f, -0.967366278f, -0.967753828f, -0.968139112f, -0.968522072f, -0.968902826f, -0.969281256f, -0.969657362f, -0.970031261f, -0.970402837f, -0.970772147f, -0.971139133f, -0.971503913f, -0.971866310f, -0.972226501f, -0.972584367f, -0.972939968f, -0.973293245f, -0.973644257f, -0.973992944f, -0.974339366f, -0.974683523f, -0.975025356f, -0.975364864f, -0.975702107f, -0.976037085f, -0.976369739f, -0.976700068f, -0.977028131f, -0.977353871f, -0.977677345f, -0.977998495f, -0.978317380f, -0.978633940f, -0.978948176f, -0.979260147f, -0.979569793f, -0.979877114f, -0.980182111f, -0.980484843f, -0.980785251f, -0.981083393f, -0.981379211f, -0.981672704f, -0.981963873f, -0.982252717f, -0.982539296f, -0.982823551f, -0.983105481f, -0.983385086f, -0.983662426f, -0.983937442f, -0.984210074f, -0.984480441f, -0.984748483f, -0.985014260f, -0.985277653f, -0.985538721f, -0.985797524f, -0.986053944f, -0.986308098f, -0.986559927f, -0.986809373f, -0.987056553f, -0.987301409f, -0.987543941f, -0.987784147f, -0.988022029f, -0.988257587f, -0.988490820f, -0.988721669f, -0.988950253f, -0.989176512f, -0.989400446f, -0.989621997f, -0.989841282f, -0.990058184f, -0.990272820f, -0.990485072f, -0.990695000f, -0.990902662f, -0.991107941f, -0.991310835f, -0.991511464f, -0.991709769f, -0.991905689f, -0.992099285f, -0.992290616f, -0.992479563f, -0.992666125f, -0.992850423f, -0.993032336f, -0.993211925f, -0.993389189f, -0.993564129f, -0.993736744f, -0.993906975f, -0.994074881f, -0.994240463f, -0.994403660f, -0.994564593f, -0.994723141f, -0.994879305f, -0.995033205f, -0.995184720f, -0.995333910f, -0.995480776f, -0.995625257f, -0.995767415f, -0.995907247f, -0.996044695f, -0.996179819f, -0.996312618f, -0.996443033f, -0.996571124f, -0.996696889f, -0.996820271f, -0.996941328f, -0.997060061f, -0.997176409f, -0.997290432f, -0.997402132f, -0.997511446f, -0.997618437f, -0.997723043f, -0.997825325f, -0.997925282f, -0.998022854f, -0.998118103f, -0.998211026f, -0.998301566f, -0.998389721f, -0.998475552f, -0.998559058f, -0.998640239f, -0.998719037f, -0.998795450f, -0.998869538f, -0.998941302f, -0.999010682f, -0.999077737f, -0.999142408f, -0.999204755f, -0.999264777f, -0.999322355f, -0.999377668f, -0.999430597f, -0.999481201f, -0.999529421f, -0.999575317f, -0.999618828f, -0.999660015f, -0.999698818f, -0.999735296f, -0.999769390f, -0.999801159f, -0.999830604f, -0.999857664f, -0.999882340f, -0.999904692f, -0.999924719f, -0.999942362f, -0.999957621f, -0.999970615f, -0.999981165f, -0.999989390f, -0.999995291f, -0.999998808f, -1.000000000f, -0.999998808f, -0.999995291f, -0.999989390f, -0.999981165f, -0.999970615f, -0.999957621f, -0.999942362f, -0.999924719f, -0.999904692f, -0.999882340f, -0.999857664f, -0.999830604f, -0.999801159f, -0.999769390f, -0.999735296f, -0.999698818f, -0.999660015f, -0.999618828f, -0.999575317f, -0.999529421f, -0.999481201f, -0.999430597f, -0.999377668f, -0.999322355f, -0.999264777f, -0.999204755f, -0.999142408f, -0.999077737f, -0.999010682f, -0.998941302f, -0.998869538f, -0.998795450f, -0.998719037f, -0.998640239f, -0.998559058f, -0.998475552f, -0.998389721f, -0.998301566f, -0.998211026f, -0.998118103f, -0.998022854f, -0.997925282f, -0.997825325f, -0.997723043f, -0.997618437f, -0.997511446f, -0.997402132f, -0.997290432f, -0.997176409f, -0.997060061f, -0.996941328f, -0.996820271f, -0.996696889f, -0.996571124f, -0.996443033f, -0.996312618f, -0.996179819f, -0.996044695f, -0.995907247f, -0.995767415f, -0.995625257f, -0.995480776f, -0.995333910f, -0.995184720f, -0.995033205f, -0.994879305f, -0.994723141f, -0.994564593f, -0.994403660f, -0.994240463f, -0.994074881f, -0.993906975f, -0.993736744f, -0.993564129f, -0.993389189f, -0.993211925f, -0.993032336f, -0.992850423f, -0.992666125f, -0.992479563f, -0.992290616f, -0.992099285f, -0.991905689f, -0.991709769f, -0.991511464f, -0.991310835f, -0.991107941f, -0.990902662f, -0.990695000f, -0.990485072f, -0.990272820f, -0.990058184f, -0.989841282f, -0.989621997f, -0.989400446f, -0.989176512f, -0.988950253f, -0.988721669f, -0.988490820f, -0.988257587f, -0.988022029f, -0.987784147f, -0.987543941f, -0.987301409f, -0.987056553f, -0.986809373f, -0.986559927f, -0.986308098f, -0.986053944f, -0.985797524f, -0.985538721f, -0.985277653f, -0.985014260f, -0.984748483f, -0.984480441f, -0.984210074f, -0.983937442f, -0.983662426f, -0.983385086f, -0.983105481f, -0.982823551f, -0.982539296f, -0.982252717f, -0.981963873f, -0.981672704f, -0.981379211f, -0.981083393f, -0.980785251f, -0.980484843f, -0.980182111f, -0.979877114f, -0.979569793f, -0.979260147f, -0.978948176f, -0.978633940f, -0.978317380f, -0.977998495f, -0.977677345f, -0.977353871f, -0.977028131f, -0.976700068f, -0.976369739f, -0.976037085f, -0.975702107f, -0.975364864f, -0.975025356f, -0.974683523f, -0.974339366f, -0.973992944f, -0.973644257f, -0.973293245f, -0.972939968f, -0.972584367f, -0.972226501f, -0.971866310f, -0.971503913f, -0.971139133f, -0.970772147f, -0.970402837f, -0.970031261f, -0.969657362f, -0.969281256f, -0.968902826f, -0.968522072f, -0.968139112f, -0.967753828f, -0.967366278f, -0.966976464f, -0.966584384f, -0.966189981f, -0.965793371f, -0.965394437f, -0.964993238f, -0.964589775f, -0.964184046f, -0.963776052f, -0.963365793f, -0.962953269f, -0.962538481f, -0.962121427f, -0.961702049f, -0.961280465f, -0.960856616f, -0.960430503f, -0.960002124f, -0.959571540f, -0.959138632f, -0.958703458f, -0.958266079f, -0.957826436f, -0.957384527f, -0.956940353f, -0.956493914f, -0.956045270f, -0.955594361f, -0.955141187f, -0.954685748f, -0.954228103f, -0.953768194f, -0.953306019f, -0.952841640f, -0.952374995f, -0.951906145f, -0.951435030f, -0.950961649f, -0.950486064f, -0.950008273f, -0.949528158f, -0.949045897f, -0.948561370f, -0.948074579f, -0.947585583f, -0.947094381f, -0.946600914f, -0.946105242f, -0.945607305f, -0.945107222f, -0.944604814f, -0.944100261f, -0.943593442f, -0.943084419f, -0.942573190f, -0.942059755f, -0.941544056f, -0.941026151f, -0.940506041f, -0.939983726f, -0.939459205f, -0.938932478f, -0.938403547f, -0.937872350f, -0.937339008f, -0.936803460f, -0.936265647f, -0.935725689f, -0.935183525f, -0.934639156f, -0.934092522f, -0.933543801f, -0.932992816f, -0.932439625f, -0.931884289f, -0.931326687f, -0.930766940f, -0.930205047f, -0.929640889f, -0.929074585f, -0.928506076f, -0.927935421f, -0.927362502f, -0.926787496f, -0.926210225f, -0.925630808f, -0.925049245f, -0.924465477f, -0.923879504f, -0.923291445f, -0.922701120f, -0.922108650f, -0.921514034f, -0.920917213f, -0.920318305f, -0.919717133f, -0.919113874f, -0.918508410f, -0.917900801f, -0.917290986f, -0.916679084f, -0.916064978f, -0.915448725f, -0.914830327f, -0.914209783f, -0.913587034f, -0.912962198f, -0.912335157f, -0.911706030f, -0.911074758f, -0.910441279f, -0.909805715f, -0.909168005f, -0.908528090f, -0.907886088f, -0.907242000f, -0.906595707f, -0.905947268f, -0.905296743f, -0.904644072f, -0.903989315f, -0.903332353f, -0.902673304f, -0.902012169f, -0.901348829f, -0.900683403f, -0.900015891f, -0.899346232f, -0.898674488f, -0.898000598f, -0.897324562f, -0.896646500f, -0.895966232f, -0.895283937f, -0.894599497f, -0.893912971f, -0.893224299f, -0.892533541f, -0.891840696f, -0.891145766f, -0.890448749f, -0.889749587f, -0.889048338f, -0.888345063f, -0.887639642f, -0.886932135f, -0.886222541f, -0.885510862f, -0.884797096f, -0.884081244f, -0.883363366f, -0.882643342f, -0.881921291f, -0.881197095f, -0.880470872f, -0.879742622f, -0.879012227f, -0.878279805f, -0.877545297f, -0.876808703f, -0.876070082f, -0.875329375f, -0.874586642f, -0.873841822f, -0.873094976f, -0.872346044f, -0.871595085f, -0.870842040f, -0.870086968f, -0.869329870f, -0.868570685f, -0.867809474f, -0.867046237f, -0.866280973f, -0.865513623f, -0.864744246f, -0.863972843f, -0.863199413f, -0.862423956f, -0.861646473f, -0.860866964f, -0.860085368f, -0.859301805f, -0.858516216f, -0.857728601f, -0.856938958f, -0.856147349f, -0.855353653f, -0.854557991f, -0.853760302f, -0.852960587f, -0.852158904f, -0.851355195f, -0.850549459f, -0.849741757f, -0.848932028f, -0.848120332f, -0.847306609f, -0.846490920f, -0.845673263f, -0.844853580f, -0.844031870f, -0.843208253f, -0.842382610f, -0.841554999f, -0.840725362f, -0.839893818f, -0.839060247f, -0.838224709f, -0.837387204f, -0.836547732f, -0.835706294f, -0.834862888f, -0.834017515f, -0.833170176f, -0.832320869f, -0.831469595f, -0.830616415f, -0.829761207f, -0.828904092f, -0.828045070f, -0.827184021f, -0.826321065f, -0.825456142f, -0.824589312f, -0.823720515f, -0.822849810f, -0.821977139f, -0.821102500f, -0.820225954f, -0.819347501f, -0.818467140f, -0.817584813f, -0.816700578f, -0.815814435f, -0.814926326f, -0.814036310f, -0.813144386f, -0.812250614f, -0.811354876f, -0.810457170f, -0.809557617f, -0.808656156f, -0.807752848f, -0.806847572f, -0.805940390f, -0.805031359f, -0.804120362f, -0.803207517f, -0.802292824f, -0.801376164f, -0.800457656f, -0.799537241f, -0.798614979f, -0.797690868f, -0.796764791f, -0.795836926f, -0.794907153f, -0.793975472f, -0.793041945f, -0.792106569f, -0.791169345f, -0.790230215f, -0.789289236f, -0.788346410f, -0.787401736f, -0.786455214f, -0.785506845f, -0.784556568f, -0.783604503f, -0.782650590f, -0.781694829f, -0.780737221f, -0.779777765f, -0.778816521f, -0.777853429f, -0.776888490f, -0.775921702f, -0.774953127f, -0.773982704f, -0.773010433f, -0.772036374f, -0.771060526f, -0.770082831f, -0.769103348f, -0.768122017f, -0.767138898f, -0.766153991f, -0.765167236f, -0.764178753f, -0.763188422f, -0.762196302f, -0.761202395f, -0.760206699f, -0.759209216f, -0.758209884f, -0.757208824f, -0.756205976f, -0.755201399f, -0.754194975f, -0.753186822f, -0.752176821f, -0.751165152f, -0.750151634f, -0.749136388f, -0.748119354f, -0.747100592f, -0.746080101f, -0.745057762f, -0.744033754f, -0.743007958f, -0.741980433f, -0.740951121f, -0.739920080f, -0.738887310f, -0.737852812f, -0.736816585f, -0.735778570f, -0.734738886f, -0.733697414f, -0.732654274f, -0.731609404f, -0.730562747f, -0.729514420f, -0.728464365f, -0.727412641f, -0.726359129f, -0.725303948f, -0.724247098f, -0.723188460f, -0.722128212f, -0.721066177f, -0.720002532f, -0.718937099f, -0.717870057f, -0.716801286f, -0.715730846f, -0.714658678f, -0.713584840f, -0.712509394f, -0.711432219f, -0.710353374f, -0.709272802f, -0.708190620f, -0.707106769f, -0.706021249f, -0.704934061f, -0.703845263f, -0.702754736f, -0.701662600f, -0.700568795f, -0.699473321f, -0.698376238f, -0.697277486f, -0.696177125f, -0.695075095f, -0.693971455f, -0.692866147f, -0.691759229f, -0.690650702f, -0.689540565f, -0.688428760f, -0.687315345f, -0.686200321f, -0.685083687f, -0.683965385f, -0.682845533f, -0.681724072f, -0.680601001f, -0.679476321f, -0.678350031f, -0.677222192f, -0.676092684f, -0.674961627f, -0.673829019f, -0.672694743f, -0.671558976f, -0.670421541f, -0.669282615f, -0.668142021f, -0.666999936f, -0.665856242f, -0.664710999f, -0.663564146f, -0.662415802f, -0.661265850f, -0.660114348f, -0.658961296f, -0.657806695f, -0.656650543f, -0.655492842f, -0.654333591f, -0.653172851f, -0.652010560f, -0.650846660f, -0.649681330f, -0.648514390f, -0.647345960f, -0.646176040f, -0.645004511f, -0.643831551f, -0.642657042f, -0.641481042f, -0.640303493f, -0.639124453f, -0.637943923f, -0.636761844f, -0.635578334f, -0.634393275f, -0.633206785f, -0.632018745f, -0.630829215f, -0.629638255f, -0.628445745f, -0.627251804f, -0.626056373f, -0.624859512f, -0.623661101f, -0.622461259f, -0.621259987f, -0.620057225f, -0.618852973f, -0.617647290f, -0.616440177f, -0.615231574f, -0.614021540f, -0.612810075f, -0.611597180f, -0.610382795f, -0.609167039f, -0.607949793f, -0.606731117f, -0.605511069f, -0.604289532f, -0.603066623f, -0.601842225f, -0.600616455f, -0.599389315f, -0.598160684f, -0.596930683f, -0.595699310f, -0.594466507f, -0.593232274f, -0.591996670f, -0.590759695f, -0.589521289f, -0.588281572f, -0.587040365f, -0.585797846f, -0.584553957f, -0.583308637f, -0.582062006f, -0.580813944f, -0.579564571f, -0.578313768f, -0.577061653f, -0.575808167f, -0.574553370f, -0.573297143f, -0.572039604f, -0.570780754f, -0.569520533f, -0.568258941f, -0.566996038f, -0.565731823f, -0.564466238f, -0.563199341f, -0.561931133f, -0.560661554f, -0.559390724f, -0.558118522f, -0.556845009f, -0.555570245f, -0.554294109f, -0.553016722f, -0.551737964f, -0.550457954f, -0.549176633f, -0.547894061f, -0.546610177f, -0.545324981f, -0.544038534f, -0.542750776f, -0.541461766f, -0.540171444f, -0.538879931f, -0.537587047f, -0.536292970f, -0.534997642f, -0.533701003f, -0.532403111f, -0.531104028f, -0.529803634f, -0.528501987f, -0.527199149f, -0.525895000f, -0.524589658f, -0.523283124f, -0.521975279f, -0.520666242f, -0.519356012f, -0.518044531f, -0.516731799f, -0.515417874f, -0.514102757f, -0.512786388f, -0.511468828f, -0.510150075f, -0.508830130f, -0.507508993f, -0.506186664f, -0.504863083f, -0.503538370f, -0.502212465f, -0.500885367f, -0.499557108f, -0.498227656f, -0.496897042f, -0.495565265f, -0.494232297f, -0.492898196f, -0.491562903f, -0.490226477f, -0.488888890f, -0.487550169f, -0.486210287f, -0.484869242f, -0.483527064f, -0.482183784f, -0.480839342f, -0.479493767f, -0.478147060f, -0.476799220f, -0.475450277f, -0.474100202f, -0.472749025f, -0.471396744f, -0.470043331f, -0.468688816f, -0.467333198f, -0.465976506f, -0.464618683f, -0.463259786f, -0.461899787f, -0.460538715f, -0.459176540f, -0.457813293f, -0.456448972f, -0.455083579f, -0.453717113f, -0.452349573f, -0.450980991f, -0.449611336f, -0.448240608f, -0.446868837f, -0.445496023f, -0.444122136f, -0.442747235f, -0.441371262f, -0.439994276f, -0.438616246f, -0.437237173f, -0.435857087f, -0.434475958f, -0.433093816f, -0.431710660f, -0.430326492f, -0.428941280f, -0.427555084f, -0.426167876f, -0.424779683f, -0.423390478f, -0.422000259f, -0.420609087f, -0.419216901f, -0.417823702f, -0.416429549f, -0.415034413f, -0.413638324f, -0.412241220f, -0.410843164f, -0.409444153f, -0.408044159f, -0.406643212f, -0.405241311f, -0.403838456f, -0.402434647f, -0.401029885f, -0.399624199f, -0.398217559f, -0.396809995f, -0.395401478f, -0.393992037f, -0.392581671f, -0.391170382f, -0.389758170f, -0.388345033f, -0.386931002f, -0.385516047f, -0.384100199f, -0.382683426f, -0.381265759f, -0.379847199f, -0.378427744f, -0.377007425f, -0.375586182f, -0.374164075f, -0.372741073f, -0.371317208f, -0.369892448f, -0.368466824f, -0.367040336f, -0.365612984f, -0.364184797f, -0.362755716f, -0.361325800f, -0.359895051f, -0.358463407f, -0.357030958f, -0.355597675f, -0.354163527f, -0.352728546f, -0.351292759f, -0.349856138f, -0.348418683f, -0.346980423f, -0.345541328f, -0.344101429f, -0.342660725f, -0.341219217f, -0.339776874f, -0.338333756f, -0.336889863f, -0.335445136f, -0.333999664f, -0.332553357f, -0.331106305f, -0.329658449f, -0.328209847f, -0.326760441f, -0.325310290f, -0.323859364f, -0.322407693f, -0.320955247f, -0.319502026f, -0.318048090f, -0.316593379f, -0.315137923f, -0.313681751f, -0.312224805f, -0.310767144f, -0.309308767f, -0.307849646f, -0.306389809f, -0.304929227f, -0.303467959f, -0.302005947f, -0.300543249f, -0.299079835f, -0.297615707f, -0.296150893f, -0.294685364f, -0.293219149f, -0.291752249f, -0.290284663f, -0.288816422f, -0.287347466f, -0.285877824f, -0.284407526f, -0.282936573f, -0.281464934f, -0.279992640f, -0.278519690f, -0.277046084f, -0.275571823f, -0.274096906f, -0.272621363f, -0.271145165f, -0.269668311f, -0.268190861f, -0.266712755f, -0.265234023f, -0.263754666f, -0.262274712f, -0.260794103f, -0.259312928f, -0.257831097f, -0.256348670f, -0.254865646f, -0.253382027f, -0.251897812f, -0.250413001f, -0.248927608f, -0.247441620f, -0.245955050f, -0.244467899f, -0.242980182f, -0.241491884f, -0.240003020f, -0.238513589f, -0.237023607f, -0.235533059f, -0.234041959f, -0.232550308f, -0.231058106f, -0.229565367f, -0.228072077f, -0.226578265f, -0.225083917f, -0.223589033f, -0.222093627f, -0.220597684f, -0.219101235f, -0.217604280f, -0.216106802f, -0.214608818f, -0.213110313f, -0.211611331f, -0.210111842f, -0.208611846f, -0.207111374f, -0.205610409f, -0.204108968f, -0.202607036f, -0.201104641f, -0.199601755f, -0.198098406f, -0.196594596f, -0.195090324f, -0.193585590f, -0.192080393f, -0.190574750f, -0.189068660f, -0.187562123f, -0.186055154f, -0.184547737f, -0.183039889f, -0.181531608f, -0.180022895f, -0.178513765f, -0.177004218f, -0.175494254f, -0.173983872f, -0.172473088f, -0.170961887f, -0.169450298f, -0.167938292f, -0.166425899f, -0.164913118f, -0.163399950f, -0.161886394f, -0.160372451f, -0.158858150f, -0.157343462f, -0.155828401f, -0.154312968f, -0.152797192f, -0.151281044f, -0.149764538f, -0.148247674f, -0.146730468f, -0.145212919f, -0.143695027f, -0.142176807f, -0.140658244f, -0.139139339f, -0.137620121f, -0.136100575f, -0.134580702f, -0.133060530f, -0.131540030f, -0.130019218f, -0.128498107f, -0.126976699f, -0.125454977f, -0.123932973f, -0.122410677f, -0.120888084f, -0.119365215f, -0.117842063f, -0.116318628f, -0.114794925f, -0.113270953f, -0.111746714f, -0.110222206f, -0.108697444f, -0.107172422f, -0.105647154f, -0.104121633f, -0.102595866f, -0.101069860f, -0.099543616f, -0.098017141f, -0.096490428f, -0.094963498f, -0.093436338f, -0.091908954f, -0.090381362f, -0.088853553f, -0.087325536f, -0.085797310f, -0.084268890f, -0.082740262f, -0.081211448f, -0.079682440f, -0.078153245f, -0.076623864f, -0.075094298f, -0.073564567f, -0.072034650f, -0.070504576f, -0.068974331f, -0.067443922f, -0.065913349f, -0.064382628f, -0.062851757f, -0.061320737f, -0.059789572f, -0.058258265f, -0.056726821f, -0.055195246f, -0.053663537f, -0.052131705f, -0.050599750f, -0.049067676f, -0.047535483f, -0.046003181f, -0.044470772f, -0.042938258f, -0.041405641f, -0.039872926f, -0.038340122f, -0.036807224f, -0.035274237f, -0.033741172f, -0.032208025f, -0.030674804f, -0.029141508f, -0.027608145f, -0.026074719f, -0.024541229f, -0.023007682f, -0.021474080f, -0.019940428f, -0.018406730f, -0.016872987f, -0.015339206f, -0.0138053885f, -0.012271538f, -0.010737659f, -0.009203754f, -0.007669829f, -0.0061358847f, -0.004601926f, -0.0030679568f, -0.0015339801f, 0.000000000f, 0.0015339801f, 0.0030679568f, 0.004601926f, 0.0061358847f, 0.007669829f, 0.009203754f, 0.010737659f, 0.012271538f, 0.0138053885f, 0.015339206f, 0.016872987f, 0.018406730f, 0.019940428f, 0.021474080f, 0.023007682f, 0.024541229f, 0.026074719f, 0.027608145f, 0.029141508f, 0.030674804f, 0.032208025f, 0.033741172f, 0.035274237f, 0.036807224f, 0.038340122f, 0.039872926f, 0.041405641f, 0.042938258f, 0.044470772f, 0.046003181f, 0.047535483f, 0.049067676f, 0.050599750f, 0.052131705f, 0.053663537f, 0.055195246f, 0.056726821f, 0.058258265f, 0.059789572f, 0.061320737f, 0.062851757f, 0.064382628f, 0.065913349f, 0.067443922f, 0.068974331f, 0.070504576f, 0.072034650f, 0.073564567f, 0.075094298f, 0.076623864f, 0.078153245f, 0.079682440f, 0.081211448f, 0.082740262f, 0.084268890f, 0.085797310f, 0.087325536f, 0.088853553f, 0.090381362f, 0.091908954f, 0.093436338f, 0.094963498f, 0.096490428f, 0.098017141f, 0.099543616f, 0.101069860f, 0.102595866f, 0.104121633f, 0.105647154f, 0.107172422f, 0.108697444f, 0.110222206f, 0.111746714f, 0.113270953f, 0.114794925f, 0.116318628f, 0.117842063f, 0.119365215f, 0.120888084f, 0.122410677f, 0.123932973f, 0.125454977f, 0.126976699f, 0.128498107f, 0.130019218f, 0.131540030f, 0.133060530f, 0.134580702f, 0.136100575f, 0.137620121f, 0.139139339f, 0.140658244f, 0.142176807f, 0.143695027f, 0.145212919f, 0.146730468f, 0.148247674f, 0.149764538f, 0.151281044f, 0.152797192f, 0.154312968f, 0.155828401f, 0.157343462f, 0.158858150f, 0.160372451f, 0.161886394f, 0.163399950f, 0.164913118f, 0.166425899f, 0.167938292f, 0.169450298f, 0.170961887f, 0.172473088f, 0.173983872f, 0.175494254f, 0.177004218f, 0.178513765f, 0.180022895f, 0.181531608f, 0.183039889f, 0.184547737f, 0.186055154f, 0.187562123f, 0.189068660f, 0.190574750f, 0.192080393f, 0.193585590f, 0.195090324f, 0.196594596f, 0.198098406f, 0.199601755f, 0.201104641f, 0.202607036f, 0.204108968f, 0.205610409f, 0.207111374f, 0.208611846f, 0.210111842f, 0.211611331f, 0.213110313f, 0.214608818f, 0.216106802f, 0.217604280f, 0.219101235f, 0.220597684f, 0.222093627f, 0.223589033f, 0.225083917f, 0.226578265f, 0.228072077f, 0.229565367f, 0.231058106f, 0.232550308f, 0.234041959f, 0.235533059f, 0.237023607f, 0.238513589f, 0.240003020f, 0.241491884f, 0.242980182f, 0.244467899f, 0.245955050f, 0.247441620f, 0.248927608f, 0.250413001f, 0.251897812f, 0.253382027f, 0.254865646f, 0.256348670f, 0.257831097f, 0.259312928f, 0.260794103f, 0.262274712f, 0.263754666f, 0.265234023f, 0.266712755f, 0.268190861f, 0.269668311f, 0.271145165f, 0.272621363f, 0.274096906f, 0.275571823f, 0.277046084f, 0.278519690f, 0.279992640f, 0.281464934f, 0.282936573f, 0.284407526f, 0.285877824f, 0.287347466f, 0.288816422f, 0.290284663f, 0.291752249f, 0.293219149f, 0.294685364f, 0.296150893f, 0.297615707f, 0.299079835f, 0.300543249f, 0.302005947f, 0.303467959f, 0.304929227f, 0.306389809f, 0.307849646f, 0.309308767f, 0.310767144f, 0.312224805f, 0.313681751f, 0.315137923f, 0.316593379f, 0.318048090f, 0.319502026f, 0.320955247f, 0.322407693f, 0.323859364f, 0.325310290f, 0.326760441f, 0.328209847f, 0.329658449f, 0.331106305f, 0.332553357f, 0.333999664f, 0.335445136f, 0.336889863f, 0.338333756f, 0.339776874f, 0.341219217f, 0.342660725f, 0.344101429f, 0.345541328f, 0.346980423f, 0.348418683f, 0.349856138f, 0.351292759f, 0.352728546f, 0.354163527f, 0.355597675f, 0.357030958f, 0.358463407f, 0.359895051f, 0.361325800f, 0.362755716f, 0.364184797f, 0.365612984f, 0.367040336f, 0.368466824f, 0.369892448f, 0.371317208f, 0.372741073f, 0.374164075f, 0.375586182f, 0.377007425f, 0.378427744f, 0.379847199f, 0.381265759f, 0.382683426f, 0.384100199f, 0.385516047f, 0.386931002f, 0.388345033f, 0.389758170f, 0.391170382f, 0.392581671f, 0.393992037f, 0.395401478f, 0.396809995f, 0.398217559f, 0.399624199f, 0.401029885f, 0.402434647f, 0.403838456f, 0.405241311f, 0.406643212f, 0.408044159f, 0.409444153f, 0.410843164f, 0.412241220f, 0.413638324f, 0.415034413f, 0.416429549f, 0.417823702f, 0.419216901f, 0.420609087f, 0.422000259f, 0.423390478f, 0.424779683f, 0.426167876f, 0.427555084f, 0.428941280f, 0.430326492f, 0.431710660f, 0.433093816f, 0.434475958f, 0.435857087f, 0.437237173f, 0.438616246f, 0.439994276f, 0.441371262f, 0.442747235f, 0.444122136f, 0.445496023f, 0.446868837f, 0.448240608f, 0.449611336f, 0.450980991f, 0.452349573f, 0.453717113f, 0.455083579f, 0.456448972f, 0.457813293f, 0.459176540f, 0.460538715f, 0.461899787f, 0.463259786f, 0.464618683f, 0.465976506f, 0.467333198f, 0.468688816f, 0.470043331f, 0.471396744f, 0.472749025f, 0.474100202f, 0.475450277f, 0.476799220f, 0.478147060f, 0.479493767f, 0.480839342f, 0.482183784f, 0.483527064f, 0.484869242f, 0.486210287f, 0.487550169f, 0.488888890f, 0.490226477f, 0.491562903f, 0.492898196f, 0.494232297f, 0.495565265f, 0.496897042f, 0.498227656f, 0.499557108f, 0.500885367f, 0.502212465f, 0.503538370f, 0.504863083f, 0.506186664f, 0.507508993f, 0.508830130f, 0.510150075f, 0.511468828f, 0.512786388f, 0.514102757f, 0.515417874f, 0.516731799f, 0.518044531f, 0.519356012f, 0.520666242f, 0.521975279f, 0.523283124f, 0.524589658f, 0.525895000f, 0.527199149f, 0.528501987f, 0.529803634f, 0.531104028f, 0.532403111f, 0.533701003f, 0.534997642f, 0.536292970f, 0.537587047f, 0.538879931f, 0.540171444f, 0.541461766f, 0.542750776f, 0.544038534f, 0.545324981f, 0.546610177f, 0.547894061f, 0.549176633f, 0.550457954f, 0.551737964f, 0.553016722f, 0.554294109f, 0.555570245f, 0.556845009f, 0.558118522f, 0.559390724f, 0.560661554f, 0.561931133f, 0.563199341f, 0.564466238f, 0.565731823f, 0.566996038f, 0.568258941f, 0.569520533f, 0.570780754f, 0.572039604f, 0.573297143f, 0.574553370f, 0.575808167f, 0.577061653f, 0.578313768f, 0.579564571f, 0.580813944f, 0.582062006f, 0.583308637f, 0.584553957f, 0.585797846f, 0.587040365f, 0.588281572f, 0.589521289f, 0.590759695f, 0.591996670f, 0.593232274f, 0.594466507f, 0.595699310f, 0.596930683f, 0.598160684f, 0.599389315f, 0.600616455f, 0.601842225f, 0.603066623f, 0.604289532f, 0.605511069f, 0.606731117f, 0.607949793f, 0.609167039f, 0.610382795f, 0.611597180f, 0.612810075f, 0.614021540f, 0.615231574f, 0.616440177f, 0.617647290f, 0.618852973f, 0.620057225f, 0.621259987f, 0.622461259f, 0.623661101f, 0.624859512f, 0.626056373f, 0.627251804f, 0.628445745f, 0.629638255f, 0.630829215f, 0.632018745f, 0.633206785f, 0.634393275f, 0.635578334f, 0.636761844f, 0.637943923f, 0.639124453f, 0.640303493f, 0.641481042f, 0.642657042f, 0.643831551f, 0.645004511f, 0.646176040f, 0.647345960f, 0.648514390f, 0.649681330f, 0.650846660f, 0.652010560f, 0.653172851f, 0.654333591f, 0.655492842f, 0.656650543f, 0.657806695f, 0.658961296f, 0.660114348f, 0.661265850f, 0.662415802f, 0.663564146f, 0.664710999f, 0.665856242f, 0.666999936f, 0.668142021f, 0.669282615f, 0.670421541f, 0.671558976f, 0.672694743f, 0.673829019f, 0.674961627f, 0.676092684f, 0.677222192f, 0.678350031f, 0.679476321f, 0.680601001f, 0.681724072f, 0.682845533f, 0.683965385f, 0.685083687f, 0.686200321f, 0.687315345f, 0.688428760f, 0.689540565f, 0.690650702f, 0.691759229f, 0.692866147f, 0.693971455f, 0.695075095f, 0.696177125f, 0.697277486f, 0.698376238f, 0.699473321f, 0.700568795f, 0.701662600f, 0.702754736f, 0.703845263f, 0.704934061f, 0.706021249f, 0.707106769f, 0.708190620f, 0.709272802f, 0.710353374f, 0.711432219f, 0.712509394f, 0.713584840f, 0.714658678f, 0.715730846f, 0.716801286f, 0.717870057f, 0.718937099f, 0.720002532f, 0.721066177f, 0.722128212f, 0.723188460f, 0.724247098f, 0.725303948f, 0.726359129f, 0.727412641f, 0.728464365f, 0.729514420f, 0.730562747f, 0.731609404f, 0.732654274f, 0.733697414f, 0.734738886f, 0.735778570f, 0.736816585f, 0.737852812f, 0.738887310f, 0.739920080f, 0.740951121f, 0.741980433f, 0.743007958f, 0.744033754f, 0.745057762f, 0.746080101f, 0.747100592f, 0.748119354f, 0.749136388f, 0.750151634f, 0.751165152f, 0.752176821f, 0.753186822f, 0.754194975f, 0.755201399f, 0.756205976f, 0.757208824f, 0.758209884f, 0.759209216f, 0.760206699f, 0.761202395f, 0.762196302f, 0.763188422f, 0.764178753f, 0.765167236f, 0.766153991f, 0.767138898f, 0.768122017f, 0.769103348f, 0.770082831f, 0.771060526f, 0.772036374f, 0.773010433f, 0.773982704f, 0.774953127f, 0.775921702f, 0.776888490f, 0.777853429f, 0.778816521f, 0.779777765f, 0.780737221f, 0.781694829f, 0.782650590f, 0.783604503f, 0.784556568f, 0.785506845f, 0.786455214f, 0.787401736f, 0.788346410f, 0.789289236f, 0.790230215f, 0.791169345f, 0.792106569f, 0.793041945f, 0.793975472f, 0.794907153f, 0.795836926f, 0.796764791f, 0.797690868f, 0.798614979f, 0.799537241f, 0.800457656f, 0.801376164f, 0.802292824f, 0.803207517f, 0.804120362f, 0.805031359f, 0.805940390f, 0.806847572f, 0.807752848f, 0.808656156f, 0.809557617f, 0.810457170f, 0.811354876f, 0.812250614f, 0.813144386f, 0.814036310f, 0.814926326f, 0.815814435f, 0.816700578f, 0.817584813f, 0.818467140f, 0.819347501f, 0.820225954f, 0.821102500f, 0.821977139f, 0.822849810f, 0.823720515f, 0.824589312f, 0.825456142f, 0.826321065f, 0.827184021f, 0.828045070f, 0.828904092f, 0.829761207f, 0.830616415f, 0.831469595f, 0.832320869f, 0.833170176f, 0.834017515f, 0.834862888f, 0.835706294f, 0.836547732f, 0.837387204f, 0.838224709f, 0.839060247f, 0.839893818f, 0.840725362f, 0.841554999f, 0.842382610f, 0.843208253f, 0.844031870f, 0.844853580f, 0.845673263f, 0.846490920f, 0.847306609f, 0.848120332f, 0.848932028f, 0.849741757f, 0.850549459f, 0.851355195f, 0.852158904f, 0.852960587f, 0.853760302f, 0.854557991f, 0.855353653f, 0.856147349f, 0.856938958f, 0.857728601f, 0.858516216f, 0.859301805f, 0.860085368f, 0.860866964f, 0.861646473f, 0.862423956f, 0.863199413f, 0.863972843f, 0.864744246f, 0.865513623f, 0.866280973f, 0.867046237f, 0.867809474f, 0.868570685f, 0.869329870f, 0.870086968f, 0.870842040f, 0.871595085f, 0.872346044f, 0.873094976f, 0.873841822f, 0.874586642f, 0.875329375f, 0.876070082f, 0.876808703f, 0.877545297f, 0.878279805f, 0.879012227f, 0.879742622f, 0.880470872f, 0.881197095f, 0.881921291f, 0.882643342f, 0.883363366f, 0.884081244f, 0.884797096f, 0.885510862f, 0.886222541f, 0.886932135f, 0.887639642f, 0.888345063f, 0.889048338f, 0.889749587f, 0.890448749f, 0.891145766f, 0.891840696f, 0.892533541f, 0.893224299f, 0.893912971f, 0.894599497f, 0.895283937f, 0.895966232f, 0.896646500f, 0.897324562f, 0.898000598f, 0.898674488f, 0.899346232f, 0.900015891f, 0.900683403f, 0.901348829f, 0.902012169f, 0.902673304f, 0.903332353f, 0.903989315f, 0.904644072f, 0.905296743f, 0.905947268f, 0.906595707f, 0.907242000f, 0.907886088f, 0.908528090f, 0.909168005f, 0.909805715f, 0.910441279f, 0.911074758f, 0.911706030f, 0.912335157f, 0.912962198f, 0.913587034f, 0.914209783f, 0.914830327f, 0.915448725f, 0.916064978f, 0.916679084f, 0.917290986f, 0.917900801f, 0.918508410f, 0.919113874f, 0.919717133f, 0.920318305f, 0.920917213f, 0.921514034f, 0.922108650f, 0.922701120f, 0.923291445f, 0.923879504f, 0.924465477f, 0.925049245f, 0.925630808f, 0.926210225f, 0.926787496f, 0.927362502f, 0.927935421f, 0.928506076f, 0.929074585f, 0.929640889f, 0.930205047f, 0.930766940f, 0.931326687f, 0.931884289f, 0.932439625f, 0.932992816f, 0.933543801f, 0.934092522f, 0.934639156f, 0.935183525f, 0.935725689f, 0.936265647f, 0.936803460f, 0.937339008f, 0.937872350f, 0.938403547f, 0.938932478f, 0.939459205f, 0.939983726f, 0.940506041f, 0.941026151f, 0.941544056f, 0.942059755f, 0.942573190f, 0.943084419f, 0.943593442f, 0.944100261f, 0.944604814f, 0.945107222f, 0.945607305f, 0.946105242f, 0.946600914f, 0.947094381f, 0.947585583f, 0.948074579f, 0.948561370f, 0.949045897f, 0.949528158f, 0.950008273f, 0.950486064f, 0.950961649f, 0.951435030f, 0.951906145f, 0.952374995f, 0.952841640f, 0.953306019f, 0.953768194f, 0.954228103f, 0.954685748f, 0.955141187f, 0.955594361f, 0.956045270f, 0.956493914f, 0.956940353f, 0.957384527f, 0.957826436f, 0.958266079f, 0.958703458f, 0.959138632f, 0.959571540f, 0.960002124f, 0.960430503f, 0.960856616f, 0.961280465f, 0.961702049f, 0.962121427f, 0.962538481f, 0.962953269f, 0.963365793f, 0.963776052f, 0.964184046f, 0.964589775f, 0.964993238f, 0.965394437f, 0.965793371f, 0.966189981f, 0.966584384f, 0.966976464f, 0.967366278f, 0.967753828f, 0.968139112f, 0.968522072f, 0.968902826f, 0.969281256f, 0.969657362f, 0.970031261f, 0.970402837f, 0.970772147f, 0.971139133f, 0.971503913f, 0.971866310f, 0.972226501f, 0.972584367f, 0.972939968f, 0.973293245f, 0.973644257f, 0.973992944f, 0.974339366f, 0.974683523f, 0.975025356f, 0.975364864f, 0.975702107f, 0.976037085f, 0.976369739f, 0.976700068f, 0.977028131f, 0.977353871f, 0.977677345f, 0.977998495f, 0.978317380f, 0.978633940f, 0.978948176f, 0.979260147f, 0.979569793f, 0.979877114f, 0.980182111f, 0.980484843f, 0.980785251f, 0.981083393f, 0.981379211f, 0.981672704f, 0.981963873f, 0.982252717f, 0.982539296f, 0.982823551f, 0.983105481f, 0.983385086f, 0.983662426f, 0.983937442f, 0.984210074f, 0.984480441f, 0.984748483f, 0.985014260f, 0.985277653f, 0.985538721f, 0.985797524f, 0.986053944f, 0.986308098f, 0.986559927f, 0.986809373f, 0.987056553f, 0.987301409f, 0.987543941f, 0.987784147f, 0.988022029f, 0.988257587f, 0.988490820f, 0.988721669f, 0.988950253f, 0.989176512f, 0.989400446f, 0.989621997f, 0.989841282f, 0.990058184f, 0.990272820f, 0.990485072f, 0.990695000f, 0.990902662f, 0.991107941f, 0.991310835f, 0.991511464f, 0.991709769f, 0.991905689f, 0.992099285f, 0.992290616f, 0.992479563f, 0.992666125f, 0.992850423f, 0.993032336f, 0.993211925f, 0.993389189f, 0.993564129f, 0.993736744f, 0.993906975f, 0.994074881f, 0.994240463f, 0.994403660f, 0.994564593f, 0.994723141f, 0.994879305f, 0.995033205f, 0.995184720f, 0.995333910f, 0.995480776f, 0.995625257f, 0.995767415f, 0.995907247f, 0.996044695f, 0.996179819f, 0.996312618f, 0.996443033f, 0.996571124f, 0.996696889f, 0.996820271f, 0.996941328f, 0.997060061f, 0.997176409f, 0.997290432f, 0.997402132f, 0.997511446f, 0.997618437f, 0.997723043f, 0.997825325f, 0.997925282f, 0.998022854f, 0.998118103f, 0.998211026f, 0.998301566f, 0.998389721f, 0.998475552f, 0.998559058f, 0.998640239f, 0.998719037f, 0.998795450f, 0.998869538f, 0.998941302f, 0.999010682f, 0.999077737f, 0.999142408f, 0.999204755f, 0.999264777f, 0.999322355f, 0.999377668f, 0.999430597f, 0.999481201f, 0.999529421f, 0.999575317f, 0.999618828f, 0.999660015f, 0.999698818f, 0.999735296f, 0.999769390f, 0.999801159f, 0.999830604f, 0.999857664f, 0.999882340f, 0.999904692f, 0.999924719f, 0.999942362f, 0.999957621f, 0.999970615f, 0.999981165f, 0.999989390f, 0.999995291f, 0.999998808f };

__device__ int gArctanTableG[8192] = { 0x0000, 0x000A, 0x0014, 0x001F, 0x0029, 0x0033, 0x003D, 0x0047, 0x0051, 0x005C, 0x0066, 0x0070, 0x007A, 0x0084, 0x008F, 0x0099, 0x00A3, 0x00AD, 0x00B7, 0x00C2, 0x00CC, 0x00D6, 0x00E0, 0x00EA, 0x00F4, 0x00FF, 0x0109, 0x0113, 0x011D, 0x0127, 0x0131, 0x013C, 0x0146, 0x0150, 0x015A, 0x0164, 0x016F, 0x0179, 0x0183, 0x018D, 0x0197, 0x01A1, 0x01AC, 0x01B6, 0x01C0, 0x01CA, 0x01D4, 0x01DE, 0x01E9, 0x01F3, 0x01FD, 0x0207, 0x0211, 0x021B, 0x0226, 0x0230, 0x023A, 0x0244, 0x024E, 0x0258, 0x0262, 0x026D, 0x0277, 0x0281, 0x028B, 0x0295, 0x029F, 0x02A9, 0x02B4, 0x02BE, 0x02C8, 0x02D2, 0x02DC, 0x02E6, 0x02F0, 0x02FB, 0x0305, 0x030F, 0x0319, 0x0323, 0x032D, 0x0337, 0x0341, 0x034C, 0x0356, 0x0360, 0x036A, 0x0374, 0x037E, 0x0388, 0x0392, 0x039C, 0x03A7, 0x03B1, 0x03BB, 0x03C5, 0x03CF, 0x03D9, 0x03E3, 0x03ED, 0x03F7, 0x0401, 0x040C, 0x0416, 0x0420, 0x042A, 0x0434, 0x043E, 0x0448, 0x0452, 0x045C, 0x0466, 0x0470, 0x047A, 0x0484, 0x048E, 0x0499, 0x04A3, 0x04AD, 0x04B7, 0x04C1, 0x04CB, 0x04D5, 0x04DF, 0x04E9, 0x04F3, 0x04FD, 0x0507, 0x0511, 0x051B, 0x0525, 0x052F, 0x0539, 0x0543, 0x054D, 0x0557, 0x0561, 0x056B, 0x0575, 0x057F, 0x0589, 0x0593, 0x059D, 0x05A7, 0x05B1, 0x05BB, 0x05C5, 0x05CF, 0x05D9, 0x05E3, 0x05ED, 0x05F7, 0x0601, 0x060B, 0x0615, 0x061F, 0x0629, 0x0633, 0x063D, 0x0647, 0x0651, 0x065B, 0x0665, 0x066E, 0x0678, 0x0682, 0x068C, 0x0696, 0x06A0, 0x06AA, 0x06B4, 0x06BE, 0x06C8, 0x06D2, 0x06DC, 0x06E5, 0x06EF, 0x06F9, 0x0703, 0x070D, 0x0717, 0x0721, 0x072B, 0x0735, 0x073E, 0x0748, 0x0752, 0x075C, 0x0766, 0x0770, 0x077A, 0x0783, 0x078D, 0x0797, 0x07A1, 0x07AB, 0x07B5, 0x07BE, 0x07C8, 0x07D2, 0x07DC, 0x07E6, 0x07EF, 0x07F9, 0x0803, 0x080D, 0x0817, 0x0820, 0x082A, 0x0834, 0x083E, 0x0848, 0x0851, 0x085B, 0x0865, 0x086F, 0x0878, 0x0882, 0x088C, 0x0896, 0x089F, 0x08A9, 0x08B3, 0x08BD, 0x08C6, 0x08D0, 0x08DA, 0x08E3, 0x08ED, 0x08F7, 0x0901, 0x090A, 0x0914, 0x091E, 0x0927, 0x0931, 0x093B, 0x0944, 0x094E, 0x0958, 0x0961, 0x096B, 0x0975, 0x097E, 0x0988, 0x0992, 0x099B, 0x09A5, 0x09AE, 0x09B8, 0x09C2, 0x09CB, 0x09D5, 0x09DE, 0x09E8, 0x09F2, 0x09FB, 0x0A05, 0x0A0E, 0x0A18, 0x0A22, 0x0A2B, 0x0A35, 0x0A3E, 0x0A48, 0x0A51, 0x0A5B, 0x0A64, 0x0A6E, 0x0A77, 0x0A81, 0x0A8B, 0x0A94, 0x0A9E, 0x0AA7, 0x0AB1, 0x0ABA, 0x0AC4, 0x0ACD, 0x0AD7, 0x0AE0, 0x0AE9, 0x0AF3, 0x0AFC, 0x0B06, 0x0B0F, 0x0B19, 0x0B22, 0x0B2C, 0x0B35, 0x0B3F, 0x0B48, 0x0B51, 0x0B5B, 0x0B64, 0x0B6E, 0x0B77, 0x0B80, 0x0B8A, 0x0B93, 0x0B9D, 0x0BA6, 0x0BAF, 0x0BB9, 0x0BC2, 0x0BCB, 0x0BD5, 0x0BDE, 0x0BE7, 0x0BF1, 0x0BFA, 0x0C03, 0x0C0D, 0x0C16, 0x0C1F, 0x0C29, 0x0C32, 0x0C3B, 0x0C45, 0x0C4E, 0x0C57, 0x0C60, 0x0C6A, 0x0C73, 0x0C7C, 0x0C86, 0x0C8F, 0x0C98, 0x0CA1, 0x0CAB, 0x0CB4, 0x0CBD, 0x0CC6, 0x0CCF, 0x0CD9, 0x0CE2, 0x0CEB, 0x0CF4, 0x0CFD, 0x0D07, 0x0D10, 0x0D19, 0x0D22, 0x0D2B, 0x0D34, 0x0D3E, 0x0D47, 0x0D50, 0x0D59, 0x0D62, 0x0D6B, 0x0D74, 0x0D7D, 0x0D87, 0x0D90, 0x0D99, 0x0DA2, 0x0DAB, 0x0DB4, 0x0DBD, 0x0DC6, 0x0DCF, 0x0DD8, 0x0DE1, 0x0DEA, 0x0DF3, 0x0DFC, 0x0E05, 0x0E0F, 0x0E18, 0x0E21, 0x0E2A, 0x0E33, 0x0E3C, 0x0E45, 0x0E4E, 0x0E56, 0x0E5F, 0x0E68, 0x0E71, 0x0E7A, 0x0E83, 0x0E8C, 0x0E95, 0x0E9E, 0x0EA7, 0x0EB0, 0x0EB9, 0x0EC2, 0x0ECB, 0x0ED4, 0x0EDC, 0x0EE5, 0x0EEE, 0x0EF7, 0x0F00, 0x0F09, 0x0F12, 0x0F1B, 0x0F23, 0x0F2C, 0x0F35, 0x0F3E, 0x0F47, 0x0F50, 0x0F58, 0x0F61, 0x0F6A, 0x0F73, 0x0F7C, 0x0F84, 0x0F8D, 0x0F96, 0x0F9F, 0x0FA7, 0x0FB0, 0x0FB9, 0x0FC2, 0x0FCA, 0x0FD3, 0x0FDC, 0x0FE5, 0x0FED, 0x0FF6, 0x0FFF, 0x1007, 0x1010, 0x1019, 0x1021, 0x102A, 0x1033, 0x103B, 0x1044, 0x104D, 0x1055, 0x105E, 0x1067, 0x106F, 0x1078, 0x1080, 0x1089, 0x1092, 0x109A, 0x10A3, 0x10AB, 0x10B4, 0x10BC, 0x10C5, 0x10CE, 0x10D6, 0x10DF, 0x10E7, 0x10F0, 0x10F8, 0x1101, 0x1109, 0x1112, 0x111A, 0x1123, 0x112B, 0x1134, 0x113C, 0x1145, 0x114D, 0x1156, 0x115E, 0x1166, 0x116F, 0x1177, 0x1180, 0x1188, 0x1191, 0x1199, 0x11A1, 0x11AA, 0x11B2, 0x11BB, 0x11C3, 0x11CB, 0x11D4, 0x11DC, 0x11E4, 0x11ED, 0x11F5, 0x11FD, 0x1206, 0x120E, 0x1216, 0x121F, 0x1227, 0x122F, 0x1237, 0x1240, 0x1248, 0x1250, 0x1259, 0x1261, 0x1269, 0x1271, 0x127A, 0x1282, 0x128A, 0x1292, 0x129A, 0x12A3, 0x12AB, 0x12B3, 0x12BB, 0x12C3, 0x12CC, 0x12D4, 0x12DC, 0x12E4, 0x12EC, 0x12F4, 0x12FC, 0x1305, 0x130D, 0x1315, 0x131D, 0x1325, 0x132D, 0x1335, 0x133D, 0x1345, 0x134D, 0x1355, 0x135E, 0x1366, 0x136E, 0x1376, 0x137E, 0x1386, 0x138E, 0x1396, 0x139E, 0x13A6, 0x13AE, 0x13B6, 0x13BE, 0x13C6, 0x13CE, 0x13D6, 0x13DE, 0x13E6, 0x13ED, 0x13F5, 0x13FD, 0x1405, 0x140D, 0x1415, 0x141D, 0x1425, 0x142D, 0x1435, 0x143D, 0x1444, 0x144C, 0x1454, 0x145C, 0x1464, 0x146C, 0x1473, 0x147B, 0x1483, 0x148B, 0x1493, 0x149B, 0x14A2, 0x14AA, 0x14B2, 0x14BA, 0x14C1, 0x14C9, 0x14D1, 0x14D9, 0x14E0, 0x14E8, 0x14F0, 0x14F8, 0x14FF, 0x1507, 0x150F, 0x1516, 0x151E, 0x1526, 0x152D, 0x1535, 0x153D, 0x1544, 0x154C, 0x1554, 0x155B, 0x1563, 0x156B, 0x1572, 0x157A, 0x1581, 0x1589, 0x1591, 0x1598, 0x15A0, 0x15A7, 0x15AF, 0x15B7, 0x15BE, 0x15C6, 0x15CD, 0x15D5, 0x15DC, 0x15E4, 0x15EB, 0x15F3, 0x15FA, 0x1602, 0x1609, 0x1611, 0x1618, 0x1620, 0x1627, 0x162F, 0x1636, 0x163E, 0x1645, 0x164C, 0x1654, 0x165B, 0x1663, 0x166A, 0x1671, 0x1679, 0x1680, 0x1688, 0x168F, 0x1696, 0x169E, 0x16A5, 0x16AC, 0x16B4, 0x16BB, 0x16C2, 0x16CA, 0x16D1, 0x16D8, 0x16E0, 0x16E7, 0x16EE, 0x16F6, 0x16FD, 0x1704, 0x170B, 0x1713, 0x171A, 0x1721, 0x1728, 0x1730, 0x1737, 0x173E, 0x1745, 0x174C, 0x1754, 0x175B, 0x1762, 0x1769, 0x1770, 0x1778, 0x177F, 0x1786, 0x178D, 0x1794, 0x179B, 0x17A2, 0x17AA, 0x17B1, 0x17B8, 0x17BF, 0x17C6, 0x17CD, 0x17D4, 0x17DB, 0x17E2, 0x17E9, 0x17F0, 0x17F7, 0x17FE, 0x1806, 0x180D, 0x1814, 0x181B, 0x1822, 0x1829, 0x1830, 0x1837, 0x183E, 0x1845, 0x184C, 0x1853, 0x185A, 0x1860, 0x1867, 0x186E, 0x1875, 0x187C, 0x1883, 0x188A, 0x1891, 0x1898, 0x189F, 0x18A6, 0x18AD, 0x18B3, 0x18BA, 0x18C1, 0x18C8, 0x18CF, 0x18D6, 0x18DD, 0x18E3, 0x18EA, 0x18F1, 0x18F8, 0x18FF, 0x1906, 0x190C, 0x1913, 0x191A, 0x1921, 0x1928, 0x192E, 0x1935, 0x193C, 0x1943, 0x1949, 0x1950, 0x1957, 0x195D, 0x1964, 0x196B, 0x1972, 0x1978, 0x197F, 0x1986, 0x198C, 0x1993, 0x199A, 0x19A0, 0x19A7, 0x19AE, 0x19B4, 0x19BB, 0x19C2, 0x19C8, 0x19CF, 0x19D5, 0x19DC, 0x19E3, 0x19E9, 0x19F0, 0x19F6, 0x19FD, 0x1A04, 0x1A0A, 0x1A11, 0x1A17, 0x1A1E, 0x1A24, 0x1A2B, 0x1A31, 0x1A38, 0x1A3E, 0x1A45, 0x1A4B, 0x1A52, 0x1A58, 0x1A5F, 0x1A65, 0x1A6C, 0x1A72, 0x1A79, 0x1A7F, 0x1A86, 0x1A8C, 0x1A93, 0x1A99, 0x1A9F, 0x1AA6, 0x1AAC, 0x1AB3, 0x1AB9, 0x1AC0, 0x1AC6, 0x1ACC, 0x1AD3, 0x1AD9, 0x1ADF, 0x1AE6, 0x1AEC, 0x1AF2, 0x1AF9, 0x1AFF, 0x1B05, 0x1B0C, 0x1B12, 0x1B18, 0x1B1F, 0x1B25, 0x1B2B, 0x1B32, 0x1B38, 0x1B3E, 0x1B44, 0x1B4B, 0x1B51, 0x1B57, 0x1B5D, 0x1B64, 0x1B6A, 0x1B70, 0x1B76, 0x1B7D, 0x1B83, 0x1B89, 0x1B8F, 0x1B95, 0x1B9C, 0x1BA2, 0x1BA8, 0x1BAE, 0x1BB4, 0x1BBA, 0x1BC1, 0x1BC7, 0x1BCD, 0x1BD3, 0x1BD9, 0x1BDF, 0x1BE5, 0x1BEB, 0x1BF2, 0x1BF8, 0x1BFE, 0x1C04, 0x1C0A, 0x1C10, 0x1C16, 0x1C1C, 0x1C22, 0x1C28, 0x1C2E, 0x1C34, 0x1C3A, 0x1C40, 0x1C46, 0x1C4C, 0x1C52, 0x1C58, 0x1C5E, 0x1C64, 0x1C6A, 0x1C70, 0x1C76, 0x1C7C, 0x1C82, 0x1C88, 0x1C8E, 0x1C94, 0x1C9A, 0x1CA0, 0x1CA6, 0x1CAC, 0x1CB2, 0x1CB8, 0x1CBE, 0x1CC3, 0x1CC9, 0x1CCF, 0x1CD5, 0x1CDB, 0x1CE1, 0x1CE7, 0x1CED, 0x1CF3, 0x1CF8, 0x1CFE, 0x1D04, 0x1D0A, 0x1D10, 0x1D16, 0x1D1B, 0x1D21, 0x1D27, 0x1D2D, 0x1D33, 0x1D38, 0x1D3E, 0x1D44, 0x1D4A, 0x1D4F, 0x1D55, 0x1D5B, 0x1D61, 0x1D66, 0x1D6C, 0x1D72, 0x1D78, 0x1D7D, 0x1D83, 0x1D89, 0x1D8E, 0x1D94, 0x1D9A, 0x1DA0, 0x1DA5, 0x1DAB, 0x1DB1, 0x1DB6, 0x1DBC, 0x1DC2, 0x1DC7, 0x1DCD, 0x1DD3, 0x1DD8, 0x1DDE, 0x1DE3, 0x1DE9, 0x1DEF, 0x1DF4, 0x1DFA, 0x1DFF, 0x1E05, 0x1E0B, 0x1E10, 0x1E16, 0x1E1B, 0x1E21, 0x1E26, 0x1E2C, 0x1E32, 0x1E37, 0x1E3D, 0x1E42, 0x1E48, 0x1E4D, 0x1E53, 0x1E58, 0x1E5E, 0x1E63, 0x1E69, 0x1E6E, 0x1E74, 0x1E79, 0x1E7F, 0x1E84, 0x1E8A, 0x1E8F, 0x1E94, 0x1E9A, 0x1E9F, 0x1EA5, 0x1EAA, 0x1EB0, 0x1EB5, 0x1EBA, 0x1EC0, 0x1EC5, 0x1ECB, 0x1ED0, 0x1ED5, 0x1EDB, 0x1EE0, 0x1EE6, 0x1EEB, 0x1EF0, 0x1EF6, 0x1EFB, 0x1F00, 0x1F06, 0x1F0B, 0x1F10, 0x1F16, 0x1F1B, 0x1F20, 0x1F26, 0x1F2B, 0x1F30, 0x1F36, 0x1F3B, 0x1F40, 0x1F45, 0x1F4B, 0x1F50, 0x1F55, 0x1F5A, 0x1F60, 0x1F65, 0x1F6A, 0x1F6F, 0x1F75, 0x1F7A, 0x1F7F, 0x1F84, 0x1F8A, 0x1F8F, 0x1F94, 0x1F99, 0x1F9E, 0x1FA4, 0x1FA9, 0x1FAE, 0x1FB3, 0x1FB8, 0x1FBD, 0x1FC3, 0x1FC8, 0x1FCD, 0x1FD2, 0x1FD7, 0x1FDC, 0x1FE1, 0x1FE6, 0x1FEC, 0x1FF1, 0x1FF6, 0x1FFB, 0x2000, 0x2005, 0x200A, 0x200F, 0x2014, 0x201A, 0x201F, 0x2024, 0x2029, 0x202E, 0x2033, 0x2038, 0x203D, 0x2043, 0x2048, 0x204D, 0x2052, 0x2057, 0x205C, 0x2062, 0x2067, 0x206C, 0x2071, 0x2076, 0x207C, 0x2081, 0x2086, 0x208B, 0x2091, 0x2096, 0x209B, 0x20A0, 0x20A6, 0x20AB, 0x20B0, 0x20B5, 0x20BB, 0x20C0, 0x20C5, 0x20CA, 0x20D0, 0x20D5, 0x20DA, 0x20E0, 0x20E5, 0x20EA, 0x20F0, 0x20F5, 0x20FA, 0x2100, 0x2105, 0x210A, 0x2110, 0x2115, 0x211A, 0x2120, 0x2125, 0x212B, 0x2130, 0x2135, 0x213B, 0x2140, 0x2146, 0x214B, 0x2150, 0x2156, 0x215B, 0x2161, 0x2166, 0x216C, 0x2171, 0x2176, 0x217C, 0x2181, 0x2187, 0x218C, 0x2192, 0x2197, 0x219D, 0x21A2, 0x21A8, 0x21AD, 0x21B3, 0x21B8, 0x21BE, 0x21C3, 0x21C9, 0x21CE, 0x21D4, 0x21DA, 0x21DF, 0x21E5, 0x21EA, 0x21F0, 0x21F5, 0x21FB, 0x2201, 0x2206, 0x220C, 0x2211, 0x2217, 0x221D, 0x2222, 0x2228, 0x222D, 0x2233, 0x2239, 0x223E, 0x2244, 0x224A, 0x224F, 0x2255, 0x225B, 0x2260, 0x2266, 0x226C, 0x2272, 0x2277, 0x227D, 0x2283, 0x2288, 0x228E, 0x2294, 0x229A, 0x229F, 0x22A5, 0x22AB, 0x22B1, 0x22B6, 0x22BC, 0x22C2, 0x22C8, 0x22CD, 0x22D3, 0x22D9, 0x22DF, 0x22E5, 0x22EA, 0x22F0, 0x22F6, 0x22FC, 0x2302, 0x2308, 0x230D, 0x2313, 0x2319, 0x231F, 0x2325, 0x232B, 0x2331, 0x2337, 0x233D, 0x2342, 0x2348, 0x234E, 0x2354, 0x235A, 0x2360, 0x2366, 0x236C, 0x2372, 0x2378, 0x237E, 0x2384, 0x238A, 0x2390, 0x2396, 0x239C, 0x23A2, 0x23A8, 0x23AE, 0x23B4, 0x23BA, 0x23C0, 0x23C6, 0x23CC, 0x23D2, 0x23D8, 0x23DE, 0x23E4, 0x23EA, 0x23F0, 0x23F6, 0x23FC, 0x2402, 0x2408, 0x240E, 0x2415, 0x241B, 0x2421, 0x2427, 0x242D, 0x2433, 0x2439, 0x243F, 0x2446, 0x244C, 0x2452, 0x2458, 0x245E, 0x2464, 0x246B, 0x2471, 0x2477, 0x247D, 0x2483, 0x248A, 0x2490, 0x2496, 0x249C, 0x24A3, 0x24A9, 0x24AF, 0x24B5, 0x24BC, 0x24C2, 0x24C8, 0x24CE, 0x24D5, 0x24DB, 0x24E1, 0x24E8, 0x24EE, 0x24F4, 0x24FB, 0x2501, 0x2507, 0x250E, 0x2514, 0x251A, 0x2521, 0x2527, 0x252D, 0x2534, 0x253A, 0x2540, 0x2547, 0x254D, 0x2554, 0x255A, 0x2561, 0x2567, 0x256D, 0x2574, 0x257A, 0x2581, 0x2587, 0x258E, 0x2594, 0x259B, 0x25A1, 0x25A8, 0x25AE, 0x25B5, 0x25BB, 0x25C2, 0x25C8, 0x25CF, 0x25D5, 0x25DC, 0x25E2, 0x25E9, 0x25EF, 0x25F6, 0x25FC, 0x2603, 0x260A, 0x2610, 0x2617, 0x261D, 0x2624, 0x262B, 0x2631, 0x2638, 0x263E, 0x2645, 0x264C, 0x2652, 0x2659, 0x2660, 0x2666, 0x266D, 0x2674, 0x267A, 0x2681, 0x2688, 0x268E, 0x2695, 0x269C, 0x26A3, 0x26A9, 0x26B0, 0x26B7, 0x26BD, 0x26C4, 0x26CB, 0x26D2, 0x26D8, 0x26DF, 0x26E6, 0x26ED, 0x26F4, 0x26FA, 0x2701, 0x2708, 0x270F, 0x2716, 0x271D, 0x2723, 0x272A, 0x2731, 0x2738, 0x273F, 0x2746, 0x274D, 0x2753, 0x275A, 0x2761, 0x2768, 0x276F, 0x2776, 0x277D, 0x2784, 0x278B, 0x2792, 0x2799, 0x27A0, 0x27A6, 0x27AD, 0x27B4, 0x27BB, 0x27C2, 0x27C9, 0x27D0, 0x27D7, 0x27DE, 0x27E5, 0x27EC, 0x27F3, 0x27FA, 0x2802, 0x2809, 0x2810, 0x2817, 0x281E, 0x2825, 0x282C, 0x2833, 0x283A, 0x2841, 0x2848, 0x284F, 0x2856, 0x285E, 0x2865, 0x286C, 0x2873, 0x287A, 0x2881, 0x2888, 0x2890, 0x2897, 0x289E, 0x28A5, 0x28AC, 0x28B4, 0x28BB, 0x28C2, 0x28C9, 0x28D0, 0x28D8, 0x28DF, 0x28E6, 0x28ED, 0x28F5, 0x28FC, 0x2903, 0x290A, 0x2912, 0x2919, 0x2920, 0x2928, 0x292F, 0x2936, 0x293E, 0x2945, 0x294C, 0x2954, 0x295B, 0x2962, 0x296A, 0x2971, 0x2978, 0x2980, 0x2987, 0x298F, 0x2996, 0x299D, 0x29A5, 0x29AC, 0x29B4, 0x29BB, 0x29C2, 0x29CA, 0x29D1, 0x29D9, 0x29E0, 0x29E8, 0x29EF, 0x29F7, 0x29FE, 0x2A06, 0x2A0D, 0x2A15, 0x2A1C, 0x2A24, 0x2A2B, 0x2A33, 0x2A3A, 0x2A42, 0x2A49, 0x2A51, 0x2A59, 0x2A60, 0x2A68, 0x2A6F, 0x2A77, 0x2A7F, 0x2A86, 0x2A8E, 0x2A95, 0x2A9D, 0x2AA5, 0x2AAC, 0x2AB4, 0x2ABC, 0x2AC3, 0x2ACB, 0x2AD3, 0x2ADA, 0x2AE2, 0x2AEA, 0x2AF1, 0x2AF9, 0x2B01, 0x2B08, 0x2B10, 0x2B18, 0x2B20, 0x2B27, 0x2B2F, 0x2B37, 0x2B3F, 0x2B46, 0x2B4E, 0x2B56, 0x2B5E, 0x2B65, 0x2B6D, 0x2B75, 0x2B7D, 0x2B85, 0x2B8D, 0x2B94, 0x2B9C, 0x2BA4, 0x2BAC, 0x2BB4, 0x2BBC, 0x2BC3, 0x2BCB, 0x2BD3, 0x2BDB, 0x2BE3, 0x2BEB, 0x2BF3, 0x2BFB, 0x2C03, 0x2C0B, 0x2C13, 0x2C1A, 0x2C22, 0x2C2A, 0x2C32, 0x2C3A, 0x2C42, 0x2C4A, 0x2C52, 0x2C5A, 0x2C62, 0x2C6A, 0x2C72, 0x2C7A, 0x2C82, 0x2C8A, 0x2C92, 0x2C9A, 0x2CA2, 0x2CAB, 0x2CB3, 0x2CBB, 0x2CC3, 0x2CCB, 0x2CD3, 0x2CDB, 0x2CE3, 0x2CEB, 0x2CF3, 0x2CFB, 0x2D04, 0x2D0C, 0x2D14, 0x2D1C, 0x2D24, 0x2D2C, 0x2D34, 0x2D3D, 0x2D45, 0x2D4D, 0x2D55, 0x2D5D, 0x2D66, 0x2D6E, 0x2D76, 0x2D7E, 0x2D86, 0x2D8F, 0x2D97, 0x2D9F, 0x2DA7, 0x2DB0, 0x2DB8, 0x2DC0, 0x2DC9, 0x2DD1, 0x2DD9, 0x2DE1, 0x2DEA, 0x2DF2, 0x2DFA, 0x2E03, 0x2E0B, 0x2E13, 0x2E1C, 0x2E24, 0x2E2C, 0x2E35, 0x2E3D, 0x2E45, 0x2E4E, 0x2E56, 0x2E5F, 0x2E67, 0x2E6F, 0x2E78, 0x2E80, 0x2E89, 0x2E91, 0x2E9A, 0x2EA2, 0x2EAA, 0x2EB3, 0x2EBB, 0x2EC4, 0x2ECC, 0x2ED5, 0x2EDD, 0x2EE6, 0x2EEE, 0x2EF7, 0x2EFF, 0x2F08, 0x2F10, 0x2F19, 0x2F21, 0x2F2A, 0x2F32, 0x2F3B, 0x2F44, 0x2F4C, 0x2F55, 0x2F5D, 0x2F66, 0x2F6E, 0x2F77, 0x2F80, 0x2F88, 0x2F91, 0x2F99, 0x2FA2, 0x2FAB, 0x2FB3, 0x2FBC, 0x2FC5, 0x2FCD, 0x2FD6, 0x2FDF, 0x2FE7, 0x2FF0, 0x2FF9, 0x3001, 0x300A, 0x3013, 0x301B, 0x3024, 0x302D, 0x3036, 0x303E, 0x3047, 0x3050, 0x3059, 0x3061, 0x306A, 0x3073, 0x307C, 0x3084, 0x308D, 0x3096, 0x309F, 0x30A8, 0x30B0, 0x30B9, 0x30C2, 0x30CB, 0x30D4, 0x30DD, 0x30E5, 0x30EE, 0x30F7, 0x3100, 0x3109, 0x3112, 0x311B, 0x3124, 0x312C, 0x3135, 0x313E, 0x3147, 0x3150, 0x3159, 0x3162, 0x316B, 0x3174, 0x317D, 0x3186, 0x318F, 0x3198, 0x31A1, 0x31AA, 0x31B2, 0x31BB, 0x31C4, 0x31CD, 0x31D6, 0x31DF, 0x31E8, 0x31F1, 0x31FB, 0x3204, 0x320D, 0x3216, 0x321F, 0x3228, 0x3231, 0x323A, 0x3243, 0x324C, 0x3255, 0x325E, 0x3267, 0x3270, 0x3279, 0x3283, 0x328C, 0x3295, 0x329E, 0x32A7, 0x32B0, 0x32B9, 0x32C2, 0x32CC, 0x32D5, 0x32DE, 0x32E7, 0x32F0, 0x32F9, 0x3303, 0x330C, 0x3315, 0x331E, 0x3327, 0x3331, 0x333A, 0x3343, 0x334C, 0x3355, 0x335F, 0x3368, 0x3371, 0x337A, 0x3384, 0x338D, 0x3396, 0x33A0, 0x33A9, 0x33B2, 0x33BB, 0x33C5, 0x33CE, 0x33D7, 0x33E1, 0x33EA, 0x33F3, 0x33FD, 0x3406, 0x340F, 0x3419, 0x3422, 0x342B, 0x3435, 0x343E, 0x3447, 0x3451, 0x345A, 0x3463, 0x346D, 0x3476, 0x3480, 0x3489, 0x3492, 0x349C, 0x34A5, 0x34AF, 0x34B8, 0x34C1, 0x34CB, 0x34D4, 0x34DE, 0x34E7, 0x34F1, 0x34FA, 0x3504, 0x350D, 0x3517, 0x3520, 0x3529, 0x3533, 0x353C, 0x3546, 0x354F, 0x3559, 0x3562, 0x356C, 0x3575, 0x357F, 0x3589, 0x3592, 0x359C, 0x35A5, 0x35AF, 0x35B8, 0x35C2, 0x35CB, 0x35D5, 0x35DE, 0x35E8, 0x35F2, 0x35FB, 0x3605, 0x360E, 0x3618, 0x3622, 0x362B, 0x3635, 0x363E, 0x3648, 0x3652, 0x365B, 0x3665, 0x366E, 0x3678, 0x3682, 0x368B, 0x3695, 0x369F, 0x36A8, 0x36B2, 0x36BC, 0x36C5, 0x36CF, 0x36D9, 0x36E2, 0x36EC, 0x36F6, 0x36FF, 0x3709, 0x3713, 0x371D, 0x3726, 0x3730, 0x373A, 0x3743, 0x374D, 0x3757, 0x3761, 0x376A, 0x3774, 0x377E, 0x3788, 0x3791, 0x379B, 0x37A5, 0x37AF, 0x37B8, 0x37C2, 0x37CC, 0x37D6, 0x37E0, 0x37E9, 0x37F3, 0x37FD, 0x3807, 0x3811, 0x381A, 0x3824, 0x382E, 0x3838, 0x3842, 0x384B, 0x3855, 0x385F, 0x3869, 0x3873, 0x387D, 0x3886, 0x3890, 0x389A, 0x38A4, 0x38AE, 0x38B8, 0x38C2, 0x38CB, 0x38D5, 0x38DF, 0x38E9, 0x38F3, 0x38FD, 0x3907, 0x3911, 0x391B, 0x3924, 0x392E, 0x3938, 0x3942, 0x394C, 0x3956, 0x3960, 0x396A, 0x3974, 0x397E, 0x3988, 0x3992, 0x399B, 0x39A5, 0x39AF, 0x39B9, 0x39C3, 0x39CD, 0x39D7, 0x39E1, 0x39EB, 0x39F5, 0x39FF, 0x3A09, 0x3A13, 0x3A1D, 0x3A27, 0x3A31, 0x3A3B, 0x3A45, 0x3A4F, 0x3A59, 0x3A63, 0x3A6D, 0x3A77, 0x3A81, 0x3A8B, 0x3A95, 0x3A9F, 0x3AA9, 0x3AB3, 0x3ABD, 0x3AC7, 0x3AD1, 0x3ADB, 0x3AE5, 0x3AEF, 0x3AF9, 0x3B03, 0x3B0D, 0x3B17, 0x3B21, 0x3B2B, 0x3B35, 0x3B3F, 0x3B49, 0x3B53, 0x3B5D, 0x3B67, 0x3B72, 0x3B7C, 0x3B86, 0x3B90, 0x3B9A, 0x3BA4, 0x3BAE, 0x3BB8, 0x3BC2, 0x3BCC, 0x3BD6, 0x3BE0, 0x3BEA, 0x3BF4, 0x3BFF, 0x3C09, 0x3C13, 0x3C1D, 0x3C27, 0x3C31, 0x3C3B, 0x3C45, 0x3C4F, 0x3C59, 0x3C64, 0x3C6E, 0x3C78, 0x3C82, 0x3C8C, 0x3C96, 0x3CA0, 0x3CAA, 0x3CB4, 0x3CBF, 0x3CC9, 0x3CD3, 0x3CDD, 0x3CE7, 0x3CF1, 0x3CFB, 0x3D05, 0x3D10, 0x3D1A, 0x3D24, 0x3D2E, 0x3D38, 0x3D42, 0x3D4C, 0x3D57, 0x3D61, 0x3D6B, 0x3D75, 0x3D7F, 0x3D89, 0x3D93, 0x3D9E, 0x3DA8, 0x3DB2, 0x3DBC, 0x3DC6, 0x3DD0, 0x3DDA, 0x3DE5, 0x3DEF, 0x3DF9, 0x3E03, 0x3E0D, 0x3E17, 0x3E22, 0x3E2C, 0x3E36, 0x3E40, 0x3E4A, 0x3E54, 0x3E5F, 0x3E69, 0x3E73, 0x3E7D, 0x3E87, 0x3E91, 0x3E9C, 0x3EA6, 0x3EB0, 0x3EBA, 0x3EC4, 0x3ECF, 0x3ED9, 0x3EE3, 0x3EED, 0x3EF7, 0x3F01, 0x3F0C, 0x3F16, 0x3F20, 0x3F2A, 0x3F34, 0x3F3E, 0x3F49, 0x3F53, 0x3F5D, 0x3F67, 0x3F71, 0x3F7C, 0x3F86, 0x3F90, 0x3F9A, 0x3FA4, 0x3FAF, 0x3FB9, 0x3FC3, 0x3FCD, 0x3FD7, 0x3FE1, 0x3FEC, 0x3FF6, 0x4000, 0x400A, 0x4014, 0x401F, 0x4029, 0x4033, 0x403D, 0x4047, 0x4051, 0x405C, 0x4066, 0x4070, 0x407A, 0x4084, 0x408F, 0x4099, 0x40A3, 0x40AD, 0x40B7, 0x40C2, 0x40CC, 0x40D6, 0x40E0, 0x40EA, 0x40F4, 0x40FF, 0x4109, 0x4113, 0x411D, 0x4127, 0x4131, 0x413C, 0x4146, 0x4150, 0x415A, 0x4164, 0x416F, 0x4179, 0x4183, 0x418D, 0x4197, 0x41A1, 0x41AC, 0x41B6, 0x41C0, 0x41CA, 0x41D4, 0x41DE, 0x41E9, 0x41F3, 0x41FD, 0x4207, 0x4211, 0x421B, 0x4226, 0x4230, 0x423A, 0x4244, 0x424E, 0x4258, 0x4262, 0x426D, 0x4277, 0x4281, 0x428B, 0x4295, 0x429F, 0x42A9, 0x42B4, 0x42BE, 0x42C8, 0x42D2, 0x42DC, 0x42E6, 0x42F0, 0x42FB, 0x4305, 0x430F, 0x4319, 0x4323, 0x432D, 0x4337, 0x4341, 0x434C, 0x4356, 0x4360, 0x436A, 0x4374, 0x437E, 0x4388, 0x4392, 0x439C, 0x43A7, 0x43B1, 0x43BB, 0x43C5, 0x43CF, 0x43D9, 0x43E3, 0x43ED, 0x43F7, 0x4401, 0x440C, 0x4416, 0x4420, 0x442A, 0x4434, 0x443E, 0x4448, 0x4452, 0x445C, 0x4466, 0x4470, 0x447A, 0x4484, 0x448E, 0x4499, 0x44A3, 0x44AD, 0x44B7, 0x44C1, 0x44CB, 0x44D5, 0x44DF, 0x44E9, 0x44F3, 0x44FD, 0x4507, 0x4511, 0x451B, 0x4525, 0x452F, 0x4539, 0x4543, 0x454D, 0x4557, 0x4561, 0x456B, 0x4575, 0x457F, 0x4589, 0x4593, 0x459D, 0x45A7, 0x45B1, 0x45BB, 0x45C5, 0x45CF, 0x45D9, 0x45E3, 0x45ED, 0x45F7, 0x4601, 0x460B, 0x4615, 0x461F, 0x4629, 0x4633, 0x463D, 0x4647, 0x4651, 0x465B, 0x4665, 0x466E, 0x4678, 0x4682, 0x468C, 0x4696, 0x46A0, 0x46AA, 0x46B4, 0x46BE, 0x46C8, 0x46D2, 0x46DC, 0x46E5, 0x46EF, 0x46F9, 0x4703, 0x470D, 0x4717, 0x4721, 0x472B, 0x4735, 0x473E, 0x4748, 0x4752, 0x475C, 0x4766, 0x4770, 0x477A, 0x4783, 0x478D, 0x4797, 0x47A1, 0x47AB, 0x47B5, 0x47BE, 0x47C8, 0x47D2, 0x47DC, 0x47E6, 0x47EF, 0x47F9, 0x4803, 0x480D, 0x4817, 0x4820, 0x482A, 0x4834, 0x483E, 0x4848, 0x4851, 0x485B, 0x4865, 0x486F, 0x4878, 0x4882, 0x488C, 0x4896, 0x489F, 0x48A9, 0x48B3, 0x48BD, 0x48C6, 0x48D0, 0x48DA, 0x48E3, 0x48ED, 0x48F7, 0x4901, 0x490A, 0x4914, 0x491E, 0x4927, 0x4931, 0x493B, 0x4944, 0x494E, 0x4958, 0x4961, 0x496B, 0x4975, 0x497E, 0x4988, 0x4992, 0x499B, 0x49A5, 0x49AE, 0x49B8, 0x49C2, 0x49CB, 0x49D5, 0x49DE, 0x49E8, 0x49F2, 0x49FB, 0x4A05, 0x4A0E, 0x4A18, 0x4A22, 0x4A2B, 0x4A35, 0x4A3E, 0x4A48, 0x4A51, 0x4A5B, 0x4A64, 0x4A6E, 0x4A77, 0x4A81, 0x4A8B, 0x4A94, 0x4A9E, 0x4AA7, 0x4AB1, 0x4ABA, 0x4AC4, 0x4ACD, 0x4AD7, 0x4AE0, 0x4AE9, 0x4AF3, 0x4AFC, 0x4B06, 0x4B0F, 0x4B19, 0x4B22, 0x4B2C, 0x4B35, 0x4B3F, 0x4B48, 0x4B51, 0x4B5B, 0x4B64, 0x4B6E, 0x4B77, 0x4B80, 0x4B8A, 0x4B93, 0x4B9D, 0x4BA6, 0x4BAF, 0x4BB9, 0x4BC2, 0x4BCB, 0x4BD5, 0x4BDE, 0x4BE7, 0x4BF1, 0x4BFA, 0x4C03, 0x4C0D, 0x4C16, 0x4C1F, 0x4C29, 0x4C32, 0x4C3B, 0x4C45, 0x4C4E, 0x4C57, 0x4C60, 0x4C6A, 0x4C73, 0x4C7C, 0x4C86, 0x4C8F, 0x4C98, 0x4CA1, 0x4CAB, 0x4CB4, 0x4CBD, 0x4CC6, 0x4CCF, 0x4CD9, 0x4CE2, 0x4CEB, 0x4CF4, 0x4CFD, 0x4D07, 0x4D10, 0x4D19, 0x4D22, 0x4D2B, 0x4D34, 0x4D3E, 0x4D47, 0x4D50, 0x4D59, 0x4D62, 0x4D6B, 0x4D74, 0x4D7D, 0x4D87, 0x4D90, 0x4D99, 0x4DA2, 0x4DAB, 0x4DB4, 0x4DBD, 0x4DC6, 0x4DCF, 0x4DD8, 0x4DE1, 0x4DEA, 0x4DF3, 0x4DFC, 0x4E05, 0x4E0F, 0x4E18, 0x4E21, 0x4E2A, 0x4E33, 0x4E3C, 0x4E45, 0x4E4E, 0x4E56, 0x4E5F, 0x4E68, 0x4E71, 0x4E7A, 0x4E83, 0x4E8C, 0x4E95, 0x4E9E, 0x4EA7, 0x4EB0, 0x4EB9, 0x4EC2, 0x4ECB, 0x4ED4, 0x4EDC, 0x4EE5, 0x4EEE, 0x4EF7, 0x4F00, 0x4F09, 0x4F12, 0x4F1B, 0x4F23, 0x4F2C, 0x4F35, 0x4F3E, 0x4F47, 0x4F50, 0x4F58, 0x4F61, 0x4F6A, 0x4F73, 0x4F7C, 0x4F84, 0x4F8D, 0x4F96, 0x4F9F, 0x4FA7, 0x4FB0, 0x4FB9, 0x4FC2, 0x4FCA, 0x4FD3, 0x4FDC, 0x4FE5, 0x4FED, 0x4FF6, 0x4FFF, 0x5007, 0x5010, 0x5019, 0x5021, 0x502A, 0x5033, 0x503B, 0x5044, 0x504D, 0x5055, 0x505E, 0x5067, 0x506F, 0x5078, 0x5080, 0x5089, 0x5092, 0x509A, 0x50A3, 0x50AB, 0x50B4, 0x50BC, 0x50C5, 0x50CE, 0x50D6, 0x50DF, 0x50E7, 0x50F0, 0x50F8, 0x5101, 0x5109, 0x5112, 0x511A, 0x5123, 0x512B, 0x5134, 0x513C, 0x5145, 0x514D, 0x5156, 0x515E, 0x5166, 0x516F, 0x5177, 0x5180, 0x5188, 0x5191, 0x5199, 0x51A1, 0x51AA, 0x51B2, 0x51BB, 0x51C3, 0x51CB, 0x51D4, 0x51DC, 0x51E4, 0x51ED, 0x51F5, 0x51FD, 0x5206, 0x520E, 0x5216, 0x521F, 0x5227, 0x522F, 0x5237, 0x5240, 0x5248, 0x5250, 0x5259, 0x5261, 0x5269, 0x5271, 0x527A, 0x5282, 0x528A, 0x5292, 0x529A, 0x52A3, 0x52AB, 0x52B3, 0x52BB, 0x52C3, 0x52CC, 0x52D4, 0x52DC, 0x52E4, 0x52EC, 0x52F4, 0x52FC, 0x5305, 0x530D, 0x5315, 0x531D, 0x5325, 0x532D, 0x5335, 0x533D, 0x5345, 0x534D, 0x5355, 0x535E, 0x5366, 0x536E, 0x5376, 0x537E, 0x5386, 0x538E, 0x5396, 0x539E, 0x53A6, 0x53AE, 0x53B6, 0x53BE, 0x53C6, 0x53CE, 0x53D6, 0x53DE, 0x53E6, 0x53ED, 0x53F5, 0x53FD, 0x5405, 0x540D, 0x5415, 0x541D, 0x5425, 0x542D, 0x5435, 0x543D, 0x5444, 0x544C, 0x5454, 0x545C, 0x5464, 0x546C, 0x5473, 0x547B, 0x5483, 0x548B, 0x5493, 0x549B, 0x54A2, 0x54AA, 0x54B2, 0x54BA, 0x54C1, 0x54C9, 0x54D1, 0x54D9, 0x54E0, 0x54E8, 0x54F0, 0x54F8, 0x54FF, 0x5507, 0x550F, 0x5516, 0x551E, 0x5526, 0x552D, 0x5535, 0x553D, 0x5544, 0x554C, 0x5554, 0x555B, 0x5563, 0x556B, 0x5572, 0x557A, 0x5581, 0x5589, 0x5591, 0x5598, 0x55A0, 0x55A7, 0x55AF, 0x55B7, 0x55BE, 0x55C6, 0x55CD, 0x55D5, 0x55DC, 0x55E4, 0x55EB, 0x55F3, 0x55FA, 0x5602, 0x5609, 0x5611, 0x5618, 0x5620, 0x5627, 0x562F, 0x5636, 0x563E, 0x5645, 0x564C, 0x5654, 0x565B, 0x5663, 0x566A, 0x5671, 0x5679, 0x5680, 0x5688, 0x568F, 0x5696, 0x569E, 0x56A5, 0x56AC, 0x56B4, 0x56BB, 0x56C2, 0x56CA, 0x56D1, 0x56D8, 0x56E0, 0x56E7, 0x56EE, 0x56F6, 0x56FD, 0x5704, 0x570B, 0x5713, 0x571A, 0x5721, 0x5728, 0x5730, 0x5737, 0x573E, 0x5745, 0x574C, 0x5754, 0x575B, 0x5762, 0x5769, 0x5770, 0x5778, 0x577F, 0x5786, 0x578D, 0x5794, 0x579B, 0x57A2, 0x57AA, 0x57B1, 0x57B8, 0x57BF, 0x57C6, 0x57CD, 0x57D4, 0x57DB, 0x57E2, 0x57E9, 0x57F0, 0x57F7, 0x57FE, 0x5806, 0x580D, 0x5814, 0x581B, 0x5822, 0x5829, 0x5830, 0x5837, 0x583E, 0x5845, 0x584C, 0x5853, 0x585A, 0x5860, 0x5867, 0x586E, 0x5875, 0x587C, 0x5883, 0x588A, 0x5891, 0x5898, 0x589F, 0x58A6, 0x58AD, 0x58B3, 0x58BA, 0x58C1, 0x58C8, 0x58CF, 0x58D6, 0x58DD, 0x58E3, 0x58EA, 0x58F1, 0x58F8, 0x58FF, 0x5906, 0x590C, 0x5913, 0x591A, 0x5921, 0x5928, 0x592E, 0x5935, 0x593C, 0x5943, 0x5949, 0x5950, 0x5957, 0x595D, 0x5964, 0x596B, 0x5972, 0x5978, 0x597F, 0x5986, 0x598C, 0x5993, 0x599A, 0x59A0, 0x59A7, 0x59AE, 0x59B4, 0x59BB, 0x59C2, 0x59C8, 0x59CF, 0x59D5, 0x59DC, 0x59E3, 0x59E9, 0x59F0, 0x59F6, 0x59FD, 0x5A04, 0x5A0A, 0x5A11, 0x5A17, 0x5A1E, 0x5A24, 0x5A2B, 0x5A31, 0x5A38, 0x5A3E, 0x5A45, 0x5A4B, 0x5A52, 0x5A58, 0x5A5F, 0x5A65, 0x5A6C, 0x5A72, 0x5A79, 0x5A7F, 0x5A86, 0x5A8C, 0x5A93, 0x5A99, 0x5A9F, 0x5AA6, 0x5AAC, 0x5AB3, 0x5AB9, 0x5AC0, 0x5AC6, 0x5ACC, 0x5AD3, 0x5AD9, 0x5ADF, 0x5AE6, 0x5AEC, 0x5AF2, 0x5AF9, 0x5AFF, 0x5B05, 0x5B0C, 0x5B12, 0x5B18, 0x5B1F, 0x5B25, 0x5B2B, 0x5B32, 0x5B38, 0x5B3E, 0x5B44, 0x5B4B, 0x5B51, 0x5B57, 0x5B5D, 0x5B64, 0x5B6A, 0x5B70, 0x5B76, 0x5B7D, 0x5B83, 0x5B89, 0x5B8F, 0x5B95, 0x5B9C, 0x5BA2, 0x5BA8, 0x5BAE, 0x5BB4, 0x5BBA, 0x5BC1, 0x5BC7, 0x5BCD, 0x5BD3, 0x5BD9, 0x5BDF, 0x5BE5, 0x5BEB, 0x5BF2, 0x5BF8, 0x5BFE, 0x5C04, 0x5C0A, 0x5C10, 0x5C16, 0x5C1C, 0x5C22, 0x5C28, 0x5C2E, 0x5C34, 0x5C3A, 0x5C40, 0x5C46, 0x5C4C, 0x5C52, 0x5C58, 0x5C5E, 0x5C64, 0x5C6A, 0x5C70, 0x5C76, 0x5C7C, 0x5C82, 0x5C88, 0x5C8E, 0x5C94, 0x5C9A, 0x5CA0, 0x5CA6, 0x5CAC, 0x5CB2, 0x5CB8, 0x5CBE, 0x5CC3, 0x5CC9, 0x5CCF, 0x5CD5, 0x5CDB, 0x5CE1, 0x5CE7, 0x5CED, 0x5CF3, 0x5CF8, 0x5CFE, 0x5D04, 0x5D0A, 0x5D10, 0x5D16, 0x5D1B, 0x5D21, 0x5D27, 0x5D2D, 0x5D33, 0x5D38, 0x5D3E, 0x5D44, 0x5D4A, 0x5D4F, 0x5D55, 0x5D5B, 0x5D61, 0x5D66, 0x5D6C, 0x5D72, 0x5D78, 0x5D7D, 0x5D83, 0x5D89, 0x5D8E, 0x5D94, 0x5D9A, 0x5DA0, 0x5DA5, 0x5DAB, 0x5DB1, 0x5DB6, 0x5DBC, 0x5DC2, 0x5DC7, 0x5DCD, 0x5DD3, 0x5DD8, 0x5DDE, 0x5DE3, 0x5DE9, 0x5DEF, 0x5DF4, 0x5DFA, 0x5DFF, 0x5E05, 0x5E0B, 0x5E10, 0x5E16, 0x5E1B, 0x5E21, 0x5E26, 0x5E2C, 0x5E32, 0x5E37, 0x5E3D, 0x5E42, 0x5E48, 0x5E4D, 0x5E53, 0x5E58, 0x5E5E, 0x5E63, 0x5E69, 0x5E6E, 0x5E74, 0x5E79, 0x5E7F, 0x5E84, 0x5E8A, 0x5E8F, 0x5E94, 0x5E9A, 0x5E9F, 0x5EA5, 0x5EAA, 0x5EB0, 0x5EB5, 0x5EBA, 0x5EC0, 0x5EC5, 0x5ECB, 0x5ED0, 0x5ED5, 0x5EDB, 0x5EE0, 0x5EE6, 0x5EEB, 0x5EF0, 0x5EF6, 0x5EFB, 0x5F00, 0x5F06, 0x5F0B, 0x5F10, 0x5F16, 0x5F1B, 0x5F20, 0x5F26, 0x5F2B, 0x5F30, 0x5F36, 0x5F3B, 0x5F40, 0x5F45, 0x5F4B, 0x5F50, 0x5F55, 0x5F5A, 0x5F60, 0x5F65, 0x5F6A, 0x5F6F, 0x5F75, 0x5F7A, 0x5F7F, 0x5F84, 0x5F8A, 0x5F8F, 0x5F94, 0x5F99, 0x5F9E, 0x5FA4, 0x5FA9, 0x5FAE, 0x5FB3, 0x5FB8, 0x5FBD, 0x5FC3, 0x5FC8, 0x5FCD, 0x5FD2, 0x5FD7, 0x5FDC, 0x5FE1, 0x5FE6, 0x5FEC, 0x5FF1, 0x5FF6, 0x5FFB, 0x6000, 0x6005, 0x600A, 0x600F, 0x6014, 0x601A, 0x601F, 0x6024, 0x6029, 0x602E, 0x6033, 0x6038, 0x603D, 0x6043, 0x6048, 0x604D, 0x6052, 0x6057, 0x605C, 0x6062, 0x6067, 0x606C, 0x6071, 0x6076, 0x607C, 0x6081, 0x6086, 0x608B, 0x6091, 0x6096, 0x609B, 0x60A0, 0x60A6, 0x60AB, 0x60B0, 0x60B5, 0x60BB, 0x60C0, 0x60C5, 0x60CA, 0x60D0, 0x60D5, 0x60DA, 0x60E0, 0x60E5, 0x60EA, 0x60F0, 0x60F5, 0x60FA, 0x6100, 0x6105, 0x610A, 0x6110, 0x6115, 0x611A, 0x6120, 0x6125, 0x612B, 0x6130, 0x6135, 0x613B, 0x6140, 0x6146, 0x614B, 0x6150, 0x6156, 0x615B, 0x6161, 0x6166, 0x616C, 0x6171, 0x6176, 0x617C, 0x6181, 0x6187, 0x618C, 0x6192, 0x6197, 0x619D, 0x61A2, 0x61A8, 0x61AD, 0x61B3, 0x61B8, 0x61BE, 0x61C3, 0x61C9, 0x61CE, 0x61D4, 0x61DA, 0x61DF, 0x61E5, 0x61EA, 0x61F0, 0x61F5, 0x61FB, 0x6201, 0x6206, 0x620C, 0x6211, 0x6217, 0x621D, 0x6222, 0x6228, 0x622D, 0x6233, 0x6239, 0x623E, 0x6244, 0x624A, 0x624F, 0x6255, 0x625B, 0x6260, 0x6266, 0x626C, 0x6272, 0x6277, 0x627D, 0x6283, 0x6288, 0x628E, 0x6294, 0x629A, 0x629F, 0x62A5, 0x62AB, 0x62B1, 0x62B6, 0x62BC, 0x62C2, 0x62C8, 0x62CD, 0x62D3, 0x62D9, 0x62DF, 0x62E5, 0x62EA, 0x62F0, 0x62F6, 0x62FC, 0x6302, 0x6308, 0x630D, 0x6313, 0x6319, 0x631F, 0x6325, 0x632B, 0x6331, 0x6337, 0x633D, 0x6342, 0x6348, 0x634E, 0x6354, 0x635A, 0x6360, 0x6366, 0x636C, 0x6372, 0x6378, 0x637E, 0x6384, 0x638A, 0x6390, 0x6396, 0x639C, 0x63A2, 0x63A8, 0x63AE, 0x63B4, 0x63BA, 0x63C0, 0x63C6, 0x63CC, 0x63D2, 0x63D8, 0x63DE, 0x63E4, 0x63EA, 0x63F0, 0x63F6, 0x63FC, 0x6402, 0x6408, 0x640E, 0x6415, 0x641B, 0x6421, 0x6427, 0x642D, 0x6433, 0x6439, 0x643F, 0x6446, 0x644C, 0x6452, 0x6458, 0x645E, 0x6464, 0x646B, 0x6471, 0x6477, 0x647D, 0x6483, 0x648A, 0x6490, 0x6496, 0x649C, 0x64A3, 0x64A9, 0x64AF, 0x64B5, 0x64BC, 0x64C2, 0x64C8, 0x64CE, 0x64D5, 0x64DB, 0x64E1, 0x64E8, 0x64EE, 0x64F4, 0x64FB, 0x6501, 0x6507, 0x650E, 0x6514, 0x651A, 0x6521, 0x6527, 0x652D, 0x6534, 0x653A, 0x6540, 0x6547, 0x654D, 0x6554, 0x655A, 0x6561, 0x6567, 0x656D, 0x6574, 0x657A, 0x6581, 0x6587, 0x658E, 0x6594, 0x659B, 0x65A1, 0x65A8, 0x65AE, 0x65B5, 0x65BB, 0x65C2, 0x65C8, 0x65CF, 0x65D5, 0x65DC, 0x65E2, 0x65E9, 0x65EF, 0x65F6, 0x65FC, 0x6603, 0x660A, 0x6610, 0x6617, 0x661D, 0x6624, 0x662B, 0x6631, 0x6638, 0x663E, 0x6645, 0x664C, 0x6652, 0x6659, 0x6660, 0x6666, 0x666D, 0x6674, 0x667A, 0x6681, 0x6688, 0x668E, 0x6695, 0x669C, 0x66A3, 0x66A9, 0x66B0, 0x66B7, 0x66BD, 0x66C4, 0x66CB, 0x66D2, 0x66D8, 0x66DF, 0x66E6, 0x66ED, 0x66F4, 0x66FA, 0x6701, 0x6708, 0x670F, 0x6716, 0x671D, 0x6723, 0x672A, 0x6731, 0x6738, 0x673F, 0x6746, 0x674D, 0x6753, 0x675A, 0x6761, 0x6768, 0x676F, 0x6776, 0x677D, 0x6784, 0x678B, 0x6792, 0x6799, 0x67A0, 0x67A6, 0x67AD, 0x67B4, 0x67BB, 0x67C2, 0x67C9, 0x67D0, 0x67D7, 0x67DE, 0x67E5, 0x67EC, 0x67F3, 0x67FA, 0x6802, 0x6809, 0x6810, 0x6817, 0x681E, 0x6825, 0x682C, 0x6833, 0x683A, 0x6841, 0x6848, 0x684F, 0x6856, 0x685E, 0x6865, 0x686C, 0x6873, 0x687A, 0x6881, 0x6888, 0x6890, 0x6897, 0x689E, 0x68A5, 0x68AC, 0x68B4, 0x68BB, 0x68C2, 0x68C9, 0x68D0, 0x68D8, 0x68DF, 0x68E6, 0x68ED, 0x68F5, 0x68FC, 0x6903, 0x690A, 0x6912, 0x6919, 0x6920, 0x6928, 0x692F, 0x6936, 0x693E, 0x6945, 0x694C, 0x6954, 0x695B, 0x6962, 0x696A, 0x6971, 0x6978, 0x6980, 0x6987, 0x698F, 0x6996, 0x699D, 0x69A5, 0x69AC, 0x69B4, 0x69BB, 0x69C2, 0x69CA, 0x69D1, 0x69D9, 0x69E0, 0x69E8, 0x69EF, 0x69F7, 0x69FE, 0x6A06, 0x6A0D, 0x6A15, 0x6A1C, 0x6A24, 0x6A2B, 0x6A33, 0x6A3A, 0x6A42, 0x6A49, 0x6A51, 0x6A59, 0x6A60, 0x6A68, 0x6A6F, 0x6A77, 0x6A7F, 0x6A86, 0x6A8E, 0x6A95, 0x6A9D, 0x6AA5, 0x6AAC, 0x6AB4, 0x6ABC, 0x6AC3, 0x6ACB, 0x6AD3, 0x6ADA, 0x6AE2, 0x6AEA, 0x6AF1, 0x6AF9, 0x6B01, 0x6B08, 0x6B10, 0x6B18, 0x6B20, 0x6B27, 0x6B2F, 0x6B37, 0x6B3F, 0x6B46, 0x6B4E, 0x6B56, 0x6B5E, 0x6B65, 0x6B6D, 0x6B75, 0x6B7D, 0x6B85, 0x6B8D, 0x6B94, 0x6B9C, 0x6BA4, 0x6BAC, 0x6BB4, 0x6BBC, 0x6BC3, 0x6BCB, 0x6BD3, 0x6BDB, 0x6BE3, 0x6BEB, 0x6BF3, 0x6BFB, 0x6C03, 0x6C0B, 0x6C13, 0x6C1A, 0x6C22, 0x6C2A, 0x6C32, 0x6C3A, 0x6C42, 0x6C4A, 0x6C52, 0x6C5A, 0x6C62, 0x6C6A, 0x6C72, 0x6C7A, 0x6C82, 0x6C8A, 0x6C92, 0x6C9A, 0x6CA2, 0x6CAB, 0x6CB3, 0x6CBB, 0x6CC3, 0x6CCB, 0x6CD3, 0x6CDB, 0x6CE3, 0x6CEB, 0x6CF3, 0x6CFB, 0x6D04, 0x6D0C, 0x6D14, 0x6D1C, 0x6D24, 0x6D2C, 0x6D34, 0x6D3D, 0x6D45, 0x6D4D, 0x6D55, 0x6D5D, 0x6D66, 0x6D6E, 0x6D76, 0x6D7E, 0x6D86, 0x6D8F, 0x6D97, 0x6D9F, 0x6DA7, 0x6DB0, 0x6DB8, 0x6DC0, 0x6DC9, 0x6DD1, 0x6DD9, 0x6DE1, 0x6DEA, 0x6DF2, 0x6DFA, 0x6E03, 0x6E0B, 0x6E13, 0x6E1C, 0x6E24, 0x6E2C, 0x6E35, 0x6E3D, 0x6E45, 0x6E4E, 0x6E56, 0x6E5F, 0x6E67, 0x6E6F, 0x6E78, 0x6E80, 0x6E89, 0x6E91, 0x6E9A, 0x6EA2, 0x6EAA, 0x6EB3, 0x6EBB, 0x6EC4, 0x6ECC, 0x6ED5, 0x6EDD, 0x6EE6, 0x6EEE, 0x6EF7, 0x6EFF, 0x6F08, 0x6F10, 0x6F19, 0x6F21, 0x6F2A, 0x6F32, 0x6F3B, 0x6F44, 0x6F4C, 0x6F55, 0x6F5D, 0x6F66, 0x6F6E, 0x6F77, 0x6F80, 0x6F88, 0x6F91, 0x6F99, 0x6FA2, 0x6FAB, 0x6FB3, 0x6FBC, 0x6FC5, 0x6FCD, 0x6FD6, 0x6FDF, 0x6FE7, 0x6FF0, 0x6FF9, 0x7001, 0x700A, 0x7013, 0x701B, 0x7024, 0x702D, 0x7036, 0x703E, 0x7047, 0x7050, 0x7059, 0x7061, 0x706A, 0x7073, 0x707C, 0x7084, 0x708D, 0x7096, 0x709F, 0x70A8, 0x70B0, 0x70B9, 0x70C2, 0x70CB, 0x70D4, 0x70DD, 0x70E5, 0x70EE, 0x70F7, 0x7100, 0x7109, 0x7112, 0x711B, 0x7124, 0x712C, 0x7135, 0x713E, 0x7147, 0x7150, 0x7159, 0x7162, 0x716B, 0x7174, 0x717D, 0x7186, 0x718F, 0x7198, 0x71A1, 0x71AA, 0x71B2, 0x71BB, 0x71C4, 0x71CD, 0x71D6, 0x71DF, 0x71E8, 0x71F1, 0x71FB, 0x7204, 0x720D, 0x7216, 0x721F, 0x7228, 0x7231, 0x723A, 0x7243, 0x724C, 0x7255, 0x725E, 0x7267, 0x7270, 0x7279, 0x7283, 0x728C, 0x7295, 0x729E, 0x72A7, 0x72B0, 0x72B9, 0x72C2, 0x72CC, 0x72D5, 0x72DE, 0x72E7, 0x72F0, 0x72F9, 0x7303, 0x730C, 0x7315, 0x731E, 0x7327, 0x7331, 0x733A, 0x7343, 0x734C, 0x7355, 0x735F, 0x7368, 0x7371, 0x737A, 0x7384, 0x738D, 0x7396, 0x73A0, 0x73A9, 0x73B2, 0x73BB, 0x73C5, 0x73CE, 0x73D7, 0x73E1, 0x73EA, 0x73F3, 0x73FD, 0x7406, 0x740F, 0x7419, 0x7422, 0x742B, 0x7435, 0x743E, 0x7447, 0x7451, 0x745A, 0x7463, 0x746D, 0x7476, 0x7480, 0x7489, 0x7492, 0x749C, 0x74A5, 0x74AF, 0x74B8, 0x74C1, 0x74CB, 0x74D4, 0x74DE, 0x74E7, 0x74F1, 0x74FA, 0x7504, 0x750D, 0x7517, 0x7520, 0x7529, 0x7533, 0x753C, 0x7546, 0x754F, 0x7559, 0x7562, 0x756C, 0x7575, 0x757F, 0x7589, 0x7592, 0x759C, 0x75A5, 0x75AF, 0x75B8, 0x75C2, 0x75CB, 0x75D5, 0x75DE, 0x75E8, 0x75F2, 0x75FB, 0x7605, 0x760E, 0x7618, 0x7622, 0x762B, 0x7635, 0x763E, 0x7648, 0x7652, 0x765B, 0x7665, 0x766E, 0x7678, 0x7682, 0x768B, 0x7695, 0x769F, 0x76A8, 0x76B2, 0x76BC, 0x76C5, 0x76CF, 0x76D9, 0x76E2, 0x76EC, 0x76F6, 0x76FF, 0x7709, 0x7713, 0x771D, 0x7726, 0x7730, 0x773A, 0x7743, 0x774D, 0x7757, 0x7761, 0x776A, 0x7774, 0x777E, 0x7788, 0x7791, 0x779B, 0x77A5, 0x77AF, 0x77B8, 0x77C2, 0x77CC, 0x77D6, 0x77E0, 0x77E9, 0x77F3, 0x77FD, 0x7807, 0x7811, 0x781A, 0x7824, 0x782E, 0x7838, 0x7842, 0x784B, 0x7855, 0x785F, 0x7869, 0x7873, 0x787D, 0x7886, 0x7890, 0x789A, 0x78A4, 0x78AE, 0x78B8, 0x78C2, 0x78CB, 0x78D5, 0x78DF, 0x78E9, 0x78F3, 0x78FD, 0x7907, 0x7911, 0x791B, 0x7924, 0x792E, 0x7938, 0x7942, 0x794C, 0x7956, 0x7960, 0x796A, 0x7974, 0x797E, 0x7988, 0x7992, 0x799B, 0x79A5, 0x79AF, 0x79B9, 0x79C3, 0x79CD, 0x79D7, 0x79E1, 0x79EB, 0x79F5, 0x79FF, 0x7A09, 0x7A13, 0x7A1D, 0x7A27, 0x7A31, 0x7A3B, 0x7A45, 0x7A4F, 0x7A59, 0x7A63, 0x7A6D, 0x7A77, 0x7A81, 0x7A8B, 0x7A95, 0x7A9F, 0x7AA9, 0x7AB3, 0x7ABD, 0x7AC7, 0x7AD1, 0x7ADB, 0x7AE5, 0x7AEF, 0x7AF9, 0x7B03, 0x7B0D, 0x7B17, 0x7B21, 0x7B2B, 0x7B35, 0x7B3F, 0x7B49, 0x7B53, 0x7B5D, 0x7B67, 0x7B72, 0x7B7C, 0x7B86, 0x7B90, 0x7B9A, 0x7BA4, 0x7BAE, 0x7BB8, 0x7BC2, 0x7BCC, 0x7BD6, 0x7BE0, 0x7BEA, 0x7BF4, 0x7BFF, 0x7C09, 0x7C13, 0x7C1D, 0x7C27, 0x7C31, 0x7C3B, 0x7C45, 0x7C4F, 0x7C59, 0x7C64, 0x7C6E, 0x7C78, 0x7C82, 0x7C8C, 0x7C96, 0x7CA0, 0x7CAA, 0x7CB4, 0x7CBF, 0x7CC9, 0x7CD3, 0x7CDD, 0x7CE7, 0x7CF1, 0x7CFB, 0x7D05, 0x7D10, 0x7D1A, 0x7D24, 0x7D2E, 0x7D38, 0x7D42, 0x7D4C, 0x7D57, 0x7D61, 0x7D6B, 0x7D75, 0x7D7F, 0x7D89, 0x7D93, 0x7D9E, 0x7DA8, 0x7DB2, 0x7DBC, 0x7DC6, 0x7DD0, 0x7DDA, 0x7DE5, 0x7DEF, 0x7DF9, 0x7E03, 0x7E0D, 0x7E17, 0x7E22, 0x7E2C, 0x7E36, 0x7E40, 0x7E4A, 0x7E54, 0x7E5F, 0x7E69, 0x7E73, 0x7E7D, 0x7E87, 0x7E91, 0x7E9C, 0x7EA6, 0x7EB0, 0x7EBA, 0x7EC4, 0x7ECF, 0x7ED9, 0x7EE3, 0x7EED, 0x7EF7, 0x7F01, 0x7F0C, 0x7F16, 0x7F20, 0x7F2A, 0x7F34, 0x7F3E, 0x7F49, 0x7F53, 0x7F5D, 0x7F67, 0x7F71, 0x7F7C, 0x7F86, 0x7F90, 0x7F9A, 0x7FA4, 0x7FAF, 0x7FB9, 0x7FC3, 0x7FCD, 0x7FD7, 0x7FE1, 0x7FEC, 0x7FF6, 0x8000, 0x800A, 0x8014, 0x801F, 0x8029, 0x8033, 0x803D, 0x8047, 0x8051, 0x805C, 0x8066, 0x8070, 0x807A, 0x8084, 0x808F, 0x8099, 0x80A3, 0x80AD, 0x80B7, 0x80C2, 0x80CC, 0x80D6, 0x80E0, 0x80EA, 0x80F4, 0x80FF, 0x8109, 0x8113, 0x811D, 0x8127, 0x8131, 0x813C, 0x8146, 0x8150, 0x815A, 0x8164, 0x816F, 0x8179, 0x8183, 0x818D, 0x8197, 0x81A1, 0x81AC, 0x81B6, 0x81C0, 0x81CA, 0x81D4, 0x81DE, 0x81E9, 0x81F3, 0x81FD, 0x8207, 0x8211, 0x821B, 0x8226, 0x8230, 0x823A, 0x8244, 0x824E, 0x8258, 0x8262, 0x826D, 0x8277, 0x8281, 0x828B, 0x8295, 0x829F, 0x82A9, 0x82B4, 0x82BE, 0x82C8, 0x82D2, 0x82DC, 0x82E6, 0x82F0, 0x82FB, 0x8305, 0x830F, 0x8319, 0x8323, 0x832D, 0x8337, 0x8341, 0x834C, 0x8356, 0x8360, 0x836A, 0x8374, 0x837E, 0x8388, 0x8392, 0x839C, 0x83A7, 0x83B1, 0x83BB, 0x83C5, 0x83CF, 0x83D9, 0x83E3, 0x83ED, 0x83F7, 0x8401, 0x840C, 0x8416, 0x8420, 0x842A, 0x8434, 0x843E, 0x8448, 0x8452, 0x845C, 0x8466, 0x8470, 0x847A, 0x8484, 0x848E, 0x8499, 0x84A3, 0x84AD, 0x84B7, 0x84C1, 0x84CB, 0x84D5, 0x84DF, 0x84E9, 0x84F3, 0x84FD, 0x8507, 0x8511, 0x851B, 0x8525, 0x852F, 0x8539, 0x8543, 0x854D, 0x8557, 0x8561, 0x856B, 0x8575, 0x857F, 0x8589, 0x8593, 0x859D, 0x85A7, 0x85B1, 0x85BB, 0x85C5, 0x85CF, 0x85D9, 0x85E3, 0x85ED, 0x85F7, 0x8601, 0x860B, 0x8615, 0x861F, 0x8629, 0x8633, 0x863D, 0x8647, 0x8651, 0x865B, 0x8665, 0x866E, 0x8678, 0x8682, 0x868C, 0x8696, 0x86A0, 0x86AA, 0x86B4, 0x86BE, 0x86C8, 0x86D2, 0x86DC, 0x86E5, 0x86EF, 0x86F9, 0x8703, 0x870D, 0x8717, 0x8721, 0x872B, 0x8735, 0x873E, 0x8748, 0x8752, 0x875C, 0x8766, 0x8770, 0x877A, 0x8783, 0x878D, 0x8797, 0x87A1, 0x87AB, 0x87B5, 0x87BE, 0x87C8, 0x87D2, 0x87DC, 0x87E6, 0x87EF, 0x87F9, 0x8803, 0x880D, 0x8817, 0x8820, 0x882A, 0x8834, 0x883E, 0x8848, 0x8851, 0x885B, 0x8865, 0x886F, 0x8878, 0x8882, 0x888C, 0x8896, 0x889F, 0x88A9, 0x88B3, 0x88BD, 0x88C6, 0x88D0, 0x88DA, 0x88E3, 0x88ED, 0x88F7, 0x8901, 0x890A, 0x8914, 0x891E, 0x8927, 0x8931, 0x893B, 0x8944, 0x894E, 0x8958, 0x8961, 0x896B, 0x8975, 0x897E, 0x8988, 0x8992, 0x899B, 0x89A5, 0x89AE, 0x89B8, 0x89C2, 0x89CB, 0x89D5, 0x89DE, 0x89E8, 0x89F2, 0x89FB, 0x8A05, 0x8A0E, 0x8A18, 0x8A22, 0x8A2B, 0x8A35, 0x8A3E, 0x8A48, 0x8A51, 0x8A5B, 0x8A64, 0x8A6E, 0x8A77, 0x8A81, 0x8A8B, 0x8A94, 0x8A9E, 0x8AA7, 0x8AB1, 0x8ABA, 0x8AC4, 0x8ACD, 0x8AD7, 0x8AE0, 0x8AE9, 0x8AF3, 0x8AFC, 0x8B06, 0x8B0F, 0x8B19, 0x8B22, 0x8B2C, 0x8B35, 0x8B3F, 0x8B48, 0x8B51, 0x8B5B, 0x8B64, 0x8B6E, 0x8B77, 0x8B80, 0x8B8A, 0x8B93, 0x8B9D, 0x8BA6, 0x8BAF, 0x8BB9, 0x8BC2, 0x8BCB, 0x8BD5, 0x8BDE, 0x8BE7, 0x8BF1, 0x8BFA, 0x8C03, 0x8C0D, 0x8C16, 0x8C1F, 0x8C29, 0x8C32, 0x8C3B, 0x8C45, 0x8C4E, 0x8C57, 0x8C60, 0x8C6A, 0x8C73, 0x8C7C, 0x8C86, 0x8C8F, 0x8C98, 0x8CA1, 0x8CAB, 0x8CB4, 0x8CBD, 0x8CC6, 0x8CCF, 0x8CD9, 0x8CE2, 0x8CEB, 0x8CF4, 0x8CFD, 0x8D07, 0x8D10, 0x8D19, 0x8D22, 0x8D2B, 0x8D34, 0x8D3E, 0x8D47, 0x8D50, 0x8D59, 0x8D62, 0x8D6B, 0x8D74, 0x8D7D, 0x8D87, 0x8D90, 0x8D99, 0x8DA2, 0x8DAB, 0x8DB4, 0x8DBD, 0x8DC6, 0x8DCF, 0x8DD8, 0x8DE1, 0x8DEA, 0x8DF3, 0x8DFC, 0x8E05, 0x8E0F, 0x8E18, 0x8E21, 0x8E2A, 0x8E33, 0x8E3C, 0x8E45, 0x8E4E, 0x8E56, 0x8E5F, 0x8E68, 0x8E71, 0x8E7A, 0x8E83, 0x8E8C, 0x8E95, 0x8E9E, 0x8EA7, 0x8EB0, 0x8EB9, 0x8EC2, 0x8ECB, 0x8ED4, 0x8EDC, 0x8EE5, 0x8EEE, 0x8EF7, 0x8F00, 0x8F09, 0x8F12, 0x8F1B, 0x8F23, 0x8F2C, 0x8F35, 0x8F3E, 0x8F47, 0x8F50, 0x8F58, 0x8F61, 0x8F6A, 0x8F73, 0x8F7C, 0x8F84, 0x8F8D, 0x8F96, 0x8F9F, 0x8FA7, 0x8FB0, 0x8FB9, 0x8FC2, 0x8FCA, 0x8FD3, 0x8FDC, 0x8FE5, 0x8FED, 0x8FF6, 0x8FFF, 0x9007, 0x9010, 0x9019, 0x9021, 0x902A, 0x9033, 0x903B, 0x9044, 0x904D, 0x9055, 0x905E, 0x9067, 0x906F, 0x9078, 0x9080, 0x9089, 0x9092, 0x909A, 0x90A3, 0x90AB, 0x90B4, 0x90BC, 0x90C5, 0x90CE, 0x90D6, 0x90DF, 0x90E7, 0x90F0, 0x90F8, 0x9101, 0x9109, 0x9112, 0x911A, 0x9123, 0x912B, 0x9134, 0x913C, 0x9145, 0x914D, 0x9156, 0x915E, 0x9166, 0x916F, 0x9177, 0x9180, 0x9188, 0x9191, 0x9199, 0x91A1, 0x91AA, 0x91B2, 0x91BB, 0x91C3, 0x91CB, 0x91D4, 0x91DC, 0x91E4, 0x91ED, 0x91F5, 0x91FD, 0x9206, 0x920E, 0x9216, 0x921F, 0x9227, 0x922F, 0x9237, 0x9240, 0x9248, 0x9250, 0x9259, 0x9261, 0x9269, 0x9271, 0x927A, 0x9282, 0x928A, 0x9292, 0x929A, 0x92A3, 0x92AB, 0x92B3, 0x92BB, 0x92C3, 0x92CC, 0x92D4, 0x92DC, 0x92E4, 0x92EC, 0x92F4, 0x92FC, 0x9305, 0x930D, 0x9315, 0x931D, 0x9325, 0x932D, 0x9335, 0x933D, 0x9345, 0x934D, 0x9355, 0x935E, 0x9366, 0x936E, 0x9376, 0x937E, 0x9386, 0x938E, 0x9396, 0x939E, 0x93A6, 0x93AE, 0x93B6, 0x93BE, 0x93C6, 0x93CE, 0x93D6, 0x93DE, 0x93E6, 0x93ED, 0x93F5, 0x93FD, 0x9405, 0x940D, 0x9415, 0x941D, 0x9425, 0x942D, 0x9435, 0x943D, 0x9444, 0x944C, 0x9454, 0x945C, 0x9464, 0x946C, 0x9473, 0x947B, 0x9483, 0x948B, 0x9493, 0x949B, 0x94A2, 0x94AA, 0x94B2, 0x94BA, 0x94C1, 0x94C9, 0x94D1, 0x94D9, 0x94E0, 0x94E8, 0x94F0, 0x94F8, 0x94FF, 0x9507, 0x950F, 0x9516, 0x951E, 0x9526, 0x952D, 0x9535, 0x953D, 0x9544, 0x954C, 0x9554, 0x955B, 0x9563, 0x956B, 0x9572, 0x957A, 0x9581, 0x9589, 0x9591, 0x9598, 0x95A0, 0x95A7, 0x95AF, 0x95B7, 0x95BE, 0x95C6, 0x95CD, 0x95D5, 0x95DC, 0x95E4, 0x95EB, 0x95F3, 0x95FA, 0x9602, 0x9609, 0x9611, 0x9618, 0x9620, 0x9627, 0x962F, 0x9636, 0x963E, 0x9645, 0x964C, 0x9654, 0x965B, 0x9663, 0x966A, 0x9671, 0x9679, 0x9680, 0x9688, 0x968F, 0x9696, 0x969E, 0x96A5, 0x96AC, 0x96B4, 0x96BB, 0x96C2, 0x96CA, 0x96D1, 0x96D8, 0x96E0, 0x96E7, 0x96EE, 0x96F6, 0x96FD, 0x9704, 0x970B, 0x9713, 0x971A, 0x9721, 0x9728, 0x9730, 0x9737, 0x973E, 0x9745, 0x974C, 0x9754, 0x975B, 0x9762, 0x9769, 0x9770, 0x9778, 0x977F, 0x9786, 0x978D, 0x9794, 0x979B, 0x97A2, 0x97AA, 0x97B1, 0x97B8, 0x97BF, 0x97C6, 0x97CD, 0x97D4, 0x97DB, 0x97E2, 0x97E9, 0x97F0, 0x97F7, 0x97FE, 0x9806, 0x980D, 0x9814, 0x981B, 0x9822, 0x9829, 0x9830, 0x9837, 0x983E, 0x9845, 0x984C, 0x9853, 0x985A, 0x9860, 0x9867, 0x986E, 0x9875, 0x987C, 0x9883, 0x988A, 0x9891, 0x9898, 0x989F, 0x98A6, 0x98AD, 0x98B3, 0x98BA, 0x98C1, 0x98C8, 0x98CF, 0x98D6, 0x98DD, 0x98E3, 0x98EA, 0x98F1, 0x98F8, 0x98FF, 0x9906, 0x990C, 0x9913, 0x991A, 0x9921, 0x9928, 0x992E, 0x9935, 0x993C, 0x9943, 0x9949, 0x9950, 0x9957, 0x995D, 0x9964, 0x996B, 0x9972, 0x9978, 0x997F, 0x9986, 0x998C, 0x9993, 0x999A, 0x99A0, 0x99A7, 0x99AE, 0x99B4, 0x99BB, 0x99C2, 0x99C8, 0x99CF, 0x99D5, 0x99DC, 0x99E3, 0x99E9, 0x99F0, 0x99F6, 0x99FD, 0x9A04, 0x9A0A, 0x9A11, 0x9A17, 0x9A1E, 0x9A24, 0x9A2B, 0x9A31, 0x9A38, 0x9A3E, 0x9A45, 0x9A4B, 0x9A52, 0x9A58, 0x9A5F, 0x9A65, 0x9A6C, 0x9A72, 0x9A79, 0x9A7F, 0x9A86, 0x9A8C, 0x9A93, 0x9A99, 0x9A9F, 0x9AA6, 0x9AAC, 0x9AB3, 0x9AB9, 0x9AC0, 0x9AC6, 0x9ACC, 0x9AD3, 0x9AD9, 0x9ADF, 0x9AE6, 0x9AEC, 0x9AF2, 0x9AF9, 0x9AFF, 0x9B05, 0x9B0C, 0x9B12, 0x9B18, 0x9B1F, 0x9B25, 0x9B2B, 0x9B32, 0x9B38, 0x9B3E, 0x9B44, 0x9B4B, 0x9B51, 0x9B57, 0x9B5D, 0x9B64, 0x9B6A, 0x9B70, 0x9B76, 0x9B7D, 0x9B83, 0x9B89, 0x9B8F, 0x9B95, 0x9B9C, 0x9BA2, 0x9BA8, 0x9BAE, 0x9BB4, 0x9BBA, 0x9BC1, 0x9BC7, 0x9BCD, 0x9BD3, 0x9BD9, 0x9BDF, 0x9BE5, 0x9BEB, 0x9BF2, 0x9BF8, 0x9BFE, 0x9C04, 0x9C0A, 0x9C10, 0x9C16, 0x9C1C, 0x9C22, 0x9C28, 0x9C2E, 0x9C34, 0x9C3A, 0x9C40, 0x9C46, 0x9C4C, 0x9C52, 0x9C58, 0x9C5E, 0x9C64, 0x9C6A, 0x9C70, 0x9C76, 0x9C7C, 0x9C82, 0x9C88, 0x9C8E, 0x9C94, 0x9C9A, 0x9CA0, 0x9CA6, 0x9CAC, 0x9CB2, 0x9CB8, 0x9CBE, 0x9CC3, 0x9CC9, 0x9CCF, 0x9CD5, 0x9CDB, 0x9CE1, 0x9CE7, 0x9CED, 0x9CF3, 0x9CF8, 0x9CFE, 0x9D04, 0x9D0A, 0x9D10, 0x9D16, 0x9D1B, 0x9D21, 0x9D27, 0x9D2D, 0x9D33, 0x9D38, 0x9D3E, 0x9D44, 0x9D4A, 0x9D4F, 0x9D55, 0x9D5B, 0x9D61, 0x9D66, 0x9D6C, 0x9D72, 0x9D78, 0x9D7D, 0x9D83, 0x9D89, 0x9D8E, 0x9D94, 0x9D9A, 0x9DA0, 0x9DA5, 0x9DAB, 0x9DB1, 0x9DB6, 0x9DBC, 0x9DC2, 0x9DC7, 0x9DCD, 0x9DD3, 0x9DD8, 0x9DDE, 0x9DE3, 0x9DE9, 0x9DEF, 0x9DF4, 0x9DFA, 0x9DFF, 0x9E05, 0x9E0B, 0x9E10, 0x9E16, 0x9E1B, 0x9E21, 0x9E26, 0x9E2C, 0x9E32, 0x9E37, 0x9E3D, 0x9E42, 0x9E48, 0x9E4D, 0x9E53, 0x9E58, 0x9E5E, 0x9E63, 0x9E69, 0x9E6E, 0x9E74, 0x9E79, 0x9E7F, 0x9E84, 0x9E8A, 0x9E8F, 0x9E94, 0x9E9A, 0x9E9F, 0x9EA5, 0x9EAA, 0x9EB0, 0x9EB5, 0x9EBA, 0x9EC0, 0x9EC5, 0x9ECB, 0x9ED0, 0x9ED5, 0x9EDB, 0x9EE0, 0x9EE6, 0x9EEB, 0x9EF0, 0x9EF6, 0x9EFB, 0x9F00, 0x9F06, 0x9F0B, 0x9F10, 0x9F16, 0x9F1B, 0x9F20, 0x9F26, 0x9F2B, 0x9F30, 0x9F36, 0x9F3B, 0x9F40, 0x9F45, 0x9F4B, 0x9F50, 0x9F55, 0x9F5A, 0x9F60, 0x9F65, 0x9F6A, 0x9F6F, 0x9F75, 0x9F7A, 0x9F7F, 0x9F84, 0x9F8A, 0x9F8F, 0x9F94, 0x9F99, 0x9F9E, 0x9FA4, 0x9FA9, 0x9FAE, 0x9FB3, 0x9FB8, 0x9FBD, 0x9FC3, 0x9FC8, 0x9FCD, 0x9FD2, 0x9FD7, 0x9FDC, 0x9FE1, 0x9FE6, 0x9FEC, 0x9FF1, 0x9FF6, 0x9FFB, 0xA000, 0xA005, 0xA00A, 0xA00F, 0xA014, 0xA01A, 0xA01F, 0xA024, 0xA029, 0xA02E, 0xA033, 0xA038, 0xA03D, 0xA043, 0xA048, 0xA04D, 0xA052, 0xA057, 0xA05C, 0xA062, 0xA067, 0xA06C, 0xA071, 0xA076, 0xA07C, 0xA081, 0xA086, 0xA08B, 0xA091, 0xA096, 0xA09B, 0xA0A0, 0xA0A6, 0xA0AB, 0xA0B0, 0xA0B5, 0xA0BB, 0xA0C0, 0xA0C5, 0xA0CA, 0xA0D0, 0xA0D5, 0xA0DA, 0xA0E0, 0xA0E5, 0xA0EA, 0xA0F0, 0xA0F5, 0xA0FA, 0xA100, 0xA105, 0xA10A, 0xA110, 0xA115, 0xA11A, 0xA120, 0xA125, 0xA12B, 0xA130, 0xA135, 0xA13B, 0xA140, 0xA146, 0xA14B, 0xA150, 0xA156, 0xA15B, 0xA161, 0xA166, 0xA16C, 0xA171, 0xA176, 0xA17C, 0xA181, 0xA187, 0xA18C, 0xA192, 0xA197, 0xA19D, 0xA1A2, 0xA1A8, 0xA1AD, 0xA1B3, 0xA1B8, 0xA1BE, 0xA1C3, 0xA1C9, 0xA1CE, 0xA1D4, 0xA1DA, 0xA1DF, 0xA1E5, 0xA1EA, 0xA1F0, 0xA1F5, 0xA1FB, 0xA201, 0xA206, 0xA20C, 0xA211, 0xA217, 0xA21D, 0xA222, 0xA228, 0xA22D, 0xA233, 0xA239, 0xA23E, 0xA244, 0xA24A, 0xA24F, 0xA255, 0xA25B, 0xA260, 0xA266, 0xA26C, 0xA272, 0xA277, 0xA27D, 0xA283, 0xA288, 0xA28E, 0xA294, 0xA29A, 0xA29F, 0xA2A5, 0xA2AB, 0xA2B1, 0xA2B6, 0xA2BC, 0xA2C2, 0xA2C8, 0xA2CD, 0xA2D3, 0xA2D9, 0xA2DF, 0xA2E5, 0xA2EA, 0xA2F0, 0xA2F6, 0xA2FC, 0xA302, 0xA308, 0xA30D, 0xA313, 0xA319, 0xA31F, 0xA325, 0xA32B, 0xA331, 0xA337, 0xA33D, 0xA342, 0xA348, 0xA34E, 0xA354, 0xA35A, 0xA360, 0xA366, 0xA36C, 0xA372, 0xA378, 0xA37E, 0xA384, 0xA38A, 0xA390, 0xA396, 0xA39C, 0xA3A2, 0xA3A8, 0xA3AE, 0xA3B4, 0xA3BA, 0xA3C0, 0xA3C6, 0xA3CC, 0xA3D2, 0xA3D8, 0xA3DE, 0xA3E4, 0xA3EA, 0xA3F0, 0xA3F6, 0xA3FC, 0xA402, 0xA408, 0xA40E, 0xA415, 0xA41B, 0xA421, 0xA427, 0xA42D, 0xA433, 0xA439, 0xA43F, 0xA446, 0xA44C, 0xA452, 0xA458, 0xA45E, 0xA464, 0xA46B, 0xA471, 0xA477, 0xA47D, 0xA483, 0xA48A, 0xA490, 0xA496, 0xA49C, 0xA4A3, 0xA4A9, 0xA4AF, 0xA4B5, 0xA4BC, 0xA4C2, 0xA4C8, 0xA4CE, 0xA4D5, 0xA4DB, 0xA4E1, 0xA4E8, 0xA4EE, 0xA4F4, 0xA4FB, 0xA501, 0xA507, 0xA50E, 0xA514, 0xA51A, 0xA521, 0xA527, 0xA52D, 0xA534, 0xA53A, 0xA540, 0xA547, 0xA54D, 0xA554, 0xA55A, 0xA561, 0xA567, 0xA56D, 0xA574, 0xA57A, 0xA581, 0xA587, 0xA58E, 0xA594, 0xA59B, 0xA5A1, 0xA5A8, 0xA5AE, 0xA5B5, 0xA5BB, 0xA5C2, 0xA5C8, 0xA5CF, 0xA5D5, 0xA5DC, 0xA5E2, 0xA5E9, 0xA5EF, 0xA5F6, 0xA5FC, 0xA603, 0xA60A, 0xA610, 0xA617, 0xA61D, 0xA624, 0xA62B, 0xA631, 0xA638, 0xA63E, 0xA645, 0xA64C, 0xA652, 0xA659, 0xA660, 0xA666, 0xA66D, 0xA674, 0xA67A, 0xA681, 0xA688, 0xA68E, 0xA695, 0xA69C, 0xA6A3, 0xA6A9, 0xA6B0, 0xA6B7, 0xA6BD, 0xA6C4, 0xA6CB, 0xA6D2, 0xA6D8, 0xA6DF, 0xA6E6, 0xA6ED, 0xA6F4, 0xA6FA, 0xA701, 0xA708, 0xA70F, 0xA716, 0xA71D, 0xA723, 0xA72A, 0xA731, 0xA738, 0xA73F, 0xA746, 0xA74D, 0xA753, 0xA75A, 0xA761, 0xA768, 0xA76F, 0xA776, 0xA77D, 0xA784, 0xA78B, 0xA792, 0xA799, 0xA7A0, 0xA7A6, 0xA7AD, 0xA7B4, 0xA7BB, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D7, 0xA7DE, 0xA7E5, 0xA7EC, 0xA7F3, 0xA7FA, 0xA802, 0xA809, 0xA810, 0xA817, 0xA81E, 0xA825, 0xA82C, 0xA833, 0xA83A, 0xA841, 0xA848, 0xA84F, 0xA856, 0xA85E, 0xA865, 0xA86C, 0xA873, 0xA87A, 0xA881, 0xA888, 0xA890, 0xA897, 0xA89E, 0xA8A5, 0xA8AC, 0xA8B4, 0xA8BB, 0xA8C2, 0xA8C9, 0xA8D0, 0xA8D8, 0xA8DF, 0xA8E6, 0xA8ED, 0xA8F5, 0xA8FC, 0xA903, 0xA90A, 0xA912, 0xA919, 0xA920, 0xA928, 0xA92F, 0xA936, 0xA93E, 0xA945, 0xA94C, 0xA954, 0xA95B, 0xA962, 0xA96A, 0xA971, 0xA978, 0xA980, 0xA987, 0xA98F, 0xA996, 0xA99D, 0xA9A5, 0xA9AC, 0xA9B4, 0xA9BB, 0xA9C2, 0xA9CA, 0xA9D1, 0xA9D9, 0xA9E0, 0xA9E8, 0xA9EF, 0xA9F7, 0xA9FE, 0xAA06, 0xAA0D, 0xAA15, 0xAA1C, 0xAA24, 0xAA2B, 0xAA33, 0xAA3A, 0xAA42, 0xAA49, 0xAA51, 0xAA59, 0xAA60, 0xAA68, 0xAA6F, 0xAA77, 0xAA7F, 0xAA86, 0xAA8E, 0xAA95, 0xAA9D, 0xAAA5, 0xAAAC, 0xAAB4, 0xAABC, 0xAAC3, 0xAACB, 0xAAD3, 0xAADA, 0xAAE2, 0xAAEA, 0xAAF1, 0xAAF9, 0xAB01, 0xAB08, 0xAB10, 0xAB18, 0xAB20, 0xAB27, 0xAB2F, 0xAB37, 0xAB3F, 0xAB46, 0xAB4E, 0xAB56, 0xAB5E, 0xAB65, 0xAB6D, 0xAB75, 0xAB7D, 0xAB85, 0xAB8D, 0xAB94, 0xAB9C, 0xABA4, 0xABAC, 0xABB4, 0xABBC, 0xABC3, 0xABCB, 0xABD3, 0xABDB, 0xABE3, 0xABEB, 0xABF3, 0xABFB, 0xAC03, 0xAC0B, 0xAC13, 0xAC1A, 0xAC22, 0xAC2A, 0xAC32, 0xAC3A, 0xAC42, 0xAC4A, 0xAC52, 0xAC5A, 0xAC62, 0xAC6A, 0xAC72, 0xAC7A, 0xAC82, 0xAC8A, 0xAC92, 0xAC9A, 0xACA2, 0xACAB, 0xACB3, 0xACBB, 0xACC3, 0xACCB, 0xACD3, 0xACDB, 0xACE3, 0xACEB, 0xACF3, 0xACFB, 0xAD04, 0xAD0C, 0xAD14, 0xAD1C, 0xAD24, 0xAD2C, 0xAD34, 0xAD3D, 0xAD45, 0xAD4D, 0xAD55, 0xAD5D, 0xAD66, 0xAD6E, 0xAD76, 0xAD7E, 0xAD86, 0xAD8F, 0xAD97, 0xAD9F, 0xADA7, 0xADB0, 0xADB8, 0xADC0, 0xADC9, 0xADD1, 0xADD9, 0xADE1, 0xADEA, 0xADF2, 0xADFA, 0xAE03, 0xAE0B, 0xAE13, 0xAE1C, 0xAE24, 0xAE2C, 0xAE35, 0xAE3D, 0xAE45, 0xAE4E, 0xAE56, 0xAE5F, 0xAE67, 0xAE6F, 0xAE78, 0xAE80, 0xAE89, 0xAE91, 0xAE9A, 0xAEA2, 0xAEAA, 0xAEB3, 0xAEBB, 0xAEC4, 0xAECC, 0xAED5, 0xAEDD, 0xAEE6, 0xAEEE, 0xAEF7, 0xAEFF, 0xAF08, 0xAF10, 0xAF19, 0xAF21, 0xAF2A, 0xAF32, 0xAF3B, 0xAF44, 0xAF4C, 0xAF55, 0xAF5D, 0xAF66, 0xAF6E, 0xAF77, 0xAF80, 0xAF88, 0xAF91, 0xAF99, 0xAFA2, 0xAFAB, 0xAFB3, 0xAFBC, 0xAFC5, 0xAFCD, 0xAFD6, 0xAFDF, 0xAFE7, 0xAFF0, 0xAFF9, 0xB001, 0xB00A, 0xB013, 0xB01B, 0xB024, 0xB02D, 0xB036, 0xB03E, 0xB047, 0xB050, 0xB059, 0xB061, 0xB06A, 0xB073, 0xB07C, 0xB084, 0xB08D, 0xB096, 0xB09F, 0xB0A8, 0xB0B0, 0xB0B9, 0xB0C2, 0xB0CB, 0xB0D4, 0xB0DD, 0xB0E5, 0xB0EE, 0xB0F7, 0xB100, 0xB109, 0xB112, 0xB11B, 0xB124, 0xB12C, 0xB135, 0xB13E, 0xB147, 0xB150, 0xB159, 0xB162, 0xB16B, 0xB174, 0xB17D, 0xB186, 0xB18F, 0xB198, 0xB1A1, 0xB1AA, 0xB1B2, 0xB1BB, 0xB1C4, 0xB1CD, 0xB1D6, 0xB1DF, 0xB1E8, 0xB1F1, 0xB1FB, 0xB204, 0xB20D, 0xB216, 0xB21F, 0xB228, 0xB231, 0xB23A, 0xB243, 0xB24C, 0xB255, 0xB25E, 0xB267, 0xB270, 0xB279, 0xB283, 0xB28C, 0xB295, 0xB29E, 0xB2A7, 0xB2B0, 0xB2B9, 0xB2C2, 0xB2CC, 0xB2D5, 0xB2DE, 0xB2E7, 0xB2F0, 0xB2F9, 0xB303, 0xB30C, 0xB315, 0xB31E, 0xB327, 0xB331, 0xB33A, 0xB343, 0xB34C, 0xB355, 0xB35F, 0xB368, 0xB371, 0xB37A, 0xB384, 0xB38D, 0xB396, 0xB3A0, 0xB3A9, 0xB3B2, 0xB3BB, 0xB3C5, 0xB3CE, 0xB3D7, 0xB3E1, 0xB3EA, 0xB3F3, 0xB3FD, 0xB406, 0xB40F, 0xB419, 0xB422, 0xB42B, 0xB435, 0xB43E, 0xB447, 0xB451, 0xB45A, 0xB463, 0xB46D, 0xB476, 0xB480, 0xB489, 0xB492, 0xB49C, 0xB4A5, 0xB4AF, 0xB4B8, 0xB4C1, 0xB4CB, 0xB4D4, 0xB4DE, 0xB4E7, 0xB4F1, 0xB4FA, 0xB504, 0xB50D, 0xB517, 0xB520, 0xB529, 0xB533, 0xB53C, 0xB546, 0xB54F, 0xB559, 0xB562, 0xB56C, 0xB575, 0xB57F, 0xB589, 0xB592, 0xB59C, 0xB5A5, 0xB5AF, 0xB5B8, 0xB5C2, 0xB5CB, 0xB5D5, 0xB5DE, 0xB5E8, 0xB5F2, 0xB5FB, 0xB605, 0xB60E, 0xB618, 0xB622, 0xB62B, 0xB635, 0xB63E, 0xB648, 0xB652, 0xB65B, 0xB665, 0xB66E, 0xB678, 0xB682, 0xB68B, 0xB695, 0xB69F, 0xB6A8, 0xB6B2, 0xB6BC, 0xB6C5, 0xB6CF, 0xB6D9, 0xB6E2, 0xB6EC, 0xB6F6, 0xB6FF, 0xB709, 0xB713, 0xB71D, 0xB726, 0xB730, 0xB73A, 0xB743, 0xB74D, 0xB757, 0xB761, 0xB76A, 0xB774, 0xB77E, 0xB788, 0xB791, 0xB79B, 0xB7A5, 0xB7AF, 0xB7B8, 0xB7C2, 0xB7CC, 0xB7D6, 0xB7E0, 0xB7E9, 0xB7F3, 0xB7FD, 0xB807, 0xB811, 0xB81A, 0xB824, 0xB82E, 0xB838, 0xB842, 0xB84B, 0xB855, 0xB85F, 0xB869, 0xB873, 0xB87D, 0xB886, 0xB890, 0xB89A, 0xB8A4, 0xB8AE, 0xB8B8, 0xB8C2, 0xB8CB, 0xB8D5, 0xB8DF, 0xB8E9, 0xB8F3, 0xB8FD, 0xB907, 0xB911, 0xB91B, 0xB924, 0xB92E, 0xB938, 0xB942, 0xB94C, 0xB956, 0xB960, 0xB96A, 0xB974, 0xB97E, 0xB988, 0xB992, 0xB99B, 0xB9A5, 0xB9AF, 0xB9B9, 0xB9C3, 0xB9CD, 0xB9D7, 0xB9E1, 0xB9EB, 0xB9F5, 0xB9FF, 0xBA09, 0xBA13, 0xBA1D, 0xBA27, 0xBA31, 0xBA3B, 0xBA45, 0xBA4F, 0xBA59, 0xBA63, 0xBA6D, 0xBA77, 0xBA81, 0xBA8B, 0xBA95, 0xBA9F, 0xBAA9, 0xBAB3, 0xBABD, 0xBAC7, 0xBAD1, 0xBADB, 0xBAE5, 0xBAEF, 0xBAF9, 0xBB03, 0xBB0D, 0xBB17, 0xBB21, 0xBB2B, 0xBB35, 0xBB3F, 0xBB49, 0xBB53, 0xBB5D, 0xBB67, 0xBB72, 0xBB7C, 0xBB86, 0xBB90, 0xBB9A, 0xBBA4, 0xBBAE, 0xBBB8, 0xBBC2, 0xBBCC, 0xBBD6, 0xBBE0, 0xBBEA, 0xBBF4, 0xBBFF, 0xBC09, 0xBC13, 0xBC1D, 0xBC27, 0xBC31, 0xBC3B, 0xBC45, 0xBC4F, 0xBC59, 0xBC64, 0xBC6E, 0xBC78, 0xBC82, 0xBC8C, 0xBC96, 0xBCA0, 0xBCAA, 0xBCB4, 0xBCBF, 0xBCC9, 0xBCD3, 0xBCDD, 0xBCE7, 0xBCF1, 0xBCFB, 0xBD05, 0xBD10, 0xBD1A, 0xBD24, 0xBD2E, 0xBD38, 0xBD42, 0xBD4C, 0xBD57, 0xBD61, 0xBD6B, 0xBD75, 0xBD7F, 0xBD89, 0xBD93, 0xBD9E, 0xBDA8, 0xBDB2, 0xBDBC, 0xBDC6, 0xBDD0, 0xBDDA, 0xBDE5, 0xBDEF, 0xBDF9, 0xBE03, 0xBE0D, 0xBE17, 0xBE22, 0xBE2C, 0xBE36, 0xBE40, 0xBE4A, 0xBE54, 0xBE5F, 0xBE69, 0xBE73, 0xBE7D, 0xBE87, 0xBE91, 0xBE9C, 0xBEA6, 0xBEB0, 0xBEBA, 0xBEC4, 0xBECF, 0xBED9, 0xBEE3, 0xBEED, 0xBEF7, 0xBF01, 0xBF0C, 0xBF16, 0xBF20, 0xBF2A, 0xBF34, 0xBF3E, 0xBF49, 0xBF53, 0xBF5D, 0xBF67, 0xBF71, 0xBF7C, 0xBF86, 0xBF90, 0xBF9A, 0xBFA4, 0xBFAF, 0xBFB9, 0xBFC3, 0xBFCD, 0xBFD7, 0xBFE1, 0xBFEC, 0xBFF6, 0xC000, 0xC00A, 0xC014, 0xC01F, 0xC029, 0xC033, 0xC03D, 0xC047, 0xC051, 0xC05C, 0xC066, 0xC070, 0xC07A, 0xC084, 0xC08F, 0xC099, 0xC0A3, 0xC0AD, 0xC0B7, 0xC0C2, 0xC0CC, 0xC0D6, 0xC0E0, 0xC0EA, 0xC0F4, 0xC0FF, 0xC109, 0xC113, 0xC11D, 0xC127, 0xC131, 0xC13C, 0xC146, 0xC150, 0xC15A, 0xC164, 0xC16F, 0xC179, 0xC183, 0xC18D, 0xC197, 0xC1A1, 0xC1AC, 0xC1B6, 0xC1C0, 0xC1CA, 0xC1D4, 0xC1DE, 0xC1E9, 0xC1F3, 0xC1FD, 0xC207, 0xC211, 0xC21B, 0xC226, 0xC230, 0xC23A, 0xC244, 0xC24E, 0xC258, 0xC262, 0xC26D, 0xC277, 0xC281, 0xC28B, 0xC295, 0xC29F, 0xC2A9, 0xC2B4, 0xC2BE, 0xC2C8, 0xC2D2, 0xC2DC, 0xC2E6, 0xC2F0, 0xC2FB, 0xC305, 0xC30F, 0xC319, 0xC323, 0xC32D, 0xC337, 0xC341, 0xC34C, 0xC356, 0xC360, 0xC36A, 0xC374, 0xC37E, 0xC388, 0xC392, 0xC39C, 0xC3A7, 0xC3B1, 0xC3BB, 0xC3C5, 0xC3CF, 0xC3D9, 0xC3E3, 0xC3ED, 0xC3F7, 0xC401, 0xC40C, 0xC416, 0xC420, 0xC42A, 0xC434, 0xC43E, 0xC448, 0xC452, 0xC45C, 0xC466, 0xC470, 0xC47A, 0xC484, 0xC48E, 0xC499, 0xC4A3, 0xC4AD, 0xC4B7, 0xC4C1, 0xC4CB, 0xC4D5, 0xC4DF, 0xC4E9, 0xC4F3, 0xC4FD, 0xC507, 0xC511, 0xC51B, 0xC525, 0xC52F, 0xC539, 0xC543, 0xC54D, 0xC557, 0xC561, 0xC56B, 0xC575, 0xC57F, 0xC589, 0xC593, 0xC59D, 0xC5A7, 0xC5B1, 0xC5BB, 0xC5C5, 0xC5CF, 0xC5D9, 0xC5E3, 0xC5ED, 0xC5F7, 0xC601, 0xC60B, 0xC615, 0xC61F, 0xC629, 0xC633, 0xC63D, 0xC647, 0xC651, 0xC65B, 0xC665, 0xC66E, 0xC678, 0xC682, 0xC68C, 0xC696, 0xC6A0, 0xC6AA, 0xC6B4, 0xC6BE, 0xC6C8, 0xC6D2, 0xC6DC, 0xC6E5, 0xC6EF, 0xC6F9, 0xC703, 0xC70D, 0xC717, 0xC721, 0xC72B, 0xC735, 0xC73E, 0xC748, 0xC752, 0xC75C, 0xC766, 0xC770, 0xC77A, 0xC783, 0xC78D, 0xC797, 0xC7A1, 0xC7AB, 0xC7B5, 0xC7BE, 0xC7C8, 0xC7D2, 0xC7DC, 0xC7E6, 0xC7EF, 0xC7F9, 0xC803, 0xC80D, 0xC817, 0xC820, 0xC82A, 0xC834, 0xC83E, 0xC848, 0xC851, 0xC85B, 0xC865, 0xC86F, 0xC878, 0xC882, 0xC88C, 0xC896, 0xC89F, 0xC8A9, 0xC8B3, 0xC8BD, 0xC8C6, 0xC8D0, 0xC8DA, 0xC8E3, 0xC8ED, 0xC8F7, 0xC901, 0xC90A, 0xC914, 0xC91E, 0xC927, 0xC931, 0xC93B, 0xC944, 0xC94E, 0xC958, 0xC961, 0xC96B, 0xC975, 0xC97E, 0xC988, 0xC992, 0xC99B, 0xC9A5, 0xC9AE, 0xC9B8, 0xC9C2, 0xC9CB, 0xC9D5, 0xC9DE, 0xC9E8, 0xC9F2, 0xC9FB, 0xCA05, 0xCA0E, 0xCA18, 0xCA22, 0xCA2B, 0xCA35, 0xCA3E, 0xCA48, 0xCA51, 0xCA5B, 0xCA64, 0xCA6E, 0xCA77, 0xCA81, 0xCA8B, 0xCA94, 0xCA9E, 0xCAA7, 0xCAB1, 0xCABA, 0xCAC4, 0xCACD, 0xCAD7, 0xCAE0, 0xCAE9, 0xCAF3, 0xCAFC, 0xCB06, 0xCB0F, 0xCB19, 0xCB22, 0xCB2C, 0xCB35, 0xCB3F, 0xCB48, 0xCB51, 0xCB5B, 0xCB64, 0xCB6E, 0xCB77, 0xCB80, 0xCB8A, 0xCB93, 0xCB9D, 0xCBA6, 0xCBAF, 0xCBB9, 0xCBC2, 0xCBCB, 0xCBD5, 0xCBDE, 0xCBE7, 0xCBF1, 0xCBFA, 0xCC03, 0xCC0D, 0xCC16, 0xCC1F, 0xCC29, 0xCC32, 0xCC3B, 0xCC45, 0xCC4E, 0xCC57, 0xCC60, 0xCC6A, 0xCC73, 0xCC7C, 0xCC86, 0xCC8F, 0xCC98, 0xCCA1, 0xCCAB, 0xCCB4, 0xCCBD, 0xCCC6, 0xCCCF, 0xCCD9, 0xCCE2, 0xCCEB, 0xCCF4, 0xCCFD, 0xCD07, 0xCD10, 0xCD19, 0xCD22, 0xCD2B, 0xCD34, 0xCD3E, 0xCD47, 0xCD50, 0xCD59, 0xCD62, 0xCD6B, 0xCD74, 0xCD7D, 0xCD87, 0xCD90, 0xCD99, 0xCDA2, 0xCDAB, 0xCDB4, 0xCDBD, 0xCDC6, 0xCDCF, 0xCDD8, 0xCDE1, 0xCDEA, 0xCDF3, 0xCDFC, 0xCE05, 0xCE0F, 0xCE18, 0xCE21, 0xCE2A, 0xCE33, 0xCE3C, 0xCE45, 0xCE4E, 0xCE56, 0xCE5F, 0xCE68, 0xCE71, 0xCE7A, 0xCE83, 0xCE8C, 0xCE95, 0xCE9E, 0xCEA7, 0xCEB0, 0xCEB9, 0xCEC2, 0xCECB, 0xCED4, 0xCEDC, 0xCEE5, 0xCEEE, 0xCEF7, 0xCF00, 0xCF09, 0xCF12, 0xCF1B, 0xCF23, 0xCF2C, 0xCF35, 0xCF3E, 0xCF47, 0xCF50, 0xCF58, 0xCF61, 0xCF6A, 0xCF73, 0xCF7C, 0xCF84, 0xCF8D, 0xCF96, 0xCF9F, 0xCFA7, 0xCFB0, 0xCFB9, 0xCFC2, 0xCFCA, 0xCFD3, 0xCFDC, 0xCFE5, 0xCFED, 0xCFF6, 0xCFFF, 0xD007, 0xD010, 0xD019, 0xD021, 0xD02A, 0xD033, 0xD03B, 0xD044, 0xD04D, 0xD055, 0xD05E, 0xD067, 0xD06F, 0xD078, 0xD080, 0xD089, 0xD092, 0xD09A, 0xD0A3, 0xD0AB, 0xD0B4, 0xD0BC, 0xD0C5, 0xD0CE, 0xD0D6, 0xD0DF, 0xD0E7, 0xD0F0, 0xD0F8, 0xD101, 0xD109, 0xD112, 0xD11A, 0xD123, 0xD12B, 0xD134, 0xD13C, 0xD145, 0xD14D, 0xD156, 0xD15E, 0xD166, 0xD16F, 0xD177, 0xD180, 0xD188, 0xD191, 0xD199, 0xD1A1, 0xD1AA, 0xD1B2, 0xD1BB, 0xD1C3, 0xD1CB, 0xD1D4, 0xD1DC, 0xD1E4, 0xD1ED, 0xD1F5, 0xD1FD, 0xD206, 0xD20E, 0xD216, 0xD21F, 0xD227, 0xD22F, 0xD237, 0xD240, 0xD248, 0xD250, 0xD259, 0xD261, 0xD269, 0xD271, 0xD27A, 0xD282, 0xD28A, 0xD292, 0xD29A, 0xD2A3, 0xD2AB, 0xD2B3, 0xD2BB, 0xD2C3, 0xD2CC, 0xD2D4, 0xD2DC, 0xD2E4, 0xD2EC, 0xD2F4, 0xD2FC, 0xD305, 0xD30D, 0xD315, 0xD31D, 0xD325, 0xD32D, 0xD335, 0xD33D, 0xD345, 0xD34D, 0xD355, 0xD35E, 0xD366, 0xD36E, 0xD376, 0xD37E, 0xD386, 0xD38E, 0xD396, 0xD39E, 0xD3A6, 0xD3AE, 0xD3B6, 0xD3BE, 0xD3C6, 0xD3CE, 0xD3D6, 0xD3DE, 0xD3E6, 0xD3ED, 0xD3F5, 0xD3FD, 0xD405, 0xD40D, 0xD415, 0xD41D, 0xD425, 0xD42D, 0xD435, 0xD43D, 0xD444, 0xD44C, 0xD454, 0xD45C, 0xD464, 0xD46C, 0xD473, 0xD47B, 0xD483, 0xD48B, 0xD493, 0xD49B, 0xD4A2, 0xD4AA, 0xD4B2, 0xD4BA, 0xD4C1, 0xD4C9, 0xD4D1, 0xD4D9, 0xD4E0, 0xD4E8, 0xD4F0, 0xD4F8, 0xD4FF, 0xD507, 0xD50F, 0xD516, 0xD51E, 0xD526, 0xD52D, 0xD535, 0xD53D, 0xD544, 0xD54C, 0xD554, 0xD55B, 0xD563, 0xD56B, 0xD572, 0xD57A, 0xD581, 0xD589, 0xD591, 0xD598, 0xD5A0, 0xD5A7, 0xD5AF, 0xD5B7, 0xD5BE, 0xD5C6, 0xD5CD, 0xD5D5, 0xD5DC, 0xD5E4, 0xD5EB, 0xD5F3, 0xD5FA, 0xD602, 0xD609, 0xD611, 0xD618, 0xD620, 0xD627, 0xD62F, 0xD636, 0xD63E, 0xD645, 0xD64C, 0xD654, 0xD65B, 0xD663, 0xD66A, 0xD671, 0xD679, 0xD680, 0xD688, 0xD68F, 0xD696, 0xD69E, 0xD6A5, 0xD6AC, 0xD6B4, 0xD6BB, 0xD6C2, 0xD6CA, 0xD6D1, 0xD6D8, 0xD6E0, 0xD6E7, 0xD6EE, 0xD6F6, 0xD6FD, 0xD704, 0xD70B, 0xD713, 0xD71A, 0xD721, 0xD728, 0xD730, 0xD737, 0xD73E, 0xD745, 0xD74C, 0xD754, 0xD75B, 0xD762, 0xD769, 0xD770, 0xD778, 0xD77F, 0xD786, 0xD78D, 0xD794, 0xD79B, 0xD7A2, 0xD7AA, 0xD7B1, 0xD7B8, 0xD7BF, 0xD7C6, 0xD7CD, 0xD7D4, 0xD7DB, 0xD7E2, 0xD7E9, 0xD7F0, 0xD7F7, 0xD7FE, 0xD806, 0xD80D, 0xD814, 0xD81B, 0xD822, 0xD829, 0xD830, 0xD837, 0xD83E, 0xD845, 0xD84C, 0xD853, 0xD85A, 0xD860, 0xD867, 0xD86E, 0xD875, 0xD87C, 0xD883, 0xD88A, 0xD891, 0xD898, 0xD89F, 0xD8A6, 0xD8AD, 0xD8B3, 0xD8BA, 0xD8C1, 0xD8C8, 0xD8CF, 0xD8D6, 0xD8DD, 0xD8E3, 0xD8EA, 0xD8F1, 0xD8F8, 0xD8FF, 0xD906, 0xD90C, 0xD913, 0xD91A, 0xD921, 0xD928, 0xD92E, 0xD935, 0xD93C, 0xD943, 0xD949, 0xD950, 0xD957, 0xD95D, 0xD964, 0xD96B, 0xD972, 0xD978, 0xD97F, 0xD986, 0xD98C, 0xD993, 0xD99A, 0xD9A0, 0xD9A7, 0xD9AE, 0xD9B4, 0xD9BB, 0xD9C2, 0xD9C8, 0xD9CF, 0xD9D5, 0xD9DC, 0xD9E3, 0xD9E9, 0xD9F0, 0xD9F6, 0xD9FD, 0xDA04, 0xDA0A, 0xDA11, 0xDA17, 0xDA1E, 0xDA24, 0xDA2B, 0xDA31, 0xDA38, 0xDA3E, 0xDA45, 0xDA4B, 0xDA52, 0xDA58, 0xDA5F, 0xDA65, 0xDA6C, 0xDA72, 0xDA79, 0xDA7F, 0xDA86, 0xDA8C, 0xDA93, 0xDA99, 0xDA9F, 0xDAA6, 0xDAAC, 0xDAB3, 0xDAB9, 0xDAC0, 0xDAC6, 0xDACC, 0xDAD3, 0xDAD9, 0xDADF, 0xDAE6, 0xDAEC, 0xDAF2, 0xDAF9, 0xDAFF, 0xDB05, 0xDB0C, 0xDB12, 0xDB18, 0xDB1F, 0xDB25, 0xDB2B, 0xDB32, 0xDB38, 0xDB3E, 0xDB44, 0xDB4B, 0xDB51, 0xDB57, 0xDB5D, 0xDB64, 0xDB6A, 0xDB70, 0xDB76, 0xDB7D, 0xDB83, 0xDB89, 0xDB8F, 0xDB95, 0xDB9C, 0xDBA2, 0xDBA8, 0xDBAE, 0xDBB4, 0xDBBA, 0xDBC1, 0xDBC7, 0xDBCD, 0xDBD3, 0xDBD9, 0xDBDF, 0xDBE5, 0xDBEB, 0xDBF2, 0xDBF8, 0xDBFE, 0xDC04, 0xDC0A, 0xDC10, 0xDC16, 0xDC1C, 0xDC22, 0xDC28, 0xDC2E, 0xDC34, 0xDC3A, 0xDC40, 0xDC46, 0xDC4C, 0xDC52, 0xDC58, 0xDC5E, 0xDC64, 0xDC6A, 0xDC70, 0xDC76, 0xDC7C, 0xDC82, 0xDC88, 0xDC8E, 0xDC94, 0xDC9A, 0xDCA0, 0xDCA6, 0xDCAC, 0xDCB2, 0xDCB8, 0xDCBE, 0xDCC3, 0xDCC9, 0xDCCF, 0xDCD5, 0xDCDB, 0xDCE1, 0xDCE7, 0xDCED, 0xDCF3, 0xDCF8, 0xDCFE, 0xDD04, 0xDD0A, 0xDD10, 0xDD16, 0xDD1B, 0xDD21, 0xDD27, 0xDD2D, 0xDD33, 0xDD38, 0xDD3E, 0xDD44, 0xDD4A, 0xDD4F, 0xDD55, 0xDD5B, 0xDD61, 0xDD66, 0xDD6C, 0xDD72, 0xDD78, 0xDD7D, 0xDD83, 0xDD89, 0xDD8E, 0xDD94, 0xDD9A, 0xDDA0, 0xDDA5, 0xDDAB, 0xDDB1, 0xDDB6, 0xDDBC, 0xDDC2, 0xDDC7, 0xDDCD, 0xDDD3, 0xDDD8, 0xDDDE, 0xDDE3, 0xDDE9, 0xDDEF, 0xDDF4, 0xDDFA, 0xDDFF, 0xDE05, 0xDE0B, 0xDE10, 0xDE16, 0xDE1B, 0xDE21, 0xDE26, 0xDE2C, 0xDE32, 0xDE37, 0xDE3D, 0xDE42, 0xDE48, 0xDE4D, 0xDE53, 0xDE58, 0xDE5E, 0xDE63, 0xDE69, 0xDE6E, 0xDE74, 0xDE79, 0xDE7F, 0xDE84, 0xDE8A, 0xDE8F, 0xDE94, 0xDE9A, 0xDE9F, 0xDEA5, 0xDEAA, 0xDEB0, 0xDEB5, 0xDEBA, 0xDEC0, 0xDEC5, 0xDECB, 0xDED0, 0xDED5, 0xDEDB, 0xDEE0, 0xDEE6, 0xDEEB, 0xDEF0, 0xDEF6, 0xDEFB, 0xDF00, 0xDF06, 0xDF0B, 0xDF10, 0xDF16, 0xDF1B, 0xDF20, 0xDF26, 0xDF2B, 0xDF30, 0xDF36, 0xDF3B, 0xDF40, 0xDF45, 0xDF4B, 0xDF50, 0xDF55, 0xDF5A, 0xDF60, 0xDF65, 0xDF6A, 0xDF6F, 0xDF75, 0xDF7A, 0xDF7F, 0xDF84, 0xDF8A, 0xDF8F, 0xDF94, 0xDF99, 0xDF9E, 0xDFA4, 0xDFA9, 0xDFAE, 0xDFB3, 0xDFB8, 0xDFBD, 0xDFC3, 0xDFC8, 0xDFCD, 0xDFD2, 0xDFD7, 0xDFDC, 0xDFE1, 0xDFE6, 0xDFEC, 0xDFF1, 0xDFF6, 0xDFFB, -0x2000, -0x1FFB, -0x1FF6, -0x1FF1, -0x1FEC, -0x1FE6, -0x1FE1, -0x1FDC, -0x1FD7, -0x1FD2, -0x1FCD, -0x1FC8, -0x1FC3, -0x1FBD, -0x1FB8, -0x1FB3, -0x1FAE, -0x1FA9, -0x1FA4, -0x1F9E, -0x1F99, -0x1F94, -0x1F8F, -0x1F8A, -0x1F84, -0x1F7F, -0x1F7A, -0x1F75, -0x1F6F, -0x1F6A, -0x1F65, -0x1F60, -0x1F5A, -0x1F55, -0x1F50, -0x1F4B, -0x1F45, -0x1F40, -0x1F3B, -0x1F36, -0x1F30, -0x1F2B, -0x1F26, -0x1F20, -0x1F1B, -0x1F16, -0x1F10, -0x1F0B, -0x1F06, -0x1F00, -0x1EFB, -0x1EF6, -0x1EF0, -0x1EEB, -0x1EE6, -0x1EE0, -0x1EDB, -0x1ED5, -0x1ED0, -0x1ECB, -0x1EC5, -0x1EC0, -0x1EBA, -0x1EB5, -0x1EB0, -0x1EAA, -0x1EA5, -0x1E9F, -0x1E9A, -0x1E94, -0x1E8F, -0x1E8A, -0x1E84, -0x1E7F, -0x1E79, -0x1E74, -0x1E6E, -0x1E69, -0x1E63, -0x1E5E, -0x1E58, -0x1E53, -0x1E4D, -0x1E48, -0x1E42, -0x1E3D, -0x1E37, -0x1E32, -0x1E2C, -0x1E26, -0x1E21, -0x1E1B, -0x1E16, -0x1E10, -0x1E0B, -0x1E05, -0x1DFF, -0x1DFA, -0x1DF4, -0x1DEF, -0x1DE9, -0x1DE3, -0x1DDE, -0x1DD8, -0x1DD3, -0x1DCD, -0x1DC7, -0x1DC2, -0x1DBC, -0x1DB6, -0x1DB1, -0x1DAB, -0x1DA5, -0x1DA0, -0x1D9A, -0x1D94, -0x1D8E, -0x1D89, -0x1D83, -0x1D7D, -0x1D78, -0x1D72, -0x1D6C, -0x1D66, -0x1D61, -0x1D5B, -0x1D55, -0x1D4F, -0x1D4A, -0x1D44, -0x1D3E, -0x1D38, -0x1D33, -0x1D2D, -0x1D27, -0x1D21, -0x1D1B, -0x1D16, -0x1D10, -0x1D0A, -0x1D04, -0x1CFE, -0x1CF8, -0x1CF3, -0x1CED, -0x1CE7, -0x1CE1, -0x1CDB, -0x1CD5, -0x1CCF, -0x1CC9, -0x1CC3, -0x1CBE, -0x1CB8, -0x1CB2, -0x1CAC, -0x1CA6, -0x1CA0, -0x1C9A, -0x1C94, -0x1C8E, -0x1C88, -0x1C82, -0x1C7C, -0x1C76, -0x1C70, -0x1C6A, -0x1C64, -0x1C5E, -0x1C58, -0x1C52, -0x1C4C, -0x1C46, -0x1C40, -0x1C3A, -0x1C34, -0x1C2E, -0x1C28, -0x1C22, -0x1C1C, -0x1C16, -0x1C10, -0x1C0A, -0x1C04, -0x1BFE, -0x1BF8, -0x1BF2, -0x1BEB, -0x1BE5, -0x1BDF, -0x1BD9, -0x1BD3, -0x1BCD, -0x1BC7, -0x1BC1, -0x1BBA, -0x1BB4, -0x1BAE, -0x1BA8, -0x1BA2, -0x1B9C, -0x1B95, -0x1B8F, -0x1B89, -0x1B83, -0x1B7D, -0x1B76, -0x1B70, -0x1B6A, -0x1B64, -0x1B5D, -0x1B57, -0x1B51, -0x1B4B, -0x1B44, -0x1B3E, -0x1B38, -0x1B32, -0x1B2B, -0x1B25, -0x1B1F, -0x1B18, -0x1B12, -0x1B0C, -0x1B05, -0x1AFF, -0x1AF9, -0x1AF2, -0x1AEC, -0x1AE6, -0x1ADF, -0x1AD9, -0x1AD3, -0x1ACC, -0x1AC6, -0x1AC0, -0x1AB9, -0x1AB3, -0x1AAC, -0x1AA6, -0x1A9F, -0x1A99, -0x1A93, -0x1A8C, -0x1A86, -0x1A7F, -0x1A79, -0x1A72, -0x1A6C, -0x1A65, -0x1A5F, -0x1A58, -0x1A52, -0x1A4B, -0x1A45, -0x1A3E, -0x1A38, -0x1A31, -0x1A2B, -0x1A24, -0x1A1E, -0x1A17, -0x1A11, -0x1A0A, -0x1A04, -0x19FD, -0x19F6, -0x19F0, -0x19E9, -0x19E3, -0x19DC, -0x19D5, -0x19CF, -0x19C8, -0x19C2, -0x19BB, -0x19B4, -0x19AE, -0x19A7, -0x19A0, -0x199A, -0x1993, -0x198C, -0x1986, -0x197F, -0x1978, -0x1972, -0x196B, -0x1964, -0x195D, -0x1957, -0x1950, -0x1949, -0x1943, -0x193C, -0x1935, -0x192E, -0x1928, -0x1921, -0x191A, -0x1913, -0x190C, -0x1906, -0x18FF, -0x18F8, -0x18F1, -0x18EA, -0x18E3, -0x18DD, -0x18D6, -0x18CF, -0x18C8, -0x18C1, -0x18BA, -0x18B3, -0x18AD, -0x18A6, -0x189F, -0x1898, -0x1891, -0x188A, -0x1883, -0x187C, -0x1875, -0x186E, -0x1867, -0x1860, -0x185A, -0x1853, -0x184C, -0x1845, -0x183E, -0x1837, -0x1830, -0x1829, -0x1822, -0x181B, -0x1814, -0x180D, -0x1806, -0x17FE, -0x17F7, -0x17F0, -0x17E9, -0x17E2, -0x17DB, -0x17D4, -0x17CD, -0x17C6, -0x17BF, -0x17B8, -0x17B1, -0x17AA, -0x17A2, -0x179B, -0x1794, -0x178D, -0x1786, -0x177F, -0x1778, -0x1770, -0x1769, -0x1762, -0x175B, -0x1754, -0x174C, -0x1745, -0x173E, -0x1737, -0x1730, -0x1728, -0x1721, -0x171A, -0x1713, -0x170B, -0x1704, -0x16FD, -0x16F6, -0x16EE, -0x16E7, -0x16E0, -0x16D8, -0x16D1, -0x16CA, -0x16C2, -0x16BB, -0x16B4, -0x16AC, -0x16A5, -0x169E, -0x1696, -0x168F, -0x1688, -0x1680, -0x1679, -0x1671, -0x166A, -0x1663, -0x165B, -0x1654, -0x164C, -0x1645, -0x163E, -0x1636, -0x162F, -0x1627, -0x1620, -0x1618, -0x1611, -0x1609, -0x1602, -0x15FA, -0x15F3, -0x15EB, -0x15E4, -0x15DC, -0x15D5, -0x15CD, -0x15C6, -0x15BE, -0x15B7, -0x15AF, -0x15A7, -0x15A0, -0x1598, -0x1591, -0x1589, -0x1581, -0x157A, -0x1572, -0x156B, -0x1563, -0x155B, -0x1554, -0x154C, -0x1544, -0x153D, -0x1535, -0x152D, -0x1526, -0x151E, -0x1516, -0x150F, -0x1507, -0x14FF, -0x14F8, -0x14F0, -0x14E8, -0x14E0, -0x14D9, -0x14D1, -0x14C9, -0x14C1, -0x14BA, -0x14B2, -0x14AA, -0x14A2, -0x149B, -0x1493, -0x148B, -0x1483, -0x147B, -0x1473, -0x146C, -0x1464, -0x145C, -0x1454, -0x144C, -0x1444, -0x143D, -0x1435, -0x142D, -0x1425, -0x141D, -0x1415, -0x140D, -0x1405, -0x13FD, -0x13F5, -0x13ED, -0x13E6, -0x13DE, -0x13D6, -0x13CE, -0x13C6, -0x13BE, -0x13B6, -0x13AE, -0x13A6, -0x139E, -0x1396, -0x138E, -0x1386, -0x137E, -0x1376, -0x136E, -0x1366, -0x135E, -0x1355, -0x134D, -0x1345, -0x133D, -0x1335, -0x132D, -0x1325, -0x131D, -0x1315, -0x130D, -0x1305, -0x12FC, -0x12F4, -0x12EC, -0x12E4, -0x12DC, -0x12D4, -0x12CC, -0x12C3, -0x12BB, -0x12B3, -0x12AB, -0x12A3, -0x129A, -0x1292, -0x128A, -0x1282, -0x127A, -0x1271, -0x1269, -0x1261, -0x1259, -0x1250, -0x1248, -0x1240, -0x1237, -0x122F, -0x1227, -0x121F, -0x1216, -0x120E, -0x1206, -0x11FD, -0x11F5, -0x11ED, -0x11E4, -0x11DC, -0x11D4, -0x11CB, -0x11C3, -0x11BB, -0x11B2, -0x11AA, -0x11A1, -0x1199, -0x1191, -0x1188, -0x1180, -0x1177, -0x116F, -0x1166, -0x115E, -0x1156, -0x114D, -0x1145, -0x113C, -0x1134, -0x112B, -0x1123, -0x111A, -0x1112, -0x1109, -0x1101, -0x10F8, -0x10F0, -0x10E7, -0x10DF, -0x10D6, -0x10CE, -0x10C5, -0x10BC, -0x10B4, -0x10AB, -0x10A3, -0x109A, -0x1092, -0x1089, -0x1080, -0x1078, -0x106F, -0x1067, -0x105E, -0x1055, -0x104D, -0x1044, -0x103B, -0x1033, -0x102A, -0x1021, -0x1019, -0x1010, -0x1007, -0x0FFF, -0x0FF6, -0x0FED, -0x0FE5, -0x0FDC, -0x0FD3, -0x0FCA, -0x0FC2, -0x0FB9, -0x0FB0, -0x0FA7, -0x0F9F, -0x0F96, -0x0F8D, -0x0F84, -0x0F7C, -0x0F73, -0x0F6A, -0x0F61, -0x0F58, -0x0F50, -0x0F47, -0x0F3E, -0x0F35, -0x0F2C, -0x0F23, -0x0F1B, -0x0F12, -0x0F09, -0x0F00, -0x0EF7, -0x0EEE, -0x0EE5, -0x0EDC, -0x0ED4, -0x0ECB, -0x0EC2, -0x0EB9, -0x0EB0, -0x0EA7, -0x0E9E, -0x0E95, -0x0E8C, -0x0E83, -0x0E7A, -0x0E71, -0x0E68, -0x0E5F, -0x0E56, -0x0E4E, -0x0E45, -0x0E3C, -0x0E33, -0x0E2A, -0x0E21, -0x0E18, -0x0E0F, -0x0E05, -0x0DFC, -0x0DF3, -0x0DEA, -0x0DE1, -0x0DD8, -0x0DCF, -0x0DC6, -0x0DBD, -0x0DB4, -0x0DAB, -0x0DA2, -0x0D99, -0x0D90, -0x0D87, -0x0D7D, -0x0D74, -0x0D6B, -0x0D62, -0x0D59, -0x0D50, -0x0D47, -0x0D3E, -0x0D34, -0x0D2B, -0x0D22, -0x0D19, -0x0D10, -0x0D07, -0x0CFD, -0x0CF4, -0x0CEB, -0x0CE2, -0x0CD9, -0x0CCF, -0x0CC6, -0x0CBD, -0x0CB4, -0x0CAB, -0x0CA1, -0x0C98, -0x0C8F, -0x0C86, -0x0C7C, -0x0C73, -0x0C6A, -0x0C60, -0x0C57, -0x0C4E, -0x0C45, -0x0C3B, -0x0C32, -0x0C29, -0x0C1F, -0x0C16, -0x0C0D, -0x0C03, -0x0BFA, -0x0BF1, -0x0BE7, -0x0BDE, -0x0BD5, -0x0BCB, -0x0BC2, -0x0BB9, -0x0BAF, -0x0BA6, -0x0B9D, -0x0B93, -0x0B8A, -0x0B80, -0x0B77, -0x0B6E, -0x0B64, -0x0B5B, -0x0B51, -0x0B48, -0x0B3F, -0x0B35, -0x0B2C, -0x0B22, -0x0B19, -0x0B0F, -0x0B06, -0x0AFC, -0x0AF3, -0x0AE9, -0x0AE0, -0x0AD7, -0x0ACD, -0x0AC4, -0x0ABA, -0x0AB1, -0x0AA7, -0x0A9E, -0x0A94, -0x0A8B, -0x0A81, -0x0A77, -0x0A6E, -0x0A64, -0x0A5B, -0x0A51, -0x0A48, -0x0A3E, -0x0A35, -0x0A2B, -0x0A22, -0x0A18, -0x0A0E, -0x0A05, -0x09FB, -0x09F2, -0x09E8, -0x09DE, -0x09D5, -0x09CB, -0x09C2, -0x09B8, -0x09AE, -0x09A5, -0x099B, -0x0992, -0x0988, -0x097E, -0x0975, -0x096B, -0x0961, -0x0958, -0x094E, -0x0944, -0x093B, -0x0931, -0x0927, -0x091E, -0x0914, -0x090A, -0x0901, -0x08F7, -0x08ED, -0x08E3, -0x08DA, -0x08D0, -0x08C6, -0x08BD, -0x08B3, -0x08A9, -0x089F, -0x0896, -0x088C, -0x0882, -0x0878, -0x086F, -0x0865, -0x085B, -0x0851, -0x0848, -0x083E, -0x0834, -0x082A, -0x0820, -0x0817, -0x080D, -0x0803, -0x07F9, -0x07EF, -0x07E6, -0x07DC, -0x07D2, -0x07C8, -0x07BE, -0x07B5, -0x07AB, -0x07A1, -0x0797, -0x078D, -0x0783, -0x077A, -0x0770, -0x0766, -0x075C, -0x0752, -0x0748, -0x073E, -0x0735, -0x072B, -0x0721, -0x0717, -0x070D, -0x0703, -0x06F9, -0x06EF, -0x06E5, -0x06DC, -0x06D2, -0x06C8, -0x06BE, -0x06B4, -0x06AA, -0x06A0, -0x0696, -0x068C, -0x0682, -0x0678, -0x066E, -0x0665, -0x065B, -0x0651, -0x0647, -0x063D, -0x0633, -0x0629, -0x061F, -0x0615, -0x060B, -0x0601, -0x05F7, -0x05ED, -0x05E3, -0x05D9, -0x05CF, -0x05C5, -0x05BB, -0x05B1, -0x05A7, -0x059D, -0x0593, -0x0589, -0x057F, -0x0575, -0x056B, -0x0561, -0x0557, -0x054D, -0x0543, -0x0539, -0x052F, -0x0525, -0x051B, -0x0511, -0x0507, -0x04FD, -0x04F3, -0x04E9, -0x04DF, -0x04D5, -0x04CB, -0x04C1, -0x04B7, -0x04AD, -0x04A3, -0x0499, -0x048E, -0x0484, -0x047A, -0x0470, -0x0466, -0x045C, -0x0452, -0x0448, -0x043E, -0x0434, -0x042A, -0x0420, -0x0416, -0x040C, -0x0401, -0x03F7, -0x03ED, -0x03E3, -0x03D9, -0x03CF, -0x03C5, -0x03BB, -0x03B1, -0x03A7, -0x039C, -0x0392, -0x0388, -0x037E, -0x0374, -0x036A, -0x0360, -0x0356, -0x034C, -0x0341, -0x0337, -0x032D, -0x0323, -0x0319, -0x030F, -0x0305, -0x02FB, -0x02F0, -0x02E6, -0x02DC, -0x02D2, -0x02C8, -0x02BE, -0x02B4, -0x02A9, -0x029F, -0x0295, -0x028B, -0x0281, -0x0277, -0x026D, -0x0262, -0x0258, -0x024E, -0x0244, -0x023A, -0x0230, -0x0226, -0x021B, -0x0211, -0x0207, -0x01FD, -0x01F3, -0x01E9, -0x01DE, -0x01D4, -0x01CA, -0x01C0, -0x01B6, -0x01AC, -0x01A1, -0x0197, -0x018D, -0x0183, -0x0179, -0x016F, -0x0164, -0x015A, -0x0150, -0x0146, -0x013C, -0x0131, -0x0127, -0x011D, -0x0113, -0x0109, -0x00FF, -0x00F4, -0x00EA, -0x00E0, -0x00D6, -0x00CC, -0x00C2, -0x00B7, -0x00AD, -0x00A3, -0x0099, -0x008F, -0x0084, -0x007A, -0x0070, -0x0066, -0x005C, -0x0051, -0x0047, -0x003D, -0x0033, -0x0029, -0x001F, -0x0014, -0x000A };

int gReverseArctanTable[65537];
__device__ int gReverseArctanTableG[65537];

struct Point {
    struct Point* next;
    struct Point* prev;
    float x;
    float z;
};

struct Polygon {
    struct Point* p;
    int nPoints;
};

struct StickData {
    int x;
    int y;
    float mag;
    int intendedYaw;
};

struct StickNode {
    struct StickNode* next;
    struct StickData data;
};

struct StrainNode {
    float strainSpeed;
    float addedSpeed;
    struct StickData data;
};

struct SquishCancelSetup {
    struct Polygon* bullyZone;
    struct Polygon* marioZone;
    struct Polygon* bullyPushZone;
    int pushAngle;
    int squishQSteps;
};

struct MiniSquishCancelSetup {
    float minBullyX;
    float maxBullyX;
    float minBullyZ;
    float maxBullyZ;
    int pushAngle;
    int squishQSteps;
};

struct SlideSetup {
    float forwardVel;
    float xVel;
    float zVel;
};

struct StrainSetup {
    int slideSetupIdx;
    int strainStickX;
    int strainStickY;
    int cameraYaw;
    float preStrainSpeed;
    float postStrainSpeed;
};

struct CollisionSetup {
    int strainSetupIdx;
    int bullyZoneIdx;
    int bullyAngle;
    float bullySpeed;
    int framesStable;
    float minBullyX;
    float maxBullyX;
    float minBullyZ;
    float maxBullyZ;
};

__device__ SlideSetup* slidingSetups;
__device__ int nSlidingSetups;

__device__ StrainSetup* strainSetups;
__device__ int nStrainSetups;

__device__ CollisionSetup* collisionSetups;
__device__ int nCollisionSetups;

__device__ StrainNode** strainLookup;
__device__ int* nStrainNodes;

__device__ float lakituPositionG[3];
__device__ bool* validCameraAngleG;

class SurfaceG {
public:
    short vertices[3][3];
    float normal[3];
    float origin_offset;
    float lower_y;
    float upper_y;

    float min_x;
    float max_x;
    float min_z;
    float max_z;

    bool is_lava;

    __device__ SurfaceG(short x0, short y0, short z0, short x1, short y1, short z1, short x2, short y2, short z2, bool lava) {
        short verts[3][3] = { {x0, y0, z0}, {x1, y1, z1}, {x2, y2, z2} };
        set_vertices(verts);
        is_lava = lava;
    }

    __device__ SurfaceG(short x0, short y0, short z0, short x1, short y1, short z1, short x2, short y2, short z2) {
        short verts[3][3] = { {x0, y0, z0}, {x1, y1, z1}, {x2, y2, z2} };
        set_vertices(verts);
        is_lava = false;
    }

    __device__ SurfaceG(short verts[3][3]) {
        set_vertices(verts);
    }

    __device__ SurfaceG() {}

    __device__ void set_vertices(short verts[3][3]) {
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                vertices[i][j] = verts[i][j];
            }
        }

        lower_y = fminf(fminf(vertices[0][1], vertices[1][1]), vertices[2][1]) - 5;
        upper_y = fmaxf(fmaxf(vertices[0][1], vertices[1][1]), vertices[2][1]) + 5;

        min_x = fminf(fminf(vertices[0][0], vertices[1][0]), vertices[2][0]);
        max_x = fmaxf(fmaxf(vertices[0][0], vertices[1][0]), vertices[2][0]);
        min_z = fminf(fminf(vertices[0][2], vertices[1][2]), vertices[2][2]);
        max_z = fmaxf(fmaxf(vertices[0][2], vertices[1][2]), vertices[2][2]);

        calculate_normal();
    }

    __device__ void calculate_normal() {
        normal[0] = (vertices[1][1] - vertices[0][1]) * (vertices[2][2] - vertices[1][2]) - (vertices[1][2] - vertices[0][2]) * (vertices[2][1] - vertices[1][1]);
        normal[1] = (vertices[1][2] - vertices[0][2]) * (vertices[2][0] - vertices[1][0]) - (vertices[1][0] - vertices[0][0]) * (vertices[2][2] - vertices[1][2]);
        normal[2] = (vertices[1][0] - vertices[0][0]) * (vertices[2][1] - vertices[1][1]) - (vertices[1][1] - vertices[0][1]) * (vertices[2][0] - vertices[1][0]);

        float mag = sqrtf(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);

        mag = (float)(1.0 / mag);
        normal[0] *= mag;
        normal[1] *= mag;
        normal[2] *= mag;

        origin_offset = -(normal[0] * vertices[0][0] + normal[1] * vertices[0][1] + normal[2] * vertices[0][2]);
    }
};

__device__ const int total_floorsG = 350;
__device__ SurfaceG floorsG[total_floorsG];

__global__ void initialise_floors() {
    floorsG[0] = SurfaceG(1536, 5478, -262, 922, 5478, -262, 922, 5478, 403);
    floorsG[1] = SurfaceG(1536, 5478, -262, 922, 5478, 403, 1536, 5478, 403);
    floorsG[2] = SurfaceG(2150, 5248, -262, 1536, 5248, -210, 2150, 5248, -210);
    floorsG[3] = SurfaceG(2150, 5248, -262, 1536, 5248, -262, 1536, 5248, -210);
    floorsG[4] = SurfaceG(2765, 5248, -262, 2150, 5248, 403, 2765, 5248, 403);
    floorsG[5] = SurfaceG(2765, 5248, -262, 2150, 5248, -262, 2150, 5248, 403);
    floorsG[6] = SurfaceG(3994, 5018, -262, 2765, 5018, -262, 2765, 5018, -210);
    floorsG[7] = SurfaceG(3994, 5018, -262, 2765, 5018, -210, 3994, 5018, -210);
    floorsG[8] = SurfaceG(7384, 4506, 371, 7513, 4403, -236, 7384, 4506, -181);
    floorsG[9] = SurfaceG(7384, 4506, 371, 7513, 4403, 426, 7513, 4403, -236);
    floorsG[10] = SurfaceG(7384, 4506, -181, 7513, 4403, -236, 7071, 4403, -678);
    floorsG[11] = SurfaceG(7384, 4506, -181, 7071, 4403, -678, 7015, 4506, -549);
    floorsG[12] = SurfaceG(7015, 4506, -549, 7071, 4403, -678, 6407, 4403, -678);
    floorsG[13] = SurfaceG(7015, 4506, -549, 6407, 4403, -678, 6462, 4506, -549);
    floorsG[14] = SurfaceG(6462, 4506, -549, 6407, 4403, -678, 5965, 4403, -236);
    floorsG[15] = SurfaceG(6462, 4506, -549, 5965, 4403, -236, 6094, 4506, -181);
    floorsG[16] = SurfaceG(7384, 4506, -181, 6912, 4019, 170, 7384, 4506, 371);
    floorsG[17] = SurfaceG(7015, 4506, -549, 6912, 4019, 20, 7384, 4506, -181);
    floorsG[18] = SurfaceG(7015, 4506, -549, 6462, 4506, -549, 6661, 4019, -79);
    floorsG[19] = SurfaceG(7384, 4506, -181, 6912, 4019, 20, 6912, 4019, 170);
    floorsG[20] = SurfaceG(6462, 4506, 740, 6561, 4019, 170, 6094, 4506, 371);
    floorsG[21] = SurfaceG(6462, 4506, 740, 6661, 4019, 271, 6561, 4019, 170);
    floorsG[22] = SurfaceG(6094, 4506, 371, 6561, 4019, 170, 6561, 4019, 20);
    floorsG[23] = SurfaceG(6094, 4506, 371, 6561, 4019, 20, 6094, 4506, -181);
    floorsG[24] = SurfaceG(7015, 4506, -549, 6811, 4019, -79, 6912, 4019, 20);
    floorsG[25] = SurfaceG(7015, 4506, -549, 6661, 4019, -79, 6811, 4019, -79);
    floorsG[26] = SurfaceG(6094, 4506, -181, 5965, 4403, -236, 5965, 4403, 426);
    floorsG[27] = SurfaceG(6094, 4506, -181, 5965, 4403, 426, 6094, 4506, 371);
    floorsG[28] = SurfaceG(7071, 4403, 869, 7015, 4506, 740, 6462, 4506, 740);
    floorsG[29] = SurfaceG(7071, 4403, 869, 6462, 4506, 740, 6407, 4403, 869);
    floorsG[30] = SurfaceG(7071, 4403, 869, 7513, 4403, 426, 7384, 4506, 371);
    floorsG[31] = SurfaceG(7071, 4403, 869, 7384, 4506, 371, 7015, 4506, 740);
    floorsG[32] = SurfaceG(5965, 4403, 426, 6407, 4403, 869, 6462, 4506, 740);
    floorsG[33] = SurfaceG(5965, 4403, 426, 6462, 4506, 740, 6094, 4506, 371);
    floorsG[34] = SurfaceG(3994, 4403, -210, 3379, 4403, -210, 3379, 4403, 403);
    floorsG[35] = SurfaceG(4403, 4403, -210, 3994, 4403, -210, 3994, 4403, 403);
    floorsG[36] = SurfaceG(4403, 4403, -210, 3994, 4403, 403, 4403, 4403, 403);
    floorsG[37] = SurfaceG(3994, 4403, -210, 3379, 4403, 403, 3994, 4403, 403);
    floorsG[38] = SurfaceG(1536, 4403, -210, 922, 4403, -210, 922, 4403, 403);
    floorsG[39] = SurfaceG(1536, 4403, -210, 922, 4403, 403, 1536, 4403, 403);
    floorsG[40] = SurfaceG(5555, 4403, 403, 5965, 4403, -210, 5555, 4403, -210);
    floorsG[41] = SurfaceG(1536, 4403, 403, 2150, 4403, 403, 1946, 4403, 198);
    floorsG[42] = SurfaceG(1536, 4403, 403, 1946, 4403, 198, 1741, 4403, 198);
    floorsG[43] = SurfaceG(1536, 4403, 403, 1741, 4403, -6, 1536, 4403, -210);
    floorsG[44] = SurfaceG(1536, 4403, 403, 1741, 4403, 198, 1741, 4403, -6);
    floorsG[45] = SurfaceG(1536, 4403, -210, 1741, 4403, -6, 1946, 4403, -6);
    floorsG[46] = SurfaceG(1536, 4403, -210, 1946, 4403, -6, 2150, 4403, -210);
    floorsG[47] = SurfaceG(2150, 4403, -210, 1946, 4403, 198, 2150, 4403, 403);
    floorsG[48] = SurfaceG(2150, 4403, -210, 1946, 4403, -6, 1946, 4403, 198);
    floorsG[49] = SurfaceG(5555, 4403, 403, 5965, 4403, 403, 5965, 4403, -210);
    floorsG[50] = SurfaceG(5965, 4255, 426, 5965, 4403, 403, 5555, 4403, 403);
    floorsG[51] = SurfaceG(6811, 4019, 271, 7015, 4506, 740, 7384, 4506, 371);
    floorsG[52] = SurfaceG(6661, 4019, 271, 6462, 4506, 740, 7015, 4506, 740);
    floorsG[53] = SurfaceG(6661, 4019, 271, 7015, 4506, 740, 6811, 4019, 271);
    floorsG[54] = SurfaceG(6811, 4019, 271, 7384, 4506, 371, 6912, 4019, 170);
    floorsG[55] = SurfaceG(6561, 4019, 20, 6661, 4019, -79, 6462, 4506, -549);
    floorsG[56] = SurfaceG(6561, 4019, 20, 6462, 4506, -549, 6094, 4506, -181);
    floorsG[57] = SurfaceG(-4965, 3789, 404, -5017, 3789, 404, -5017, 3789, 761);
    floorsG[58] = SurfaceG(-4965, 3789, 404, -5017, 3789, 761, -4965, 3789, 813);
    floorsG[59] = SurfaceG(-5017, 3789, -971, -5017, 3789, -209, -4965, 3789, -209);
    floorsG[60] = SurfaceG(-4965, 3789, -1022, -5017, 3789, -971, -4965, 3789, -209);
    floorsG[61] = SurfaceG(-4965, 3789, 813, -5631, 3789, 761, -5682, 3789, 813);
    floorsG[62] = SurfaceG(-5682, 3789, -1022, -5682, 3789, -971, -5017, 3789, -971);
    floorsG[63] = SurfaceG(-5682, 3789, -1022, -5017, 3789, -971, -4965, 3789, -1022);
    floorsG[64] = SurfaceG(-5682, 3789, -1022, -6911, 3174, -1022, -6911, 3174, -971);
    floorsG[65] = SurfaceG(-5682, 3789, -971, -5682, 3789, -1022, -6911, 3174, -971);
    floorsG[66] = SurfaceG(-5631, 3789, -663, -5682, 3789, -663, -5682, 3789, 813);
    floorsG[67] = SurfaceG(-5631, 3789, -663, -5682, 3789, 813, -5631, 3789, 761);
    floorsG[68] = SurfaceG(-4965, 3789, 813, -5017, 3789, 761, -5631, 3789, 761);
    floorsG[69] = SurfaceG(2765, 3789, -210, 2150, 3789, -210, 2150, 3789, 403);
    floorsG[70] = SurfaceG(2765, 3789, -210, 2150, 3789, 403, 2765, 3789, 403);
    floorsG[71] = SurfaceG(307, 3789, -518, -306, 3789, 710, 307, 3789, 710);
    floorsG[72] = SurfaceG(307, 3789, -518, -306, 3789, -518, -306, 3789, 710);
    floorsG[73] = SurfaceG(-3173, 3686, -876, -3276, 3686, -876, -3276, 3686, -774);
    floorsG[74] = SurfaceG(-3173, 3686, -876, -3276, 3686, -774, -3173, 3686, -774);
    floorsG[75] = SurfaceG(-3276, 3686, -774, -3276, 3686, -876, -3378, 3482, -978);
    floorsG[76] = SurfaceG(-1330, 3686, -872, -1433, 3686, -872, -1433, 3686, -770);
    floorsG[77] = SurfaceG(-1330, 3686, -872, -1433, 3686, -770, -1330, 3686, -770);
    floorsG[78] = SurfaceG(-1433, 3686, -770, -1433, 3686, -872, -1535, 3482, -975);
    floorsG[79] = SurfaceG(-5017, 3686, 404, -4965, 3686, 404, -4965, 3686, -209);
    floorsG[80] = SurfaceG(-5017, 3686, 404, -4965, 3686, -209, -5017, 3686, -209);
    floorsG[81] = SurfaceG(-5631, 3686, -971, -6911, 3072, -971, -6962, 3072, -663);
    floorsG[82] = SurfaceG(-5631, 3686, -971, -6962, 3072, -663, -5631, 3686, -663);
    floorsG[83] = SurfaceG(-4965, 3686, 404, -4484, 3686, 404, -4484, 3686, -209);
    floorsG[84] = SurfaceG(-4965, 3686, 404, -4484, 3686, -209, -4965, 3686, -209);
    floorsG[85] = SurfaceG(-5631, 3686, -971, -5631, 3686, 761, -5017, 3686, 761);
    floorsG[86] = SurfaceG(-5017, 3686, -971, -5631, 3686, -971, -5017, 3686, 761);
    floorsG[87] = SurfaceG(-4607, 3533, 1126, 563, 3533, 1126, 563, 3482, 1024);
    floorsG[88] = SurfaceG(-4607, 3533, 1126, 563, 3482, 1024, -4530, 3482, 1050);
    floorsG[89] = SurfaceG(-4607, 3533, 1126, -4530, 3482, 1050, -4530, 3482, -1106);
    floorsG[90] = SurfaceG(-4607, 3533, 1126, -4530, 3482, -1106, -4607, 3533, -1183);
    floorsG[91] = SurfaceG(5734, 3533, -1183, 563, 3533, -1183, 5658, 3482, -1106);
    floorsG[92] = SurfaceG(563, 3533, -1183, 563, 3482, -1081, 5658, 3482, -1106);
    floorsG[93] = SurfaceG(5734, 3533, -1183, 5658, 3482, -1106, 5734, 3533, 1126);
    floorsG[94] = SurfaceG(-4146, 3533, -209, -4484, 3686, -209, -4484, 3686, 404);
    floorsG[95] = SurfaceG(-4146, 3533, -209, -4484, 3686, 404, -4146, 3533, 404);
    floorsG[96] = SurfaceG(-3378, 3482, -978, -3276, 3686, -876, -3173, 3686, -876);
    floorsG[97] = SurfaceG(-3378, 3482, -978, -3173, 3686, -876, -3071, 3482, -978);
    floorsG[98] = SurfaceG(-3071, 3482, -978, -3173, 3686, -876, -3173, 3686, -774);
    floorsG[99] = SurfaceG(-3327, 3482, -620, -3276, 3686, -774, -3378, 3482, -978);
    floorsG[100] = SurfaceG(-3122, 3482, -620, -3173, 3686, -774, -3276, 3686, -774);
    floorsG[101] = SurfaceG(-3122, 3482, -620, -3276, 3686, -774, -3327, 3482, -620);
    floorsG[102] = SurfaceG(-3071, 3482, -978, -3173, 3686, -774, -3122, 3482, -620);
    floorsG[103] = SurfaceG(-1535, 3482, -975, -1330, 3686, -872, -1228, 3482, -975);
    floorsG[104] = SurfaceG(-1228, 3482, -975, -1330, 3686, -872, -1330, 3686, -770);
    floorsG[105] = SurfaceG(-1228, 3482, -975, -1330, 3686, -770, -1279, 3482, -616);
    floorsG[106] = SurfaceG(-1535, 3482, -975, -1433, 3686, -872, -1330, 3686, -872);
    floorsG[107] = SurfaceG(-1279, 3482, -616, -1330, 3686, -770, -1433, 3686, -770);
    floorsG[108] = SurfaceG(-1279, 3482, -616, -1433, 3686, -770, -1484, 3482, -616);
    floorsG[109] = SurfaceG(-1484, 3482, -616, -1433, 3686, -770, -1535, 3482, -975);
    floorsG[110] = SurfaceG(-4530, 3482, -1106, 563, 3533, -1183, -4607, 3533, -1183);
    floorsG[111] = SurfaceG(-4530, 3482, -1106, 563, 3482, -1081, 563, 3533, -1183);
    floorsG[112] = SurfaceG(5658, 3482, 1050, 563, 3482, 1024, 5734, 3533, 1126);
    floorsG[113] = SurfaceG(563, 3482, 1024, 563, 3533, 1126, 5734, 3533, 1126);
    floorsG[114] = SurfaceG(5658, 3482, -1106, 5658, 3482, 1050, 5734, 3533, 1126);
    floorsG[115] = SurfaceG(-4530, 3482, 1050, -2000, 3482, -26, -4530, 3482, -1106, true);
    floorsG[116] = SurfaceG(-4530, 3482, 1050, 563, 3482, 1024, -2000, 3482, -26, true);
    floorsG[117] = SurfaceG(-4530, 3482, -1106, -2000, 3482, -26, 563, 3482, -1081, true);
    floorsG[118] = SurfaceG(563, 3482, -1081, -2000, 3482, -26, 563, 3482, 1024, true);
    floorsG[119] = SurfaceG(563, 3482, 1024, 3128, 3482, -26, 563, 3482, -1081, true);
    floorsG[120] = SurfaceG(563, 3482, -1081, 3128, 3482, -26, 5658, 3482, -1106, true);
    floorsG[121] = SurfaceG(3128, 3482, -26, 563, 3482, 1024, 5658, 3482, 1050, true);
    floorsG[122] = SurfaceG(5658, 3482, -1106, 3128, 3482, -26, 5658, 3482, 1050, true);
    floorsG[123] = SurfaceG(-7474, 3174, -612, -7525, 2867, 1, -7474, 2867, 1);
    floorsG[124] = SurfaceG(-7474, 3174, -612, -7525, 3174, -612, -7525, 2867, 1);
    floorsG[125] = SurfaceG(-7525, 3174, -612, -7474, 3174, -612, -7321, 3174, -971);
    floorsG[126] = SurfaceG(-7525, 3174, -612, -7321, 3174, -971, -7372, 3174, -1022);
    floorsG[127] = SurfaceG(-7372, 3174, -1021, -7321, 3174, -971, -6911, 3174, -971);
    floorsG[128] = SurfaceG(-7372, 3174, -1021, -6911, 3174, -971, -6911, 3174, -1022);
    floorsG[129] = SurfaceG(-6911, 3174, -663, -6962, 3174, -663, -6962, 3174, -612);
    floorsG[130] = SurfaceG(-6911, 3174, -612, -5682, 3789, -612, -5682, 3789, -663);
    floorsG[131] = SurfaceG(-6911, 3174, -663, -6911, 3174, -612, -5682, 3789, -663);
    floorsG[132] = SurfaceG(-6911, 3174, -663, -6962, 3174, -612, -6911, 3174, -612);
    floorsG[133] = SurfaceG(-6962, 3072, -612, -6962, 3072, -663, -7474, 3072, -612);
    floorsG[134] = SurfaceG(-6962, 3072, -663, -6911, 3072, -971, -7474, 3072, -612);
    floorsG[135] = SurfaceG(-6911, 3072, -971, -7321, 3072, -971, -7474, 3072, -612);
    floorsG[136] = SurfaceG(-6962, 3072, -612, -7474, 3072, -612, -6962, 2765, 52);
    floorsG[137] = SurfaceG(-7474, 3072, -612, -7474, 2765, 1, -6962, 2765, 52);
    floorsG[138] = SurfaceG(6640, 2899, -122, 6640, 2899, 321, 6830, 2899, 321);
    floorsG[139] = SurfaceG(6640, 2899, -122, 6830, 2899, 321, 6957, 2899, 194);
    floorsG[140] = SurfaceG(6640, 2899, -122, 6513, 2899, 194, 6640, 2899, 321);
    floorsG[141] = SurfaceG(6640, 2899, -122, 6957, 2899, 194, 6957, 2899, 4);
    floorsG[142] = SurfaceG(6640, 2899, -122, 6957, 2899, 4, 6830, 2899, -122);
    floorsG[143] = SurfaceG(6640, 2899, -122, 6513, 2899, 4, 6513, 2899, 194);
    floorsG[144] = SurfaceG(-6911, 2867, 1, -6297, 2867, 52, -6297, 2867, 1);
    floorsG[145] = SurfaceG(-6911, 2867, 1, -6911, 2867, 52, -6297, 2867, 52);
    floorsG[146] = SurfaceG(-7474, 2867, 1, -7525, 2867, 1, -7218, 2867, 616);
    floorsG[147] = SurfaceG(-7218, 2867, 616, -7187, 2867, 564, -7474, 2867, 1);
    floorsG[148] = SurfaceG(-7218, 2867, 616, -6297, 2867, 616, -6297, 2867, 564);
    floorsG[149] = SurfaceG(-7218, 2867, 616, -6297, 2867, 564, -7187, 2867, 564);
    floorsG[150] = SurfaceG(-6962, 2867, 1, -6911, 3174, -612, -6962, 3174, -612);
    floorsG[151] = SurfaceG(-6962, 2867, 1, -6911, 2867, 1, -6911, 3174, -612);
    floorsG[152] = SurfaceG(-6962, 2867, 52, -6911, 2867, 1, -6962, 2867, 1);
    floorsG[153] = SurfaceG(-6962, 2867, 52, -6911, 2867, 52, -6911, 2867, 1);
    floorsG[154] = SurfaceG(-6962, 2765, 52, -6297, 2765, 564, -6297, 2765, 52);
    floorsG[155] = SurfaceG(-6962, 2765, 52, -7187, 2765, 564, -6297, 2765, 564);
    floorsG[156] = SurfaceG(-6962, 2765, 52, -7474, 2765, 1, -7187, 2765, 564);
    floorsG[157] = SurfaceG(-2354, 1331, -613, -1637, 1331, 0, -1330, 1331, -306);
    floorsG[158] = SurfaceG(-2354, 1331, -613, -2354, 1331, -306, -2047, 1331, 0);
    floorsG[159] = SurfaceG(-2354, 1331, -613, -2047, 1331, 0, -1637, 1331, 0);
    floorsG[160] = SurfaceG(-2354, 1331, -613, -1330, 1331, -613, -1637, 1331, -921);
    floorsG[161] = SurfaceG(-2354, 1331, -613, -1637, 1331, -921, -2047, 1331, -921);
    floorsG[162] = SurfaceG(-2354, 1331, -613, -1330, 1331, -306, -1330, 1331, -613);
    floorsG[163] = SurfaceG(-1381, 819, -25, -1407, 819, 0, -1356, 819, 0);
    floorsG[164] = SurfaceG(-1356, 819, 614, -1407, 819, 614, -1381, 819, 640);
    floorsG[165] = SurfaceG(-2380, 819, 614, -2431, 819, 614, -2405, 819, 640);
    floorsG[166] = SurfaceG(-2405, 819, -25, -2431, 819, 0, -2380, 819, 0);
    floorsG[167] = SurfaceG(-562, 819, -306, -665, 819, 0, -562, 819, 0);
    floorsG[168] = SurfaceG(-562, 819, -306, -665, 819, -306, -665, 819, 0);
    floorsG[169] = SurfaceG(-665, 819, 614, -1074, 410, 0, -1074, 410, 614);
    floorsG[170] = SurfaceG(-665, 819, 614, -665, 819, 0, -1074, 410, 0);
    floorsG[171] = SurfaceG(-665, 819, 614, -562, 819, 614, -562, 819, 0);
    floorsG[172] = SurfaceG(-562, 819, 0, -562, 819, 614, -50, 410, 614);
    floorsG[173] = SurfaceG(-562, 819, 0, -50, 410, 614, -50, 410, 0);
    floorsG[174] = SurfaceG(-665, 819, 614, -562, 819, 0, -665, 819, 0);
    floorsG[175] = SurfaceG(-767, 819, -613, -1330, 1331, -306, -767, 819, -306);
    floorsG[176] = SurfaceG(-767, 819, -306, -460, 819, -306, -460, 819, -613);
    floorsG[177] = SurfaceG(-767, 819, -306, -460, 819, -613, -767, 819, -613);
    floorsG[178] = SurfaceG(-767, 819, -613, -1330, 1331, -613, -1330, 1331, -306);
    floorsG[179] = SurfaceG(-1330, 788, 614, -2457, 742, 640, -1330, 742, 640);
    floorsG[180] = SurfaceG(-1330, 788, 614, -2457, 788, 614, -2457, 742, 640);
    floorsG[181] = SurfaceG(-1330, 753, 0, -2457, 753, 614, -1330, 753, 614);
    floorsG[182] = SurfaceG(-1330, 753, 0, -2457, 753, 0, -2457, 753, 614);
    floorsG[183] = SurfaceG(-1330, 742, -25, -2457, 742, -25, -2457, 788, 0);
    floorsG[184] = SurfaceG(-1330, 742, -25, -2457, 788, 0, -1330, 788, 0);
    floorsG[185] = SurfaceG(1280, 410, -462, 1178, 410, -462, 1178, 410, -359);
    floorsG[186] = SurfaceG(1280, 410, -462, 1178, 410, -359, 1280, 410, -359);
    floorsG[187] = SurfaceG(1178, 410, -359, 1178, 410, -462, 1075, 205, -564);
    floorsG[188] = SurfaceG(922, 410, 102, 205, 410, 102, 205, 410, 512);
    floorsG[189] = SurfaceG(-5836, 410, 1, -4197, 410, 1, -4505, 410, -305);
    floorsG[190] = SurfaceG(-5836, 410, 1, -4505, 410, -305, -5529, 410, -305);
    floorsG[191] = SurfaceG(-5836, 410, 1, -4197, 410, 617, -4197, 410, 1);
    floorsG[192] = SurfaceG(-5836, 410, 1, -5836, 410, 617, -5529, 410, 924);
    floorsG[193] = SurfaceG(-5836, 410, 1, -5529, 410, 924, -4505, 410, 924);
    floorsG[194] = SurfaceG(-5836, 410, 1, -4505, 410, 924, -4197, 410, 617);
    floorsG[195] = SurfaceG(2458, 410, 102, 1741, 410, 512, 2458, 410, 512);
    floorsG[196] = SurfaceG(922, 410, 102, 205, 410, 512, 922, 410, 512);
    floorsG[197] = SurfaceG(-2969, 410, 617, -2149, 307, 2, -2969, 410, 2);
    floorsG[198] = SurfaceG(-2969, 410, 617, -2149, 307, 617, -2149, 307, 2);
    floorsG[199] = SurfaceG(2458, 410, 102, 1741, 410, 102, 1741, 410, 512);
    floorsG[200] = SurfaceG(2662, 410, 512, 2458, 410, 717, 3277, 410, 717);
    floorsG[201] = SurfaceG(2458, 410, 717, 2662, 410, 512, 2662, 410, 102);
    floorsG[202] = SurfaceG(2458, 410, 717, 2662, 410, 102, 2458, 410, -101);
    floorsG[203] = SurfaceG(2458, 410, -101, 2662, 410, 102, 3072, 410, 102);
    floorsG[204] = SurfaceG(2458, 410, -101, 3072, 410, 102, 3277, 410, -101);
    floorsG[205] = SurfaceG(3277, 410, 717, 3277, 410, -101, 3072, 410, 102);
    floorsG[206] = SurfaceG(3277, 410, 717, 3072, 410, 102, 3072, 410, 512);
    floorsG[207] = SurfaceG(2662, 410, 512, 3277, 410, 717, 3072, 410, 512);
    floorsG[208] = SurfaceG(-50, 410, 614, 205, 410, 0, -50, 410, 0);
    floorsG[209] = SurfaceG(-1433, 410, 614, -1074, 410, 0, -1433, 410, 0);
    floorsG[210] = SurfaceG(-1433, 410, 614, -1074, 410, 614, -1074, 410, 0);
    floorsG[211] = SurfaceG(-50, 410, 614, 205, 410, 614, 205, 410, 0);
    floorsG[212] = SurfaceG(-2354, 256, 1126, 1126, 256, 1126, 1126, 205, 1050);
    floorsG[213] = SurfaceG(-7525, 256, 1126, -2354, 256, 1126, -2354, 205, 1024);
    floorsG[214] = SurfaceG(1126, 256, -1183, -2354, 256, -1183, -2354, 205, -1081);
    floorsG[215] = SurfaceG(1126, 256, -1183, -2354, 205, -1081, 1126, 205, -1106);
    floorsG[216] = SurfaceG(4915, 256, 1126, 4915, 256, -1183, 4838, 205, -1106);
    floorsG[217] = SurfaceG(4915, 256, 1126, 4838, 205, -1106, 4838, 205, 1050);
    floorsG[218] = SurfaceG(-7525, 256, 1126, -2354, 205, 1024, -7449, 205, 1050);
    floorsG[219] = SurfaceG(-7525, 256, 1126, -7449, 205, 1050, -7449, 205, -1106);
    floorsG[220] = SurfaceG(-7525, 256, 1126, -7449, 205, -1106, -7525, 256, -1183);
    floorsG[221] = SurfaceG(2662, 207, 512, -2354, 205, -1081, -2354, 205, 1024, true);
    floorsG[222] = SurfaceG(2662, 207, 512, 2663, 205, 101, -2354, 205, -1081, true);
    floorsG[223] = SurfaceG(1126, 205, 1050, -2354, 205, 1024, -2354, 256, 1126);
    floorsG[224] = SurfaceG(4838, 205, 1050, 1126, 256, 1126, 4915, 256, 1126);
    floorsG[225] = SurfaceG(4838, 205, 1050, 1126, 205, 1050, 1126, 256, 1126);
    floorsG[226] = SurfaceG(1075, 205, -564, 1280, 410, -462, 1382, 205, -564);
    floorsG[227] = SurfaceG(1382, 205, -564, 1280, 410, -462, 1280, 410, -359);
    floorsG[228] = SurfaceG(1075, 205, -564, 1178, 410, -462, 1280, 410, -462);
    floorsG[229] = SurfaceG(1126, 205, -206, 1178, 410, -359, 1075, 205, -564);
    floorsG[230] = SurfaceG(1331, 205, -206, 1280, 410, -359, 1178, 410, -359);
    floorsG[231] = SurfaceG(1331, 205, -206, 1178, 410, -359, 1126, 205, -206);
    floorsG[232] = SurfaceG(1382, 205, -564, 1280, 410, -359, 1331, 205, -206);
    floorsG[233] = SurfaceG(-7449, 205, -1106, -2354, 205, -1081, -2354, 256, -1183);
    floorsG[234] = SurfaceG(1126, 205, -1106, 4838, 205, -1106, 4915, 256, -1183);
    floorsG[235] = SurfaceG(1126, 205, -1106, 4915, 256, -1183, 1126, 256, -1183);
    floorsG[236] = SurfaceG(-7449, 205, -1106, -2354, 256, -1183, -7525, 256, -1183);
    floorsG[237] = SurfaceG(1126, 205, 1050, 3072, 205, 512, 2662, 207, 512, true);
    floorsG[238] = SurfaceG(1126, 205, 1050, 4838, 205, 1050, 3072, 205, 512, true);
    floorsG[239] = SurfaceG(4838, 205, -1106, 3072, 205, 512, 4838, 205, 1050, true);
    floorsG[240] = SurfaceG(4838, 205, -1106, 3072, 205, 102, 3072, 205, 512, true);
    floorsG[241] = SurfaceG(1126, 205, 1050, 2662, 207, 512, -2354, 205, 1024, true);
    floorsG[242] = SurfaceG(2663, 205, 101, 3072, 205, 102, 4838, 205, -1106, true);
    floorsG[243] = SurfaceG(2663, 205, 101, 1126, 205, -1106, -2354, 205, -1081, true);
    floorsG[244] = SurfaceG(2663, 205, 101, 4838, 205, -1106, 1126, 205, -1106, true);
    floorsG[245] = SurfaceG(-7449, 205, -1106, -4919, 205, -26, -2354, 205, -1081, true);
    floorsG[246] = SurfaceG(-2354, 205, -1081, -4919, 205, -26, -2354, 205, 1024, true);
    floorsG[247] = SurfaceG(-7449, 205, 1050, -2354, 205, 1024, -4919, 205, -26, true);
    floorsG[248] = SurfaceG(-7449, 205, 1050, -4919, 205, -26, -7449, 205, -1106, true);
    floorsG[249] = SurfaceG(4403, -665, 819, 4454, -665, 819, 4454, -665, -255);
    floorsG[250] = SurfaceG(4403, -665, 819, 4454, -665, -255, 4403, -665, -204);
    floorsG[251] = SurfaceG(4454, -665, -255, 3379, -665, -204, 4403, -665, -204);
    floorsG[252] = SurfaceG(4454, -665, -255, 3379, -665, -255, 3379, -665, -204);
    floorsG[253] = SurfaceG(3379, -665, -204, 3379, -665, -255, 3072, -665, 102);
    floorsG[254] = SurfaceG(3379, -1279, 819, 3738, -1279, 461, 3738, -1279, 154);
    floorsG[255] = SurfaceG(3738, -1279, 461, 4403, -1279, 819, 4045, -1279, 461);
    floorsG[256] = SurfaceG(3738, -1279, 461, 3379, -1279, 819, 4403, -1279, 819);
    floorsG[257] = SurfaceG(3379, -1279, 819, 3072, -1125, 102, 3072, -1125, 512);
    floorsG[258] = SurfaceG(3379, -1279, 819, 3738, -1279, 154, 3379, -1279, -204);
    floorsG[259] = SurfaceG(3379, -1279, 819, 3379, -1279, -204, 3072, -1125, 102);
    floorsG[260] = SurfaceG(4045, -1279, 154, 4045, -1279, 461, 4403, -1279, 819);
    floorsG[261] = SurfaceG(4045, -1279, 154, 4403, -1279, 819, 4403, -1279, -204);
    floorsG[262] = SurfaceG(3379, -1279, -204, 3738, -1279, 154, 4045, -1279, 154);
    floorsG[263] = SurfaceG(3379, -1279, -204, 4045, -1279, 154, 4403, -1279, -204);
    floorsG[264] = SurfaceG(5070, -2042, 317, 5070, -2042, 215, 4967, -2042, 215);
    floorsG[265] = SurfaceG(5070, -2042, 317, 4967, -2042, 215, 4967, -2042, 317);
    floorsG[266] = SurfaceG(3941, -2042, 317, 3941, -2042, 215, 3839, -2042, 317);
    floorsG[267] = SurfaceG(3941, -2042, 215, 3839, -2042, 215, 3839, -2042, 317);
    floorsG[268] = SurfaceG(4967, -2042, 215, 5070, -2042, 215, 5070, -2124, 164);
    floorsG[269] = SurfaceG(4967, -2042, 215, 5070, -2124, 164, 4967, -2124, 164);
    floorsG[270] = SurfaceG(3941, -2042, 317, 3839, -2042, 317, 3941, -2124, 369);
    floorsG[271] = SurfaceG(3839, -2042, 317, 3839, -2124, 369, 3941, -2124, 369);
    floorsG[272] = SurfaceG(5172, -2093, 215, 5070, -2042, 215, 5070, -2042, 317);
    floorsG[273] = SurfaceG(5172, -2093, 215, 5070, -2042, 317, 5172, -2093, 317);
    floorsG[274] = SurfaceG(3839, -2124, 164, 3839, -2042, 215, 3941, -2042, 215);
    floorsG[275] = SurfaceG(4967, -2124, 369, 5070, -2124, 369, 5070, -2042, 317);
    floorsG[276] = SurfaceG(4967, -2124, 369, 5070, -2042, 317, 4967, -2042, 317);
    floorsG[277] = SurfaceG(3941, -2124, 164, 3839, -2124, 164, 3941, -2042, 215);
    floorsG[278] = SurfaceG(7526, -2149, -40, 6912, -2149, -40, 6912, -2149, 573);
    floorsG[279] = SurfaceG(7526, -2149, -40, 6912, -2149, 573, 7526, -2149, 573);
    floorsG[280] = SurfaceG(1024, -2149, -1289, 1434, -2457, -921, 1434, -2149, -1289);
    floorsG[281] = SurfaceG(1024, -2149, -1289, 1024, -2457, -921, 1434, -2457, -921);
    floorsG[282] = SurfaceG(1690, -2149, -1289, 1382, -2149, -1596, 1075, -2149, -1596);
    floorsG[283] = SurfaceG(1690, -2149, -1289, 1075, -2149, -1596, 768, -2149, -1289);
    floorsG[284] = SurfaceG(1690, -2149, -2211, 1382, -2149, -1596, 1690, -2149, -1289);
    floorsG[285] = SurfaceG(1690, -2149, -2211, 1382, -2149, -1904, 1382, -2149, -1596);
    floorsG[286] = SurfaceG(768, -2149, -1289, 1075, -2149, -1596, 1075, -2149, -1904);
    floorsG[287] = SurfaceG(768, -2149, -1289, 1075, -2149, -1904, 768, -2149, -2211);
    floorsG[288] = SurfaceG(768, -2149, -2211, 1075, -2149, -1904, 1382, -2149, -1904);
    floorsG[289] = SurfaceG(768, -2149, -2211, 1382, -2149, -1904, 1690, -2149, -2211);
    floorsG[290] = SurfaceG(5273, -2196, 215, 5170, -2196, 215, 5170, -2196, 317);
    floorsG[291] = SurfaceG(5273, -2196, 317, 5273, -2196, 215, 5170, -2196, 317);
    floorsG[292] = SurfaceG(6401, -2196, 317, 6299, -2196, 215, 6299, -2196, 317);
    floorsG[293] = SurfaceG(6401, -2196, 317, 6401, -2196, 215, 6299, -2196, 215);
    floorsG[294] = SurfaceG(5273, -2196, 317, 5170, -2196, 317, 5273, -2278, 369);
    floorsG[295] = SurfaceG(5170, -2196, 317, 5170, -2278, 369, 5273, -2278, 369);
    floorsG[296] = SurfaceG(6299, -2196, 215, 6401, -2278, 164, 6299, -2278, 164);
    floorsG[297] = SurfaceG(6299, -2196, 215, 6401, -2196, 215, 6401, -2278, 164);
    floorsG[298] = SurfaceG(6299, -2278, 369, 6401, -2196, 317, 6299, -2196, 317);
    floorsG[299] = SurfaceG(5170, -2278, 164, 5170, -2196, 215, 5273, -2196, 215);
    floorsG[300] = SurfaceG(5273, -2278, 164, 5170, -2278, 164, 5273, -2196, 215);
    floorsG[301] = SurfaceG(6299, -2278, 369, 6401, -2278, 369, 6401, -2196, 317);
    floorsG[302] = SurfaceG(2662, -2457, -306, 2662, -2764, 61, 3072, -2764, 61);
    floorsG[303] = SurfaceG(2662, -2457, -306, 3072, -2764, 61, 3072, -2457, -306);
    floorsG[304] = SurfaceG(2662, -2457, -613, 3072, -2457, -921, 1843, -2457, -921);
    floorsG[305] = SurfaceG(2662, -2457, -613, 2662, -2457, -306, 3072, -2457, -306);
    floorsG[306] = SurfaceG(2662, -2457, -613, 3072, -2457, -306, 3072, -2457, -921);
    floorsG[307] = SurfaceG(2253, -2457, -613, 2662, -2457, -613, 1843, -2457, -921);
    floorsG[308] = SurfaceG(2253, -2457, -613, 1843, -2457, -921, 1843, -2457, -613);
    floorsG[309] = SurfaceG(1843, -2457, -613, 2253, -2457, -306, 2253, -2457, -613);
    floorsG[310] = SurfaceG(1843, -2457, -613, 1434, -2457, -613, 2253, -2457, -306);
    floorsG[311] = SurfaceG(1434, -2457, -613, 1024, -2457, -306, 2253, -2457, -306);
    floorsG[312] = SurfaceG(1434, -2457, -613, 1024, -2457, -921, 1024, -2457, -306);
    floorsG[313] = SurfaceG(1434, -2457, -613, 1434, -2457, -921, 1024, -2457, -921);
    floorsG[314] = SurfaceG(-4453, -2661, -613, -4607, -3071, -306, -4453, -2661, -306);
    floorsG[315] = SurfaceG(-4453, -2661, -613, -4607, -3071, -613, -4607, -3071, -306);
    floorsG[316] = SurfaceG(-4453, -2661, -306, -4146, -2661, -306, -4146, -2661, -613);
    floorsG[317] = SurfaceG(-4453, -2661, -306, -4146, -2661, -613, -4453, -2661, -613);
    floorsG[318] = SurfaceG(-4453, -2743, -306, -4453, -2743, 307, -4146, -2743, 307);
    floorsG[319] = SurfaceG(-4453, -2743, -306, -4146, -2743, 307, -4146, -2743, -306);
    floorsG[320] = SurfaceG(3379, -2764, -347, 4301, -2764, -40, 3994, -2764, -347);
    floorsG[321] = SurfaceG(3379, -2764, -347, 4301, -2764, 573, 4301, -2764, -40);
    floorsG[322] = SurfaceG(3379, -2764, -347, 3072, -2764, -40, 3072, -2764, 573);
    floorsG[323] = SurfaceG(3379, -2764, -347, 3072, -2764, 573, 3379, -2764, 881);
    floorsG[324] = SurfaceG(3379, -2764, -347, 3994, -2764, 881, 4301, -2764, 573);
    floorsG[325] = SurfaceG(3379, -2764, -347, 3379, -2764, 881, 3994, -2764, 881);
    floorsG[326] = SurfaceG(2662, -2764, -347, 2048, -2764, -347, 2048, -2764, 881);
    floorsG[327] = SurfaceG(2662, -2764, -347, 2048, -2764, 881, 2662, -2764, 881);
    floorsG[328] = SurfaceG(3072, -2764, 61, 2662, -2764, 471, 3072, -2764, 471);
    floorsG[329] = SurfaceG(3072, -2764, 61, 2662, -2764, 61, 2662, -2764, 471);
    floorsG[330] = SurfaceG(-7065, -2764, -511, -7986, -2764, 512, -7065, -2764, 512);
    floorsG[331] = SurfaceG(-7065, -2764, -511, -7986, -2764, -511, -7986, -2764, 512);
    floorsG[332] = SurfaceG(-7065, -2764, 307, -6553, -2866, 307, -6553, -2866, -306);
    floorsG[333] = SurfaceG(-7065, -2764, 307, -6553, -2866, -306, -7065, -2764, -306);
    floorsG[334] = SurfaceG(-6553, -2866, 307, -7065, -3071, 322, -6041, -3071, 307);
    floorsG[335] = SurfaceG(-306, -2866, 307, 0, -2866, 922, 0, -2866, -306);
    floorsG[336] = SurfaceG(-306, -2866, 307, 0, -2866, -306, -306, -2866, -306);
    floorsG[337] = SurfaceG(-6041, -2866, -306, -6553, -2866, 307, -6041, -2866, 307);
    floorsG[338] = SurfaceG(-6041, -2866, -306, -6553, -2866, -306, -6553, -2866, 307);
    floorsG[339] = SurfaceG(5222, -2917, 573, 6298, -2917, 573, 6298, -2917, -40);
    floorsG[340] = SurfaceG(5222, -2917, 573, 4301, -2764, -40, 4301, -2764, 573);
    floorsG[341] = SurfaceG(5222, -2917, 573, 5222, -2917, -40, 4301, -2764, -40);
    floorsG[342] = SurfaceG(5222, -2917, 573, 6298, -2917, -40, 5222, -2917, -40);
    floorsG[343] = SurfaceG(-921, -3020, 307, -921, -3020, 922, -306, -2866, 307);
    floorsG[344] = SurfaceG(-921, -3020, 922, 0, -2866, 922, -306, -2866, 307);
    floorsG[345] = SurfaceG(-3993, -3071, -613, -4146, -2661, -306, -3993, -3071, -306);
    floorsG[346] = SurfaceG(-3993, -3071, -613, -4146, -2661, -613, -4146, -2661, -306);
    floorsG[347] = SurfaceG(-7065, -3071, 322, -6553, -2866, 307, -7065, -2866, 307);
    floorsG[348] = SurfaceG(-8191, -3071, 8192, 8192, -3071, -8191, -8191, -3071, -8191, true);
    floorsG[349] = SurfaceG(-8191, -3071, 8192, 8192, -3071, 8192, 8192, -3071, -8191, true);
}

void init_reverse_atan() {
    for (int i = 0; i < 8192; i++) {
        int angle = (unsigned short)gArctanTable[i];
        gReverseArctanTable[angle] = i;
    }
}

__global__ void init_reverse_atanG() {
    for (int i = 0; i < 8192; i++) {
        int angle = (unsigned short)gArctanTableG[i];
        gReverseArctanTableG[angle] = i;
    }
}

__global__ void init_lakitu_position(float x, float y, float z) {
    lakituPositionG[0] = x;
    lakituPositionG[1] = y;
    lakituPositionG[2] = z;
}

__global__ void copy_pointers_to_gpu(SlideSetup* p1, StrainSetup* p2, CollisionSetup* p3, StrainNode** p4, int* p5, bool* p6) {
    slidingSetups = p1;
    strainSetups = p2;
    collisionSetups = p3;
    strainLookup = p4;
    nStrainNodes = p5;
    validCameraAngleG = p6;
}

void init_camera_angles(bool* validCameraAngle) {
    for (int i = 0; i < 65536; i += 16) {
        int angle = (unsigned short)atan2s(coss(i), sins(i));

        validCameraAngle[angle] = true;
    }
}

__device__ int16_t atan2_lookupG(float z, float x) {
    int16_t angle = 0;

    if (x == 0) {
        angle = gArctanTableG[0];
    }
    else {
        angle = gArctanTableG[uint16_t(float(float(z / x) * 1024.0 + 0.5))];
    }

    return angle;
}

__device__ int16_t atan2sG(float z, float x) {
    int16_t angle = 0;

    if (x >= 0) {
        if (z >= 0) {
            if (z >= x) {
                angle = atan2_lookupG(x, z);
            }
            else {
                angle = 0x4000 - atan2_lookupG(z, x);
            }
        }
        else {
            z = -z;

            if (z < x) {
                angle = 0x4000 + atan2_lookupG(z, x);
            }
            else {
                angle = 0x8000 - atan2_lookupG(x, z);
            }
        }
    }
    else {
        x = -x;

        if (z < 0) {
            z = -z;

            if (z >= x) {
                angle = 0x8000 + atan2_lookupG(x, z);
            }
            else {
                angle = 0xC000 - atan2_lookupG(z, x);
            }
        }
        else {
            if (z < x) {
                angle = 0xC000 + atan2_lookupG(z, x);
            }
            else {
                angle = -atan2_lookupG(x, z);
            }
        }
    }

    return (short)angle;
}

__device__ int find_floorG(float* position, SurfaceG** floor, float& floor_y, SurfaceG floor_set[], int n_floor_set) {
    short x = (short)(int)position[0];
    short y = (short)(int)position[1];
    short z = (short)(int)position[2];

    int floor_idx = -1;

    for (int i = 0; i < n_floor_set; ++i) {
        if (x < floor_set[i].min_x || x > floor_set[i].max_x || z < floor_set[i].min_z || z > floor_set[i].max_z) {
            continue;
        }

        if ((floor_set[i].vertices[0][2] - z) * (floor_set[i].vertices[1][0] - floor_set[i].vertices[0][0]) - (floor_set[i].vertices[0][0] - x) * (floor_set[i].vertices[1][2] - floor_set[i].vertices[0][2]) < 0) {
            continue;
        }
        if ((floor_set[i].vertices[1][2] - z) * (floor_set[i].vertices[2][0] - floor_set[i].vertices[1][0]) - (floor_set[i].vertices[1][0] - x) * (floor_set[i].vertices[2][2] - floor_set[i].vertices[1][2]) < 0) {
            continue;
        }
        if ((floor_set[i].vertices[2][2] - z) * (floor_set[i].vertices[0][0] - floor_set[i].vertices[2][0]) - (floor_set[i].vertices[2][0] - x) * (floor_set[i].vertices[0][2] - floor_set[i].vertices[2][2]) < 0) {
            continue;
        }

        float height = -(x * floor_set[i].normal[0] + floor_set[i].normal[2] * z + floor_set[i].origin_offset) / floor_set[i].normal[1];

        if (y - (height + -78.0f) < 0.0f) {
            continue;
        }

        floor_y = height;
        *floor = &floor_set[i];
        floor_idx = i;
        break;
    }

    return floor_idx;
}


int calculate_camera_yaw(Vec3f currentPosition, Vec3f lakituPosition, short baseCameraYaw, short faceAngle, float currentFloorY) {
    float baseCameraDist = 1400.0;
    short baseCameraPitch = 0x05B0;

    SurfaceC* floor;
    float floorY;

    float xOff = currentPosition[0] + sins(baseCameraYaw) * 40.f;
    float zOff = currentPosition[2] + coss(baseCameraYaw) * 40.f;
    float offPos[3] = { xOff, currentPosition[1], zOff };

    int floorIdx = find_floor(offPos, &floor, floorY, floorsC, total_floorsC);
    floorY = floorY - currentPosition[1];

    if (floorIdx != -1) {
        if (floorY > 0) {
            if (!(floor->normal[2] == 0.f && floorY < 100.f)) {
                baseCameraPitch += atan2s(40.f, floorY);
            }
        }
    }

    float posMul = 1.f;
    float posBound = 200.f;
    //float posBound = 1200.f; //pole
    float focMul = 0.9f;
    float focBound = 200.f;

    float posY = (currentFloorY - currentPosition[1]) * posMul;

    if (posY > posBound) {
        posY = posBound;
    }

    if (posY < -posBound) {
        posY = -posBound;
    }

    float focusY = (currentFloorY - currentPosition[1]) * focMul;

    if (focusY > focBound) {
        focusY = focBound;
    }

    if (focusY < -focBound) {
        focusY = -focBound;
    }

    baseCameraPitch = baseCameraPitch + 2304;

    float cameraPos[3] = { currentPosition[0] + baseCameraDist * coss(baseCameraPitch) * sins(baseCameraYaw),
                       currentPosition[1] + posY + 125.0f + baseCameraDist * sins(baseCameraPitch),
                       currentPosition[2] + baseCameraDist * coss(baseCameraPitch) * coss(baseCameraYaw)
    };

    float pan[3] = { 0, 0, 0 };
    float temp[3] = { 0, 0, 0 };

    // Get distance and angle from camera to Mario.
    float dx = currentPosition[0] - cameraPos[0];
    float dy = currentPosition[1] - cameraPos[1];
    float dz = currentPosition[2] - cameraPos[2];

    float cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    float cameraPitch = atan2s(sqrtf(dx * dx + dz * dz), dy);
    float cameraYaw = atan2s(dz, dx);

    // The camera will pan ahead up to about 30% of the camera's distance to Mario.
    pan[2] = sins(0xC00) * cameraDist;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sins(faceAngle) + temp[0] * coss(faceAngle);
    pan[2] = temp[2] * coss(faceAngle) - temp[0] * sins(faceAngle);

    // rotate in the opposite direction
    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sins(cameraYaw) + temp[0] * coss(cameraYaw);
    pan[2] = temp[2] * coss(cameraYaw) - temp[0] * sins(cameraYaw);

    // Only pan left or right
    pan[2] = 0.f;

    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    //temp[0] = -pan[0]; //pole
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sins(cameraYaw) + temp[0] * coss(cameraYaw);
    pan[2] = temp[2] * coss(cameraYaw) - temp[0] * sins(cameraYaw);

    float cameraFocus[3] = { currentPosition[0] + pan[0], currentPosition[1] + focusY + 125.0f + pan[1], currentPosition[2] + pan[2] };

    dx = cameraFocus[0] - lakituPosition[0];
    dy = cameraFocus[1] - lakituPosition[1];
    dz = cameraFocus[2] - lakituPosition[2];

    cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    cameraPitch = atan2s(sqrtf(dx * dx + dz * dz), dy);
    cameraYaw = atan2s(dz, dx);

    if (cameraPitch > 15872) {
        cameraPitch = 15872;
    }
    if (cameraPitch < -15872) {
        cameraPitch = -15872;
    }

    cameraFocus[0] = lakituPosition[0] + cameraDist * coss(cameraPitch) * sins(cameraYaw);
    cameraFocus[1] = lakituPosition[1] + cameraDist * sins(cameraPitch);
    cameraFocus[2] = lakituPosition[2] + cameraDist * coss(cameraPitch) * coss(cameraYaw);

    return atan2s(lakituPosition[2] - cameraFocus[2], lakituPosition[0] - cameraFocus[0]);
}

__device__ int calculate_camera_yawG(float* currentPosition, float* lakituPosition, short baseCameraYaw, short faceAngle, float currentFloorY) {
    float baseCameraDist = 1400.0;
    short baseCameraPitch = 0x05B0;

    SurfaceG* floor;
    float floorY;

    float xOff = currentPosition[0] + sinsG(baseCameraYaw) * 40.f;
    float zOff = currentPosition[2] + cossG(baseCameraYaw) * 40.f;
    float offPos[3] = { xOff, currentPosition[1], zOff };

    int floorIdx = find_floorG(offPos, &floor, floorY, floorsG, total_floorsG);
    floorY = floorY - currentPosition[1];

    if (floorIdx != -1) {
        if (floorY > 0) {
            if (!(floor->normal[2] == 0.f && floorY < 100.f)) {
                baseCameraPitch += atan2sG(40.f, floorY);
            }
        }
    }

    float posMul = 1.f;
    float posBound = 200.f;
    //float posBound = 1200.f; //pole
    float focMul = 0.9f;
    float focBound = 200.f;

    float posY = (currentFloorY - currentPosition[1]) * posMul;

    if (posY > posBound) {
        posY = posBound;
    }

    if (posY < -posBound) {
        posY = -posBound;
    }

    float focusY = (currentFloorY - currentPosition[1]) * focMul;

    if (focusY > focBound) {
        focusY = focBound;
    }

    if (focusY < -focBound) {
        focusY = -focBound;
    }

    baseCameraPitch = baseCameraPitch + 2304;

    float cameraPos[3] = { currentPosition[0] + baseCameraDist * cossG(baseCameraPitch) * sinsG(baseCameraYaw),
                       currentPosition[1] + posY + 125.0f + baseCameraDist * sinsG(baseCameraPitch),
                       currentPosition[2] + baseCameraDist * cossG(baseCameraPitch) * cossG(baseCameraYaw)
    };

    float pan[3] = { 0, 0, 0 };
    float temp[3] = { 0, 0, 0 };

    // Get distance and angle from camera to Mario.
    float dx = currentPosition[0] - cameraPos[0];
    float dy = currentPosition[1] - cameraPos[1];
    float dz = currentPosition[2] - cameraPos[2];

    float cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    float cameraPitch = atan2sG(sqrtf(dx * dx + dz * dz), dy);
    float cameraYaw = atan2sG(dz, dx);

    // The camera will pan ahead up to about 30% of the camera's distance to Mario.
    pan[2] = sinsG(0xC00) * cameraDist;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(faceAngle) + temp[0] * cossG(faceAngle);
    pan[2] = temp[2] * cossG(faceAngle) - temp[0] * sinsG(faceAngle);

    // rotate in the opposite direction
    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(cameraYaw) + temp[0] * cossG(cameraYaw);
    pan[2] = temp[2] * cossG(cameraYaw) - temp[0] * sinsG(cameraYaw);

    // Only pan left or right
    pan[2] = 0.f;

    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    //temp[0] = -pan[0]; //pole
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(cameraYaw) + temp[0] * cossG(cameraYaw);
    pan[2] = temp[2] * cossG(cameraYaw) - temp[0] * sinsG(cameraYaw);

    float cameraFocus[3] = { currentPosition[0] + pan[0], currentPosition[1] + focusY + 125.0f + pan[1], currentPosition[2] + pan[2] };

    dx = cameraFocus[0] - lakituPosition[0];
    dy = cameraFocus[1] - lakituPosition[1];
    dz = cameraFocus[2] - lakituPosition[2];

    cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    cameraPitch = atan2sG(sqrtf(dx * dx + dz * dz), dy);
    cameraYaw = atan2sG(dz, dx);

    if (cameraPitch > 15872) {
        cameraPitch = 15872;
    }
    if (cameraPitch < -15872) {
        cameraPitch = -15872;
    }

    cameraFocus[0] = lakituPosition[0] + cameraDist * cossG(cameraPitch) * sinsG(cameraYaw);
    cameraFocus[1] = lakituPosition[1] + cameraDist * sinsG(cameraPitch);
    cameraFocus[2] = lakituPosition[2] + cameraDist * cossG(cameraPitch) * cossG(cameraYaw);

    return atan2sG(lakituPosition[2] - cameraFocus[2], lakituPosition[0] - cameraFocus[0]);
}

__device__ bool check_in_bounds(float x, float z) {
    short xS = (short)(int)x;
    short zS = (short)(int)z;

    return (xS >= -8191 && xS <= 8192 && zS >= -8191 && zS <= 8192);
}

__device__ void check_bully_speed(float bullySpeed, int bullyAngle, float minBullyX, float maxBullyX, float minBullyZ, float maxBullyZ, int sqIdx, int strainIdx, const int minStableFrames) {
    float currentMinBullyX = minBullyX;
    float currentMaxBullyX = maxBullyX;
    float currentMinBullyZ = minBullyZ;
    float currentMaxBullyZ = maxBullyZ;

    int currentAngle = bullyAngle;

    int backwardFrames;

    for (backwardFrames = 0; backwardFrames < 65536; backwardFrames += 2) {
        float nextMinBullyX = currentMinBullyX - (bullySpeed * sinsG(currentAngle));
        float nextMaxBullyX = currentMaxBullyX - (bullySpeed * sinsG(currentAngle));
        float nextMinBullyZ = currentMinBullyZ - (bullySpeed * cossG(currentAngle));
        float nextMaxBullyZ = currentMaxBullyZ - (bullySpeed * cossG(currentAngle));

        currentAngle = (unsigned short)(int)(currentAngle - 32767.999200000002);

        float intendedMinBullyX = nextMinBullyX + (bullySpeed * sinsG(currentAngle));
        float intendedMaxBullyX = nextMaxBullyX + (bullySpeed * sinsG(currentAngle));
        float intendedMinBullyZ = nextMinBullyZ + (bullySpeed * cossG(currentAngle));
        float intendedMaxBullyZ = nextMaxBullyZ + (bullySpeed * cossG(currentAngle));

        if (intendedMinBullyX < INT_MIN ||
            intendedMinBullyX > INT_MAX ||
            intendedMinBullyZ < INT_MIN ||
            intendedMinBullyZ > INT_MAX ||
            check_in_bounds(intendedMinBullyX, intendedMinBullyZ) ||
            check_in_bounds(intendedMinBullyX, intendedMaxBullyZ) || 
            check_in_bounds(intendedMaxBullyX, intendedMinBullyZ) || 
            check_in_bounds(intendedMaxBullyX, intendedMaxBullyZ)
            ) {
            break;
        }

        nextMinBullyX = nextMinBullyX - (bullySpeed * sinsG(currentAngle));
        nextMaxBullyX = nextMaxBullyX - (bullySpeed * sinsG(currentAngle));
        nextMinBullyZ = nextMinBullyZ - (bullySpeed * cossG(currentAngle));
        nextMaxBullyZ = nextMaxBullyZ - (bullySpeed * cossG(currentAngle));

        currentAngle = (unsigned short)(int)(currentAngle - 32767.999200000002);

        intendedMinBullyX = nextMinBullyX + (bullySpeed * sinsG(currentAngle));
        intendedMaxBullyX = nextMaxBullyX + (bullySpeed * sinsG(currentAngle));
        intendedMinBullyZ = nextMinBullyZ + (bullySpeed * cossG(currentAngle));
        intendedMaxBullyZ = nextMaxBullyZ + (bullySpeed * cossG(currentAngle));

        if (intendedMinBullyX < INT_MIN ||
            intendedMinBullyX > INT_MAX ||
            intendedMinBullyZ < INT_MIN ||
            intendedMinBullyZ > INT_MAX ||
            check_in_bounds(intendedMinBullyX, intendedMinBullyZ) ||
            check_in_bounds(intendedMinBullyX, intendedMaxBullyZ) ||
            check_in_bounds(intendedMaxBullyX, intendedMinBullyZ) ||
            check_in_bounds(intendedMaxBullyX, intendedMaxBullyZ)
            ) {
            break;
        }

        nextMinBullyX = fmaxf(nextMinBullyX, minBullyX);
        nextMaxBullyX = fminf(nextMaxBullyX, maxBullyX);
        nextMinBullyZ = fmaxf(nextMinBullyZ, minBullyZ);
        nextMaxBullyZ = fminf(nextMaxBullyZ, maxBullyZ);

        if (nextMinBullyX > nextMaxBullyX || nextMinBullyZ > nextMaxBullyZ) {
            break;
        }

        currentMinBullyX = nextMinBullyX;
        currentMaxBullyX = nextMaxBullyX;
        currentMinBullyZ = nextMinBullyZ;
        currentMaxBullyZ = nextMaxBullyZ;
    }

    if (backwardFrames >= minStableFrames) {
        int solIdx = atomicAdd(&nCollisionSetups, 1);

        if (solIdx < MAX_COLLISION_SETUPS) {
            struct CollisionSetup* setup = &(collisionSetups[solIdx]);
            setup->strainSetupIdx = strainIdx;
            setup->bullyZoneIdx = sqIdx;
            setup->bullyAngle = bullyAngle;
            setup->bullySpeed = bullySpeed;
            setup->framesStable = backwardFrames;
            setup->minBullyX = currentMinBullyX;
            setup->maxBullyX = currentMaxBullyX;
            setup->minBullyZ = currentMinBullyZ;
            setup->maxBullyZ = currentMaxBullyZ;
        }
    }
}

__device__ float simulate_bully_collision(float marioVelX, float marioVelZ, int marioAngle, float bullySpeed, int bullyAngle, float xDist, float zDist) {
    const float conversionRatio = 73.0f * 3 / 53;

    float bullyVelX = bullySpeed * sinsG(bullyAngle);
    float bullyVelZ = bullySpeed * cossG(bullyAngle);

    float projectedV1 = (xDist * marioVelX + zDist * marioVelZ) / (xDist * xDist + zDist * zDist);
    float projectedV2 = (-xDist * bullyVelX - zDist * bullyVelZ) / (xDist * xDist + zDist * zDist);

    marioVelX += -projectedV1 * xDist + conversionRatio * projectedV2 * -xDist;
    marioVelZ += -projectedV1 * zDist + conversionRatio * projectedV2 * -zDist;

    short newMarioYaw = atan2sG(marioVelZ, marioVelX);
    short marioDYaw = newMarioYaw - marioAngle;

    float marioSpeed = sqrtf(marioVelX * marioVelX + marioVelZ * marioVelZ);

    if (marioDYaw < -0x4000 || marioDYaw > 0x4000) {
        marioSpeed *= -1.0f;
    }

    return marioSpeed;
}

__global__ void find_collisions(int slideYaw, struct MiniSquishCancelSetup* sqSetupsGPU, int nZones, const float maxBullySpeed, const int minStableFrames) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    int sqIdx = idx % nZones;
    int strainIdx = idx / nZones;

    if (strainIdx < min(nStrainSetups, MAX_STRAIN_SETUPS)) {
        MiniSquishCancelSetup* sqSetup = &(sqSetupsGPU[sqIdx]);
        StrainSetup* strainSetup = &(strainSetups[strainIdx]);
        SlideSetup* slideSetup = &(slidingSetups[strainSetup->slideSetupIdx]);

        const float conversionRatio = 73.0f * 3 / 53;

        const float bullyPushDist = 115.0f;

        float testBullyX = fabs(sqSetup->minBullyX) > fabs(sqSetup->maxBullyX) ? sqSetup->minBullyX : sqSetup->maxBullyX;
        float testBullyZ = fabs(sqSetup->minBullyZ) > fabs(sqSetup->maxBullyZ) ? sqSetup->minBullyZ : sqSetup->maxBullyZ;

        float testMarioX = testBullyX + bullyPushDist * sinsG(sqSetup->pushAngle);
        float testMarioZ = testBullyZ + bullyPushDist * cossG(sqSetup->pushAngle);

        float xDist = testBullyX - testMarioX;
        float zDist = testBullyZ - testMarioZ;

        float a = (xDist * xDist + zDist * zDist);

        float marioVelX = strainSetup->postStrainSpeed * sinsG(slideYaw);
        float marioVelZ = strainSetup->postStrainSpeed * cossG(slideYaw);

        float projectedV1 = (xDist * marioVelX + zDist * marioVelZ) / a;

        float b = -(marioVelX * xDist + marioVelZ * zDist);
        float c = marioVelX * marioVelX + marioVelZ * marioVelZ - slideSetup->forwardVel * slideSetup->forwardVel;
        
        float dis = b * b - 4.0f * a * c;

        if (dis >= 0.0f) {
            for (int i = 0; i < 2; i++) {
                float sign = (i * 2) - 1;
                float f = (-b + sign * sqrtf(dis)) / (2.0f * a);

                float newMarioVelX = marioVelX - f * xDist;
                float newMarioVelZ = marioVelZ - f * zDist;

                short newMarioYaw = atan2sG(newMarioVelZ, newMarioVelX);
                short marioDYaw = newMarioYaw - (short)slideYaw;

                if (marioDYaw >= -0x4000 && marioDYaw <= 0x4000) {
                    float projectedV2 = (f - projectedV1) / conversionRatio;

                    float cosMaxAngleDiff = fabs(-bullyPushDist * (projectedV2 / maxBullySpeed));
                    
                    if (cosMaxAngleDiff < 1.0f) {
                        float maxAngleDiff = 32768.0f * acos(cosMaxAngleDiff) / M_PI;

                        for (int bullyAngleDiff = 0; bullyAngleDiff < maxAngleDiff; bullyAngleDiff += 16) {
                            for (int j = 0; j < 4; j++) {
                                int bullyAngle;

                                if (j % 2 == 0) {
                                    bullyAngle = 0;
                                }
                                else {
                                    bullyAngle = 32768;
                                }

                                if (j / 2 == 0) {
                                    bullyAngle = (unsigned short)(bullyAngle - bullyAngleDiff);
                                }
                                else {
                                    bullyAngle = (unsigned short)(bullyAngle + bullyAngleDiff);
                                }

                                float estimatedSpeed = projectedV2 / ((-xDist * sinsG(bullyAngle) - zDist * cossG(bullyAngle)) / a);
                                estimatedSpeed = sign(estimatedSpeed) * fminf(fabsf(estimatedSpeed), maxBullySpeed);

                                float marioCollisionSpeed = simulate_bully_collision(marioVelX, marioVelZ, slideYaw, estimatedSpeed, bullyAngle, xDist, zDist);

                                if (marioCollisionSpeed == slideSetup->forwardVel) {
                                    check_bully_speed(estimatedSpeed, bullyAngle, sqSetup->minBullyX, sqSetup->maxBullyX, sqSetup->minBullyZ, sqSetup->maxBullyZ, sqIdx, strainIdx, minStableFrames);
                                }

                                int searchDir = sign(estimatedSpeed);

                                float testSpeed = estimatedSpeed;
                                float testCollisionSpeed = marioCollisionSpeed;

                                while (fabs(testSpeed) < maxBullySpeed && testCollisionSpeed >= slideSetup->forwardVel) {
                                    testSpeed = nextafterf(testSpeed, -INFINITY * searchDir);
                                    testCollisionSpeed = simulate_bully_collision(marioVelX, marioVelZ, slideYaw, testSpeed, bullyAngle, xDist, zDist);

                                    if (testCollisionSpeed == slideSetup->forwardVel) {
                                        check_bully_speed(testCollisionSpeed, bullyAngle, sqSetup->minBullyX, sqSetup->maxBullyX, sqSetup->minBullyZ, sqSetup->maxBullyZ, sqIdx, strainIdx, minStableFrames);
                                    }
                                }

                                testSpeed = estimatedSpeed;
                                testCollisionSpeed = marioCollisionSpeed;

                                while (fabs(testSpeed) < maxBullySpeed && testCollisionSpeed <= slideSetup->forwardVel) {
                                    testSpeed = nextafterf(testSpeed, INFINITY * searchDir);
                                    testCollisionSpeed = simulate_bully_collision(marioVelX, marioVelZ, slideYaw, testSpeed, bullyAngle, xDist, zDist);

                                    if (testCollisionSpeed == slideSetup->forwardVel) {
                                        check_bully_speed(testCollisionSpeed, bullyAngle, sqSetup->minBullyX, sqSetup->maxBullyX, sqSetup->minBullyZ, sqSetup->maxBullyZ, sqIdx, strainIdx, minStableFrames);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

__device__ int find_closest_strain_speedG(float strainVel, int cameraIdx) {
    int lower = 0;
    int upper = nStrainNodes[cameraIdx];

    while (lower < upper - 1) {
        int mid = (upper + lower) / 2;

        if (strainLookup[cameraIdx][mid].strainSpeed < strainVel) {
            lower = mid;
        }
        else if (strainLookup[cameraIdx][mid].strainSpeed > strainVel) {
            upper = mid;
        }
        else {
            return mid;
        }
    }

    float diff1 = fabs(strainVel - strainLookup[cameraIdx][lower].strainSpeed);
    float diff2 = fabs(strainVel - strainLookup[cameraIdx][upper].strainSpeed);

    if (diff1 < diff2) {
        return lower;
    }
    else {
        return upper;
    }
}

__global__ void find_strainG(int facingAngle, float maxFVel, Polygon* ch, int baseCameraYaw) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(nSlidingSetups, MAX_SLIDE_SETUPS)) {
        SlideSetup* slidingSetup = &(slidingSetups[idx]);

        float xVel = slidingSetup->xVel;
        float zVel = slidingSetup->zVel;

        int gridSize = 5;
        float maxStrainVel = 10.0f;

        double norm = (double)sinsG(facingAngle) * (double)sinsG(facingAngle) + (double)cossG(facingAngle) * (double)cossG(facingAngle);
        float forwardVel = ((double)xVel * sinsG(facingAngle) + (double)zVel * cossG(facingAngle)) / norm;
        float strainVel = ((double)xVel * cossG(facingAngle) - (double)zVel * sinsG(facingAngle)) / norm;

        if (fabsf(forwardVel) <= maxFVel && fabsf(strainVel) <= maxStrainVel) {
            float minStrainVel = strainVel;
            float maxStrainVel = strainVel;
            float minForwardVel = forwardVel;
            float maxForwardVel = forwardVel;

            for (int i = 0; i < gridSize; i++) {
                minStrainVel = nextafterf(minStrainVel, -INFINITY);
                maxStrainVel = nextafterf(maxStrainVel, INFINITY);
                minForwardVel = nextafterf(minForwardVel, -INFINITY);
                maxForwardVel = nextafterf(maxForwardVel, INFINITY);
            }

            int minStrainCameraYaw = 0;
            int maxStrainCameraYaw = 0;

            float testPos[3] = { ch->p->x - xVel, -3000.0f, ch->p->z - zVel };
            int refCameraYaw = (unsigned short)calculate_camera_yawG(testPos, lakituPositionG, baseCameraYaw, facingAngle, -3071.0f);

            Point* p = ch->p;

            for (int i = 0; i < ch->nPoints; i++) {
                for (int j = 0; j < 4; j++) {
                    float originalSpeed;
                    float strainingSpeed;

                    if (j == 0) {
                        originalSpeed = maxForwardVel - 1.5f;
                        originalSpeed = originalSpeed + sign(originalSpeed) * 0.35f;
                        strainingSpeed = 0.0f;
                    }
                    else if (j == 1) {
                        originalSpeed = maxForwardVel + 1.5f;
                        originalSpeed = originalSpeed + sign(originalSpeed) * 0.35f;
                        strainingSpeed = 0.0f;
                    }
                    else if (j == 2) {
                        originalSpeed = maxForwardVel;
                        originalSpeed = originalSpeed + sign(originalSpeed) * 0.35f;
                        strainingSpeed = 10.0f;
                    }
                    else {
                        originalSpeed = maxForwardVel;
                        originalSpeed = originalSpeed + sign(originalSpeed) * 0.35f;
                        strainingSpeed = -10.0f;
                    }

                    float xOffset = originalSpeed * sinsG(facingAngle);
                    float zOffset = originalSpeed * cossG(facingAngle);

                    xOffset += strainingSpeed * cossG(facingAngle);
                    zOffset -= strainingSpeed * sinsG(facingAngle);

                    testPos[0] = p->x - xVel - xOffset;
                    testPos[2] = p->z - zVel - zOffset;

                    int cameraYaw = calculate_camera_yawG(testPos, lakituPositionG, baseCameraYaw, facingAngle, -3071.0f);
                    cameraYaw = (short)(cameraYaw - refCameraYaw);

                    minStrainCameraYaw = min(minStrainCameraYaw, cameraYaw);
                    maxStrainCameraYaw = max(maxStrainCameraYaw, cameraYaw);
                    p = p->next;
                }
            }

            int minCameraIdx = revAtansG(minStrainCameraYaw + refCameraYaw);
            int maxCameraIdx = revAtansG(maxStrainCameraYaw + refCameraYaw);

            if (minCameraIdx > maxCameraIdx) {
                maxCameraIdx += 8192;
            }

            for (int h = minCameraIdx; h <= maxCameraIdx; h++) {
                int strainCameraYaw = (unsigned short)gArctanTableG[h % 8192];

                if (validCameraAngleG[strainCameraYaw]) {
                    int minIdx = find_closest_strain_speedG(minStrainVel, h % 8192);

                    if (strainLookup[h % 8192][minIdx].strainSpeed < minStrainVel) {
                        minIdx++;
                    }

                    int maxIdx = find_closest_strain_speedG(maxStrainVel, h % 8192);

                    if (strainLookup[h % 8192][maxIdx].strainSpeed > maxStrainVel) {
                        maxIdx--;
                    }

                    for (int i = minIdx; i <= maxIdx; i++) {
                        for (float f = minForwardVel; f <= maxForwardVel; f = nextafterf(f, INFINITY)) {
                            float xVel1 = f * sinsG(facingAngle);
                            float zVel1 = f * cossG(facingAngle);

                            xVel1 += strainLookup[h % 8192][i].strainSpeed * cossG(facingAngle);
                            zVel1 -= strainLookup[h % 8192][i].strainSpeed * sinsG(facingAngle);

                            if (xVel == xVel1 && zVel == zVel1) {
                                float originalSpeed = f - strainLookup[h % 8192][i].addedSpeed;
                                originalSpeed = originalSpeed + sign(originalSpeed) * 0.35f;

                                if (originalSpeed - (sign(originalSpeed) * 0.35f) + strainLookup[h % 8192][i].addedSpeed == f) {
                                    int solIdx = atomicAdd(&nStrainSetups, 1);

                                    if (solIdx < MAX_STRAIN_SETUPS) {
                                        struct StrainSetup* setup = &(strainSetups[solIdx]);
                                        setup->slideSetupIdx = idx;
                                        setup->strainStickX = strainLookup[h % 8192][i].data.x;
                                        setup->strainStickY = strainLookup[h % 8192][i].data.y;
                                        setup->preStrainSpeed = originalSpeed;
                                        setup->postStrainSpeed = f;
                                        setup->cameraYaw = strainCameraYaw;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

__device__ void compute_slideG(float xVel1, float zVel1, float& xVel2, float& zVel2, float mag, int intendedDYaw, int slopeAngle, float accel, float steepness) {
    xVel2 = xVel1;
    zVel2 = zVel1;

    float oldSpeed3 = sqrtf(xVel2 * xVel2 + zVel2 * zVel2);

    xVel2 += zVel2 * (mag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
    zVel2 -= xVel2 * (mag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

    float newSpeed3 = sqrtf(xVel2 * xVel2 + zVel2 * zVel2);

    xVel2 = xVel2 * oldSpeed3 / newSpeed3;
    zVel2 = zVel2 * oldSpeed3 / newSpeed3;

    xVel2 += accel * steepness * sinsG(slopeAngle);
    zVel2 += accel * steepness * cossG(slopeAngle);
}

__device__ void get_estimate_sliding_speedsG(float xVel, float zVel, float& xVel1, float& zVel1, float mag, int intendedDYaw, int slopeAngle, float accel, float steepness) {
    xVel1 = xVel;
    zVel1 = zVel;

    xVel1 -= accel * steepness * sinsG(slopeAngle);
    zVel1 -= accel * steepness * cossG(slopeAngle);

    float newSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    zVel1 += xVel1 * (mag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
    xVel1 -= zVel1 * (mag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

    float oldSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    xVel1 = xVel1 * newSpeed / oldSpeed;
    zVel1 = zVel1 * newSpeed / oldSpeed;
}

void get_estimate_sliding_speeds(float xVel, float zVel, float& xVel1, float& zVel1, float mag, int intendedDYaw, int slopeAngle, float accel, float steepness) {
    xVel1 = xVel;
    zVel1 = zVel;

    xVel1 -= accel * steepness * sins(slopeAngle);
    zVel1 -= accel * steepness * coss(slopeAngle);

    float newSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    zVel1 += xVel1 * (mag / 32.0f) * sins(intendedDYaw) * 0.05f;
    xVel1 -= zVel1 * (mag / 32.0f) * sins(intendedDYaw) * 0.05f;

    float oldSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    xVel1 = xVel1 * newSpeed / oldSpeed;
    zVel1 = zVel1 * newSpeed / oldSpeed;
}

__device__ void find_sliding_speedsG(float forwardVel, float xVel, float zVel, float xVel1, float zVel1, float mag, int intendedDYaw, int slopeAngle, float accel, float steepness) {
    int blockSize = 5;

    for (int i = 0; i < blockSize; i++) {
        xVel1 = nextafter(xVel1, -INFINITY);
        zVel1 = nextafter(zVel1, -INFINITY);
    }

    float xVel2;
    float zVel2;

    for (int x = -blockSize; x <= blockSize; x++) {
        float zVel1a = zVel1;

        for (int z = -blockSize; z <= blockSize; z++) {
            compute_slideG(xVel1, zVel1a, xVel2, zVel2, mag, intendedDYaw, slopeAngle, accel, steepness);

            if (xVel2 == xVel && zVel2 == zVel) {
                int idx = atomicAdd(&nSlidingSetups, 1);

                if (idx < MAX_SLIDE_SETUPS) {
                    SlideSetup* setup = &(slidingSetups[idx]);
                    setup->forwardVel = forwardVel;
                    setup->xVel = xVel1;
                    setup->zVel = zVel1a;
                }
            }

            zVel1a = nextafter(zVel1a, INFINITY);
        }

        xVel1 = nextafter(xVel1, INFINITY);
    }
}

__device__ void get_vel_rangesG(float& minXVel, float& maxXVel, float& minZVel, float& maxZVel, float mag, int intendedDYaw, float forwardVel, float finalXVel, float finalZVel) {
    float forward = cossG(intendedDYaw);
    forward *= 0.5f + 0.5f * forwardVel / 100.0f;
    float lossFactor = mag / 32.0f * forward * 0.02f + 0.92f;

    minXVel = finalXVel / lossFactor;

    while (minXVel * lossFactor > finalXVel) {
        minXVel = nextafter(minXVel, INFINITY);
    }

    while (nextafter(minXVel, -INFINITY) * lossFactor <= finalXVel) {
        minXVel = nextafter(minXVel, -INFINITY);
    }

    maxXVel = finalXVel / lossFactor;

    while (maxXVel * lossFactor < finalXVel) {
        maxXVel = nextafter(maxXVel, -INFINITY);
    }

    while (nextafter(maxXVel, INFINITY) * lossFactor >= finalXVel) {
        maxXVel = nextafter(maxXVel, INFINITY);
    }

    minZVel = finalZVel / lossFactor;

    while (minZVel * lossFactor > finalZVel) {
        minZVel = nextafter(minZVel, INFINITY);
    }

    while (nextafter(minZVel, -INFINITY) * lossFactor <= finalZVel) {
        minZVel = nextafter(minZVel, -INFINITY);
    }

    maxZVel = finalZVel / lossFactor;

    while (maxZVel * lossFactor < finalZVel) {
        maxZVel = nextafter(maxZVel, -INFINITY);
    }

    while (nextafter(maxZVel, INFINITY) * lossFactor >= finalZVel) {
        maxZVel = nextafter(maxZVel, INFINITY);
    }
}

void get_vel_ranges(float& minXVel, float& maxXVel, float& minZVel, float& maxZVel, float mag, int intendedDYaw, float forwardVel, float finalXVel, float finalZVel) {
    float forward = coss(intendedDYaw);
    forward *= 0.5f + 0.5f * forwardVel / 100.0f;
    float lossFactor = mag / 32.0f * forward * 0.02f + 0.92f;

    minXVel = finalXVel / lossFactor;

    while (minXVel * lossFactor > finalXVel) {
        minXVel = nextafter(minXVel, INFINITY);
    }

    while (nextafter(minXVel, -INFINITY) * lossFactor <= finalXVel) {
        minXVel = nextafter(minXVel, -INFINITY);
    }

    maxXVel = finalXVel / lossFactor;

    while (maxXVel * lossFactor < finalXVel) {
        maxXVel = nextafter(maxXVel, -INFINITY);
    }

    while (nextafter(maxXVel, INFINITY) * lossFactor >= finalXVel) {
        maxXVel = nextafter(maxXVel, INFINITY);
    }

    minZVel = finalZVel / lossFactor;

    while (minZVel * lossFactor > finalZVel) {
        minZVel = nextafter(minZVel, INFINITY);
    }

    while (nextafter(minZVel, -INFINITY) * lossFactor <= finalZVel) {
        minZVel = nextafter(minZVel, -INFINITY);
    }

    maxZVel = finalZVel / lossFactor;

    while (maxZVel * lossFactor < finalZVel) {
        maxZVel = nextafter(maxZVel, -INFINITY);
    }

    while (nextafter(maxZVel, INFINITY) * lossFactor >= finalZVel) {
        maxZVel = nextafter(maxZVel, INFINITY);
    }
}

float find_boundary(float minValue, float maxValue, float target, float yNormal, float vel, int dir) {
    while (nextafterf(minValue, INFINITY) < maxValue) {
        float midValue = fmaxf(nextafterf(minValue, INFINITY), (minValue + maxValue) / 2.0f);

        float pos = midValue;

        for (int i = 0; i < 4; i++) {
            pos = pos + yNormal * (vel / 4.0f);
        }

        if (pos < target) {
            minValue = midValue;
        }
        else if (pos > target) {
            maxValue = midValue;
        }
        else if (dir > 0) {
            minValue = midValue;
        }
        else {
            maxValue = midValue;
        }
    }

    if (dir > 0) {
        return minValue;
    }
    else {
        return maxValue;
    }
}

void create_polygon(bool* grid, float minX, float maxX, float minZ, float maxZ, struct Polygon* poly) {
    int minXI = (int)minX;
    int maxXI = (int)maxX;
    int minZI = (int)minZ;
    int maxZI = (int)maxZ;

    bool foundSquare = false;

    int x;
    int z;

    for (x = minXI; x <= maxXI; x++) {
        for (z = minZI; z <= maxZI; z++) {
            if (grid[(z - minZI) * (maxXI - minXI + 1) + x - minXI]) {
                foundSquare = true;
                break;
            }
        }

        if (foundSquare) {
            break;
        }
    }

    if (x <= maxXI && z <= maxZI) {
        x = x - (x <= 0);
        z = z - (z <= 0);

        struct Point* p = (struct Point*)std::malloc(sizeof(struct Point));
        p->x = x + (x <= 0) == minXI ? minX : x;
        p->z = z + (z <= 0) == minZI ? minZ : z;
        poly->p = p;
        poly->nPoints = 1;

        int x1 = x;
        int z1 = z;

        int dirX = 1;
        int dirZ = 0;

        int loopCount = 0;

        while (x1 + dirX != x || z1 + dirZ != z) {
            x1 = x1 + dirX;
            z1 = z1 + dirZ;

            int offsetX = (dirZ - dirX + 1) / 2;
            int offsetZ = (1 - dirX - dirZ) / 2;

            int temp = dirX;
            dirX = dirZ;
            dirZ = -temp;

            int gridX = x1 + (x1 <= 0) + dirX - offsetX - minXI;
            int gridZ = z1 + (z1 <= 0) + dirZ - offsetZ - minZI;

            int idx = gridZ * (maxXI - minXI + 1) + gridX;

            if (gridX >= 0 && gridX <= (maxXI - minXI) && gridZ >= 0 && gridZ <= (maxZI - minZI) && grid[idx]) {
                struct Point* p1 = (struct Point*)std::malloc(sizeof(struct Point));
                p1->x = x1 + (x1 <= 0) == minXI ? minX : (x1 == maxXI + (x1 >= 0) ? maxX : x1);
                p1->z = z1 + (z1 <= 0) == minZI ? minZ : (z1 == maxZI + (z1 >= 0) ? maxZ : z1);
                p->next = p1;
                p1->prev = p;
                p = p1;
                poly->nPoints++;
            }
            else {
                temp = dirX;
                dirX = -dirZ;
                dirZ = temp;

                gridX = x1 + (x1 <= 0) - offsetX - minXI;
                gridZ = z1 + (z1 <= 0) - offsetZ - minZI;

                int idx = gridZ * (maxXI - minXI + 1) + gridX;

                if (!(gridX >= 0 && gridX <= (maxXI - minXI) && gridZ >= 0 && gridZ <= (maxZI - minZI) && grid[idx])) {
                    struct Point* p1 = (struct Point*)std::malloc(sizeof(struct Point));
                    p1->x = x1 + (x1 <= 0) == minXI ? minX : (x1 == maxXI + (x1 >= 0) ? maxX : x1);
                    p1->z = z1 + (z1 <= 0) == minZI ? minZ : (z1 == maxZI + (z1 >= 0) ? maxZ : z1);
                    p->next = p1;
                    p1->prev = p;
                    p = p1;
                    poly->nPoints++;

                    temp = dirX;
                    dirX = -dirZ;
                    dirZ = temp;
                }
            }
            loopCount++;
        }

        p->next = poly->p;
        poly->p->prev = p;
    }
}

void free_polygon(struct Polygon* poly) {
    struct Point* point = poly->p;

    for (int i = 0; i < poly->nPoints; i++) {
        struct Point* nextPoint = point->next;
        std::free(point);
        point = nextPoint;
    }

    poly->p = NULL;
    poly->nPoints = 0;
}

void free_polygonG(struct Polygon* polyGPU) {
    struct Polygon* polyCPU = (struct Polygon*)std::malloc(sizeof(struct Polygon));
    struct Point* pointCPU = (struct Point*)std::malloc(sizeof(struct Point));

    cudaMemcpy(polyCPU, polyGPU, sizeof(struct Polygon), cudaMemcpyDeviceToHost);
    struct Point* point = polyCPU->p;

    for (int i = 0; i < polyCPU->nPoints; i++) {
        cudaMemcpy(pointCPU, point, sizeof(struct Point), cudaMemcpyDeviceToHost);
        cudaFree(point);
        point = pointCPU->next;
    }

    std::free(polyCPU);
    std::free(pointCPU);
}

bool point_in_polygon(Vec3f point, struct Polygon* poly) {
    int intersectCount = 0;

    Point* p = poly->p;

    for (int i = 0; i < poly->nPoints; i++) {
        if (((int)p->x == point[0] && (int)p->z == point[2]) ||
            ((int)p->x == point[0] && (int)p->next->x == point[0] &&
                (((int)p->z < point[2] && (int)p->next->z > point[2]) ||
                    ((int)p->z > point[2] && (int)p->next->z < point[2]))) ||
            ((int)p->z == point[2] && (int)p->next->z == point[2] &&
                (((int)p->x < point[0] && (int)p->next->x > point[0]) ||
                    ((int)p->x > point[0] && (int)p->next->x < point[0]))))
        {
            return true;
        }

        if ((((int)p->x < point[0] && (int)p->next->x >= point[0]) || ((int)p->x >= point[0] && (int)p->next->x < point[0])) && (int)p->z >= point[2]) {
            intersectCount++;
        }

        p = p->next;
    }

    return (intersectCount % 2) == 1;
}

void update_polygon(struct Polygon* poly, Platform* plat) {
    float minX = INFINITY;
    float maxX = -INFINITY;
    float minZ = INFINITY;
    float maxZ = -INFINITY;

    struct Point* p = poly->p;

    for (int i = 0; i < poly->nPoints; i++) {
        minX = fminf(minX, p->x);
        maxX = fmaxf(maxX, p->x);
        minZ = fminf(minZ, p->z);
        maxZ = fmaxf(maxZ, p->z);

        p = p->next;
    }

    int minXI = (int)minX;
    int maxXI = (int)maxX;
    int minZI = (int)minZ;
    int maxZI = (int)maxZ;

    bool* grid = (bool*)std::malloc((maxXI - minXI + 1) * (maxZI - minZI + 1) * sizeof(bool));

    for (int x = minXI; x <= maxXI; x++) {
        for (int z = minZI; z <= maxZI; z++) {
            Vec3f squarePos = { (float)x, 0.0f, (float)z };
            float fHeight;
            grid[(z - minZI) * (maxXI - minXI + 1) + x - minXI] = find_floor(squarePos, plat->triangles, &fHeight);
        }
    }

    free_polygon(poly);
    create_polygon(grid, minX, maxX, minZ, maxZ, poly);

    std::free(grid);
}

void copy_polygon(struct Polygon* src, struct Polygon* dst) {
    dst->nPoints = src->nPoints;

    if (src->nPoints > 0) {
        struct Point* p = src->p;
        struct Point* p1 = (struct Point*)std::malloc(sizeof(struct Point));
        dst->p = p1;
        p1->x = p->x;
        p1->z = p->z;

        for (int i = 1; i < src->nPoints; i++) {
            p = p->next;
            struct Point* p2 = (struct Point*)std::malloc(sizeof(struct Point));
            p2->x = p->x;
            p2->z = p->z;
            p1->next = p2;
            p2->prev = p1;
            p1 = p2;
        }

        p1->next = dst->p;
        dst->p->prev = p1;
    }
}

void copy_polygon_to_gpu(struct Polygon* polyCPU, struct Polygon*& polyGPU) {
    struct Point* p = polyCPU->p;

    struct Point* firstG;
    cudaMalloc(&firstG, sizeof(struct Point));

    struct Point* pG0 = firstG;
    struct Point* pG1;
    cudaMalloc(&pG1, sizeof(struct Point));

    struct Point first;

    first.x = p->x;
    first.z = p->z;
    first.next = pG1;

    p = p->next;
    Point temp;

    for (int k = 1; k < polyCPU->nPoints; k++) {
        temp.x = p->x;
        temp.z = p->z;
        temp.prev = pG0;
        pG0 = pG1;

        if (k == polyCPU->nPoints - 1) {
            temp.next = firstG;
        }
        else {
            cudaMalloc(&pG1, sizeof(struct Point));
            temp.next = pG1;
        }

        cudaMemcpy(pG0, &temp, sizeof(struct Point), cudaMemcpyHostToDevice);
        p = p->next;
    }

    first.prev = pG0;

    cudaMemcpy(firstG, &first, sizeof(struct Point), cudaMemcpyHostToDevice);

    struct Polygon tempPoly;
    tempPoly.nPoints = polyCPU->nPoints;
    tempPoly.p = firstG;

    cudaMalloc((void**)&polyGPU, sizeof(struct Polygon));
    cudaMemcpy(polyGPU, &tempPoly, sizeof(struct Polygon), cudaMemcpyHostToDevice);
}

void cut_polygon_on_line(struct Polygon* polygon, float lineX, float lineZ, float x0, float z0, int dir) {
    struct Point* p = polygon->p;
    struct Point* p0 = (dir > 0) ? p->prev : p->next;

    double minS = INFINITY;
    int startIdx = -1;

    double* t = (double*)malloc(polygon->nPoints * sizeof(double));

    for (int i = 0; i < polygon->nPoints; i++) {
        float xDiff = p->x - p0->x;
        float zDiff = p->z - p0->z;

        t[i] = (lineZ * (x0 - p0->x) - lineX * (z0 - p0->z)) / (xDiff * lineZ - zDiff * lineX);

        if (t[i] >= 0.0 && t[i] < 1.0) {
            double s = (zDiff * (x0 - p0->x) - xDiff * (z0 - p0->z)) / (xDiff * lineZ - zDiff * lineX);
            if (s < minS) {
                minS = s;
                startIdx = i;
            }
        }

        p0 = p;
        p = (dir > 0) ? p->next : p->prev;
    }

    if (startIdx >= 0) {
        for (int i = 0; i < startIdx; i++) {
            p0 = p;
            p = (dir > 0) ? p->next : p->prev;
        }

        bool delMode = false;
        Point* p1 = NULL;
        int newNPoints = polygon->nPoints;

        for (int i = 0; i < polygon->nPoints; i++) {
            int idx = (startIdx + i) % polygon->nPoints;

            float xDiff = p->x - p0->x;
            float zDiff = p->z - p0->z;
            double tTest = (lineZ * (x0 - p0->x) - lineX * (z0 - p0->z)) / (xDiff * lineZ - zDiff * lineX);

            if (t[idx] >= 0.0 && t[idx] < 1.0) {
                if (delMode) {
                    if (t[idx] > 0.0) {
                        Point* p2 = (struct Point*)std::malloc(sizeof(struct Point));
                        p2->x = t[idx] * (p->x - p0->x) + p0->x;
                        p2->z = t[idx] * (p->z - p0->z) + p0->z;

                        if (dir > 0) {
                            p1->next = p2;
                            p2->prev = p1;
                            p->prev = p2;
                            p2->next = p;
                        }
                        else {
                            p1->prev = p2;
                            p2->next = p1;
                            p->next = p2;
                            p2->prev = p;
                        }

                        newNPoints++;
                    }
                    else {
                        if (dir > 0) {
                            p->prev = p1;
                            p1->next = p;
                        }
                        else {
                            p->next = p1;
                            p1->prev = p;
                        }
                    }

                    std::free(p0);
                    newNPoints--;

                    delMode = false;
                }
                else {
                    if (t[idx] > 0.0) {
                        p1 = (struct Point*)std::malloc(sizeof(struct Point));
                        p1->x = t[idx] * (p->x - p0->x) + p0->x;
                        p1->z = t[idx] * (p->z - p0->z) + p0->z;

                        if (dir > 0) {
                            p0->next = p1;
                            p1->prev = p0;
                        }
                        else {
                            p0->prev = p1;
                            p1->next = p0;
                        }

                        newNPoints++;
                    }
                    else {
                        p1 = p0;
                    }

                    delMode = true;
                }
            }
            else if (delMode) {
                std::free(p0);
                newNPoints--;
            }

            p0 = p;
            p = (dir > 0) ? p->next : p->prev;
        }

        polygon->p = p;
        polygon->nPoints = newNPoints;
    }

    std::free(t);
}

void print_polygon(struct Polygon* polygon) {
    struct Point* p = polygon->p;

    for (int j = 0; j < polygon->nPoints; j++) {
        if (j > 0) {
            printf(", ");
        }
        printf("(%.10g, %.10g)", p->x, p->z);
        p = p->next;
    }
    printf("\n");
}

bool find_start_polygon(Vec3f targetPosition, float xVel, float zVel, float yNormal, Vec2S floors1, Vec2S floors2, Polygon* p) {
    bool validPoly = false;

    float minX = nextafterf(targetPosition[0], -INFINITY) - yNormal * xVel;
    float maxX = nextafterf(targetPosition[0], INFINITY) - yNormal * xVel;
    float minZ = nextafterf(targetPosition[2], -INFINITY) - yNormal * zVel;
    float maxZ = nextafterf(targetPosition[2], INFINITY) - yNormal * zVel;

    minX = find_boundary(minX, maxX, targetPosition[0], yNormal, xVel, -1);
    maxX = find_boundary(minX, maxX, targetPosition[0], yNormal, xVel, 1);
    minZ = find_boundary(minZ, maxZ, targetPosition[2], yNormal, zVel, -1);
    maxZ = find_boundary(minZ, maxZ, targetPosition[2], yNormal, zVel, 1);

    int minXI = (int)minX;
    int maxXI = (int)maxX;
    int minZI = (int)minZ;
    int maxZI = (int)maxZ;

    bool* grid = (bool*)std::malloc((maxXI - minXI + 1) * (maxZI - minZI + 1) * sizeof(bool));

    for (int x = minXI; x <= maxXI; x++) {
        for (int z = minZI; z <= maxZI; z++) {
            Vec3f squarePos = { (float)x, 0.0f, (float)z };
            float fHeight;
            const Surface* f1 = find_floor(squarePos, floors1, &fHeight);
            const Surface* f2 = find_floor(squarePos, floors2, &fHeight);

            grid[(z - minZI) * (maxXI - minXI + 1) + x - minXI] = (!f1 && f2);

            if (!f1 && f2) {
                validPoly = true;
            }
        }
    }

    if (validPoly) {
        create_polygon(grid, minX, maxX, minZ, maxZ, p);
    }

    std::free(grid);

    return validPoly;
}

bool search_xVel(float xVel, float zVel, float targetSpeed, Vec3f targetPosition, float yNormal, Vec2S floors1, Vec2S floors2, float* vels, Polygon* polys, int& velCount) {
    float xDir = sign(xVel);

    float speed = sqrtf(xVel * xVel + zVel * zVel);

    float minXVel = xVel;
    float maxXVel = xVel;

    float minSpeed = speed;

    if (xDir * minSpeed < xDir * targetSpeed) {
        while (xDir * minSpeed < xDir * targetSpeed) {
            minXVel = nextafterf(minXVel, INFINITY);
            minSpeed = sqrtf(minXVel * minXVel + zVel * zVel);
        }
    }
    else {
        while (xDir * minSpeed >= xDir * targetSpeed) {
            minXVel = nextafterf(minXVel, -INFINITY);
            minSpeed = sqrtf(minXVel * minXVel + zVel * zVel);
        }

        minXVel = nextafterf(minXVel, INFINITY);
    }

    float maxSpeed = speed;

    if (xDir * maxSpeed > xDir * targetSpeed) {
        while (xDir * maxSpeed > xDir * targetSpeed) {
            maxXVel = nextafterf(maxXVel, -INFINITY);
            maxSpeed = sqrtf(maxXVel * maxXVel + zVel * zVel);
        }
    }
    else {
        while (xDir * maxSpeed <= xDir * targetSpeed) {
            maxXVel = nextafterf(maxXVel, INFINITY);
            maxSpeed = sqrtf(maxXVel * maxXVel + zVel * zVel);
        }

        maxXVel = nextafterf(maxXVel, -INFINITY);
    }

    bool foundSpeed = minXVel > maxXVel;

    for (float xVel1 = minXVel; xVel1 <= maxXVel; xVel1 = nextafterf(xVel1, INFINITY)) {
        if (find_start_polygon(targetPosition, xVel1, zVel, yNormal, floors1, floors2, &(polys[velCount]))) {
            vels[2 * velCount] = xVel1;
            vels[(2 * velCount) + 1] = zVel;
            velCount++;
            foundSpeed = true;
        }
    }

    return foundSpeed;
}

void remove_duplicate_strain_speeds(struct StrainNode* strainLookupCPU, int& nStrainNodesCPU) {
    int oldLength = nStrainNodesCPU;
    nStrainNodesCPU = min(nStrainNodesCPU, 1);

    for (int i = 1; i < oldLength; i++) {
        if (strainLookupCPU[i].strainSpeed != strainLookupCPU[nStrainNodesCPU - 1].strainSpeed) {
            strainLookupCPU[nStrainNodesCPU] = strainLookupCPU[i];
            nStrainNodesCPU++;
        }
    }
}

void sort_strain_data(struct StrainNode* strainLookupCPU, int start, int length) {
    if (length > 1) {
        int pivot = start + (length / 2);
        float pivotSpeed = strainLookupCPU[pivot].strainSpeed;

        int i = start - 1;
        int j = start + length;

        int p = -1;

        while (p == -1) {
            do {
                i++;
            } while (strainLookupCPU[i].strainSpeed < pivotSpeed);

            do {
                j--;
            } while (strainLookupCPU[j].strainSpeed > pivotSpeed);

            if (i >= j) {
                p = j;
            }
            else {
                struct StrainNode temp = strainLookupCPU[i];
                strainLookupCPU[i] = strainLookupCPU[j];
                strainLookupCPU[j] = temp;
            }
        }

        if (p != start + length - 1) {
            sort_strain_data(strainLookupCPU, start, p - start + 1);
            sort_strain_data(strainLookupCPU, p + 1, start + length - p - 1);
        }
    }
}

void generate_straining_speed_lookup(struct StrainNode* strainLookupCPU, int& nStrainNodesCPU, int faceAngle, int cameraYaw) {
    nStrainNodesCPU = 0;

    for (int x = -128; x < 128; x++) {
        for (int y = -128; y < 128; y++) {
            float xS;
            if (x < 8.0f) {
                if (x > -8.0f) {
                    xS = 0.0f;
                }
                else {
                    xS = x + 6.0f;
                }
            }
            else {
                xS = x - 6.0f;
            }
            float yS;
            if (y < 8.0f) {
                if (y > -8.0f) {
                    yS = 0.0f;
                }
                else {
                    yS = y + 6.0f;
                }
            }
            else {
                yS = y - 6.0f;
            }

            int intendedYaw = (unsigned short)(atan2s(-yS, xS) + cameraYaw);

            float mag = sqrtf(xS * xS + yS * yS);

            if (mag > 64.0f) {
                xS = xS * (64.0f / mag);
                yS = yS * (64.0f / mag);
                mag = 64.0f;
            }

            mag = ((mag / 64.0f) * (mag / 64.0f)) * 32.0f;

            int intendedDYaw = (unsigned short)(intendedYaw - faceAngle);

            float intendedMag = mag / 32.0f;

            float sidewaysSpeed = intendedMag * sins(intendedDYaw) * 10.0f;
            float addedSpeed = intendedMag * coss(intendedDYaw) * 1.5f;

            strainLookupCPU[nStrainNodesCPU].data.x = x;
            strainLookupCPU[nStrainNodesCPU].data.y = y;
            strainLookupCPU[nStrainNodesCPU].data.intendedYaw = intendedYaw;
            strainLookupCPU[nStrainNodesCPU].data.mag = mag;
            strainLookupCPU[nStrainNodesCPU].addedSpeed = addedSpeed;
            strainLookupCPU[nStrainNodesCPU].strainSpeed = sidewaysSpeed;
            nStrainNodesCPU++;
        }
    }

    sort_strain_data(strainLookupCPU, 0, nStrainNodesCPU);
    remove_duplicate_strain_speeds(strainLookupCPU, nStrainNodesCPU);
}

void generate_stick_lookup(struct StickNode* stickLookup, int cameraYaw) {
    for (int i = 0; i < 4096; i++) {
        stickLookup[i].next = NULL;
    }

    for (int x = -128; x < 128; x++) {
        for (int y = -128; y < 128; y++) {
            float xS;
            if (x < 8.0f) {
                if (x > -8.0f) {
                    xS = 0.0f;
                }
                else {
                    xS = x + 6.0f;
                }
            }
            else {
                xS = x - 6.0f;
            }
            float yS;
            if (y < 8.0f) {
                if (y > -8.0f) {
                    yS = 0.0f;
                }
                else {
                    yS = y + 6.0f;
                }
            }
            else {
                yS = y - 6.0f;
            }

            int intendedYaw = (unsigned short)(atan2s(-yS, xS) + cameraYaw);

            float mag = sqrtf(xS * xS + yS * yS);

            if (mag > 64.0f) {
                xS = xS * (64.0f / mag);
                yS = yS * (64.0f / mag);
                mag = 64.0f;
            }

            mag = ((mag / 64.0f) * (mag / 64.0f)) * 32.0f;

            struct StickNode* node = &(stickLookup[intendedYaw >> 4]);

            while (node->next != NULL && node->data.mag < mag) {
                node = node->next;
            }

            if (node->next == NULL || node->data.mag != mag) {
                struct StickNode* next = (struct StickNode*)std::malloc(sizeof(struct StickNode));
                next->next = node->next;
                next->data = node->data;
                node->next = next;
                node->data.x = x;
                node->data.y = y;
                node->data.intendedYaw = intendedYaw;
                node->data.mag = mag;
            }
        }
    }
}

void free_stick_lookup(struct StickNode* stickLookup) {
    for (int i = 0; i < 4096; i++) {
        StickNode* node = stickLookup[i].next;

        while (node != NULL) {
            StickNode* oldNode = node;
            node = node->next;
            std::free(oldNode);
        }

        stickLookup[i].next = NULL;
    }
}

__global__ void try_forward_velG(const float minVel, const float maxVel, const float xVel0, const float zVel0, const float mag, const int intendedDYaw, const int slideYaw, const int slopeAngle, const float accel, const float steepness, const float maxSpeed, const float maxStrainSpeed) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int nVels = *(int*)&maxVel - *(int*)&minVel;

    if (idx < nVels) {
        int velI = *(int*)&minVel + idx;
        float vel = *(float*)&velI;

        float minXVel;
        float maxXVel;
        float minZVel;
        float maxZVel;

        get_vel_rangesG(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, vel, xVel0, zVel0);

        if (minXVel <= maxXVel && minZVel <= maxZVel) {
            float xVel = (minXVel + maxXVel) / 2.0;
            float zVel = (minZVel + maxZVel) / 2.0;

            float xVel1;
            float zVel1;

            get_estimate_sliding_speedsG(xVel, zVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

            float slidingForwardVel = xVel1 * sinsG(slideYaw) + zVel1 * cossG(slideYaw);
            float slidingStrainVel = xVel1 * cossG(slideYaw) - zVel1 * sinsG(slideYaw);

            if (fabsf(slidingForwardVel) <= maxSpeed && fabsf(slidingStrainVel) <= maxStrainSpeed) {
                find_sliding_speedsG(vel, xVel, zVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);
            }
        }
    }
}

void try_intended_yaw(int x, int y, float mag, int intendedDYaw, int slideYaw, int slideCameraYaw, float departureSpeed, float xVel0, float zVel0, int minCollisionAngle, int maxCollisionAngle, const int slopeAngle, const float accel, const float steepness, int baseCameraYaw, struct SlideSetup* slidingSetupsGPU, struct StrainSetup* strainSetupsGPU, struct CollisionSetup* collisionSetupsGPU, struct StickNode* stickLookup, struct SquishCancelSetup* sqSetups, struct MiniSquishCancelSetup* sqSetupsGPU, int nZones, const float minSpeed, const float maxSpeed, const int minStableFrames, Polygon* ch, int nThreads, ofstream& wf) {
    const float maxBullySpeed = 1000000000.0f;
    const float maxMarioSpeed = 3.0 * (73.0 / 53.0) * maxBullySpeed;

    const float maxStrainSpeed = 10.0f;

    if (coss(intendedDYaw) < 0.0) {
        const float slopeSpeed = accel * steepness;

        float minLossFactor = departureSpeed / (maxSpeed + slopeSpeed);
        float maxLossFactor = departureSpeed / fmaxf(minSpeed - slopeSpeed, 0.0f);

        float minForwardVel = -((((((minLossFactor - 0.92f) / 0.02f) / (mag / 32.0f)) / coss(intendedDYaw)) - 0.5f) * 100.0f / 0.5f);
        float maxForwardVel = -((((((maxLossFactor - 0.92f) / 0.02f) / (mag / 32.0f)) / coss(intendedDYaw)) - 0.5f) * 100.0f / 0.5f);
        maxForwardVel = fminf(maxMarioSpeed, maxForwardVel);

        float minXVel;
        float maxXVel;
        float minZVel;
        float maxZVel;

        get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, minForwardVel, xVel0, zVel0);

        float xVel1;
        float zVel1;

        get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

        float slidingForwardVel1 = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
        float slidingStrainVel1 = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

        get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, maxForwardVel, xVel0, zVel0);
        get_estimate_sliding_speeds(maxXVel, maxZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

        float slidingForwardVel2 = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
        float slidingStrainVel2 = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

        if (fminf(fabsf(slidingForwardVel1), fabsf(slidingForwardVel2)) <= maxSpeed && fminf(fabsf(slidingStrainVel1), fabsf(slidingStrainVel2)) <= maxStrainSpeed) {
            if (slidingForwardVel1 < -maxSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                minForwardVel = upperSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingForwardVelM < -maxSpeed) {
                        lowerSpeed = midSpeed;
                    }
                    else {
                        upperSpeed = midSpeed;
                        minForwardVel = midSpeed;
                        slidingForwardVel1 = slidingForwardVelM;
                        slidingStrainVel1 = slidingStrainVelM;
                    }
                }
            }

            if (slidingForwardVel2 < -maxSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                maxForwardVel = lowerSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingForwardVelM < -maxSpeed) {
                        upperSpeed = midSpeed;
                    }
                    else {
                        lowerSpeed = midSpeed;
                        maxForwardVel = midSpeed;
                        slidingForwardVel2 = slidingForwardVelM;
                        slidingStrainVel2 = slidingStrainVelM;
                    }
                }
            }

            if (slidingStrainVel1 < -maxStrainSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                minForwardVel = upperSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingStrainVelM < -maxStrainSpeed) {
                        lowerSpeed = midSpeed;
                    }
                    else {
                        upperSpeed = midSpeed;
                        minForwardVel = midSpeed;
                        slidingForwardVel1 = slidingForwardVelM;
                        slidingStrainVel1 = slidingStrainVelM;
                    }
                }
            }

            if (slidingStrainVel2 < -maxStrainSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                maxForwardVel = lowerSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingStrainVelM < -maxStrainSpeed) {
                        upperSpeed = midSpeed;
                    }
                    else {
                        lowerSpeed = midSpeed;
                        maxForwardVel = midSpeed;
                        slidingForwardVel2 = slidingForwardVelM;
                        slidingStrainVel2 = slidingStrainVelM;
                    }
                }
            }

            if (slidingForwardVel1 > maxSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                minForwardVel = upperSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingForwardVelM > maxSpeed) {
                        lowerSpeed = midSpeed;
                    }
                    else {
                        upperSpeed = midSpeed;
                        minForwardVel = midSpeed;
                        slidingForwardVel1 = slidingForwardVelM;
                        slidingStrainVel1 = slidingStrainVelM;
                    }
                }
            }

            if (slidingForwardVel2 > maxSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                maxForwardVel = lowerSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingForwardVelM > maxSpeed) {
                        upperSpeed = midSpeed;
                    }
                    else {
                        lowerSpeed = midSpeed;
                        maxForwardVel = midSpeed;
                        slidingForwardVel2 = slidingForwardVelM;
                        slidingStrainVel2 = slidingStrainVelM;
                    }
                }
            }

            if (slidingStrainVel1 > maxStrainSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                minForwardVel = upperSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingStrainVelM > maxStrainSpeed) {
                        lowerSpeed = midSpeed;
                    }
                    else {
                        upperSpeed = midSpeed;
                        minForwardVel = midSpeed;
                        slidingForwardVel1 = slidingForwardVelM;
                        slidingStrainVel1 = slidingStrainVelM;
                    }
                }
            }

            if (slidingStrainVel2 > maxStrainSpeed) {
                float lowerSpeed = minForwardVel;
                float upperSpeed = maxForwardVel;

                maxForwardVel = lowerSpeed;

                while (nextafterf(lowerSpeed, INFINITY) < upperSpeed) {
                    float midSpeed = fmaxf((lowerSpeed + upperSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                    get_vel_ranges(minXVel, maxXVel, minZVel, maxZVel, mag, intendedDYaw, midSpeed, xVel0, zVel0);
                    get_estimate_sliding_speeds(minXVel, minZVel, xVel1, zVel1, mag, intendedDYaw, slopeAngle, accel, steepness);

                    float slidingForwardVelM = xVel1 * sins(slideYaw) + zVel1 * coss(slideYaw);
                    float slidingStrainVelM = xVel1 * coss(slideYaw) - zVel1 * sins(slideYaw);

                    if (slidingStrainVelM > maxStrainSpeed) {
                        upperSpeed = midSpeed;
                    }
                    else {
                        lowerSpeed = midSpeed;
                        maxForwardVel = midSpeed;
                        slidingForwardVel2 = slidingForwardVelM;
                        slidingStrainVel2 = slidingStrainVelM;
                    }
                }
            }

            int nVels = *(int*)&maxForwardVel - *(int*)&minForwardVel;
            int nBlocks = (nVels + nThreads - 1) / nThreads;

            int nSlidingSetupsCPU = 0;

            cudaMemcpyToSymbol(nSlidingSetups, &nSlidingSetupsCPU, sizeof(int), 0, cudaMemcpyHostToDevice);
            try_forward_velG<<<nBlocks, nThreads>>>(minForwardVel, maxForwardVel, xVel0, zVel0, mag, intendedDYaw, slideYaw, slopeAngle, accel, steepness, maxSpeed, maxStrainSpeed);
            cudaMemcpyFromSymbol(&nSlidingSetupsCPU, nSlidingSetups, sizeof(int), 0, cudaMemcpyDeviceToHost);

            if (nSlidingSetupsCPU > 0) {
                if (nSlidingSetupsCPU > MAX_SLIDE_SETUPS) {
                    fprintf(stderr, "Warning: The maximum number of slide setups has been exceeded. No more will be recorded. Increase the internal maximum to prevent this from happening.\n");
                    nSlidingSetupsCPU = MAX_SLIDE_SETUPS;
                }

                nBlocks = (nSlidingSetupsCPU + nThreads - 1) / nThreads;

                int nStrainSetupsCPU = 0;

                cudaMemcpyToSymbol(nStrainSetups, &nStrainSetupsCPU, sizeof(int), 0, cudaMemcpyHostToDevice);
                find_strainG<<<nBlocks, nThreads>>>(slideYaw, maxSpeed, ch, baseCameraYaw);
                cudaMemcpyFromSymbol(&nStrainSetupsCPU, nStrainSetups, sizeof(int), 0, cudaMemcpyDeviceToHost);

                if (nStrainSetupsCPU > 0) {
                    if (nStrainSetupsCPU > MAX_STRAIN_SETUPS) {
                        fprintf(stderr, "Warning: The maximum number of strain setups has been exceeded. No more will be recorded. Increase the internal maximum to prevent this from happening.\n");
                        nStrainSetupsCPU = MAX_STRAIN_SETUPS;
                    }

                    nBlocks = (nStrainSetupsCPU * nZones + nThreads - 1) / nThreads;

                    int nCollisionSetupsCPU = 0;

                    cudaMemcpyToSymbol(nCollisionSetups, &nCollisionSetupsCPU, sizeof(int), 0, cudaMemcpyHostToDevice);
                    find_collisions<<<nBlocks, nThreads>>>(slideYaw, sqSetupsGPU, nZones, maxBullySpeed, minStableFrames);
                    cudaMemcpyFromSymbol(&nCollisionSetupsCPU, nCollisionSetups, sizeof(int), 0, cudaMemcpyDeviceToHost);

                    if (nCollisionSetupsCPU > 0) {
                        if (nCollisionSetupsCPU > MAX_COLLISION_SETUPS) {
                            fprintf(stderr, "Warning: The maximum number of bully collision setups has been exceeded. No more will be recorded. Increase the internal maximum to prevent this from happening.\n");
                            nCollisionSetupsCPU = MAX_COLLISION_SETUPS;
                        }

                        struct CollisionSetup* collisionSetupsCPU = (struct CollisionSetup*)std::malloc(nCollisionSetupsCPU * sizeof(struct CollisionSetup));
                        struct SlideSetup* slidingSetupsCPU = (struct SlideSetup*)std::malloc(nSlidingSetupsCPU * sizeof(struct SlideSetup));
                        struct StrainSetup* strainSetupsCPU = (struct StrainSetup*)std::malloc(nStrainSetupsCPU * sizeof(struct StrainSetup));

                        cudaMemcpy(collisionSetupsCPU, collisionSetupsGPU, nCollisionSetupsCPU * sizeof(struct CollisionSetup), cudaMemcpyDeviceToHost);
                        cudaMemcpy(slidingSetupsCPU, slidingSetupsGPU, nSlidingSetupsCPU * sizeof(struct SlideSetup), cudaMemcpyDeviceToHost);
                        cudaMemcpy(strainSetupsCPU, strainSetupsGPU, nStrainSetupsCPU * sizeof(struct StrainSetup), cudaMemcpyDeviceToHost);

                        for (int i = 0; i < nCollisionSetupsCPU; i++) {
                            CollisionSetup* collisionSetup = &(collisionSetupsCPU[i]);
                            SquishCancelSetup* sqSetup = &(sqSetups[collisionSetup->bullyZoneIdx]);
                            StrainSetup* strainSetup = &(strainSetupsCPU[collisionSetup->strainSetupIdx]);
                            SlideSetup* slideSetup = &(slidingSetupsCPU[strainSetup->slideSetupIdx]);

                            wf << xVel0 << ", " << zVel0 << ", ";
                            wf << slideYaw << ", " << x << ", " << y << ", ";
                            wf << slideSetup->forwardVel << ", " << slideSetup->xVel << ", " << slideSetup->zVel << ", " << slideCameraYaw << ", ";
                            wf << strainSetup->preStrainSpeed << ", " << strainSetup->strainStickX << ", " << strainSetup->strainStickY << ", " << strainSetup->cameraYaw << ", ";
                            wf << strainSetup->postStrainSpeed << ", " << sqSetup->squishQSteps << ", " << sqSetup->pushAngle << ", ";
                            wf << collisionSetup->bullyAngle << ", " << collisionSetup->bullySpeed << ", " << collisionSetup->framesStable << ", ";
                            wf << collisionSetup->minBullyX << ", " << collisionSetup->maxBullyX << ", " << collisionSetup->minBullyZ << ", " << collisionSetup->maxBullyZ << endl;
                        }

                        std::free(slidingSetupsCPU);
                        std::free(strainSetupsCPU);
                    }
                }
            }
        }
    }
}

void find_slide_setups(float xVel0, float zVel0, float departureSpeed, int frame2Angle, int minFallAngle, int maxFallAngle, int minCollisionAngle, int maxCollisionAngle, int slideCameraYaw, int baseCameraYaw, Vec3f lakituPosition, Polygon* ch, bool* validCameraAngle, int slopeAngle, float accel, float steepness, struct SlideSetup* slidingSetupsGPU, struct StrainSetup* strainSetupsGPU, struct CollisionSetup* collisionSetupsGPU, struct StrainNode** strainLookupGPU, int* nStrainNodesGPU, struct StickNode* stickLookup, struct SquishCancelSetup* sqSetups, struct MiniSquishCancelSetup* sqSetupsGPU, int nZones, const float minSpeed, const float maxSpeed, const int minStableFrames, int nThreads, ofstream& wf) {
    int finalSlideYaw = atan2s(zVel0, xVel0);
    int newFacingDYaw = (short)(frame2Angle - finalSlideYaw);

    bool validDYaw = false;
    int minIntendedYaw = 0;
    int maxIntendedYaw = 0;

    if (newFacingDYaw == -0x4000) {
        minIntendedYaw = frame2Angle;
        maxIntendedYaw = frame2Angle;
        validDYaw = true;
    }
    else if (newFacingDYaw == 0x0) {
        minIntendedYaw = -0x200;
        maxIntendedYaw = 0x200;
        validDYaw = true;
    }
    else if (newFacingDYaw == -0x8000) {
        minIntendedYaw = 0x7800;
        maxIntendedYaw = 0x8200;
        validDYaw = true;
    }
    else if (newFacingDYaw > -0x3800 && newFacingDYaw < 0) {
        minIntendedYaw = finalSlideYaw + newFacingDYaw - 0x200;
        maxIntendedYaw = finalSlideYaw + newFacingDYaw - 0x200;
        validDYaw = true;
    }
    else if (newFacingDYaw > 0 && newFacingDYaw <= 0x3800) {
        minIntendedYaw = finalSlideYaw + newFacingDYaw + 0x200;
        maxIntendedYaw = finalSlideYaw + newFacingDYaw + 0x200;
        validDYaw = true;
    }
    else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4200) {
        minIntendedYaw = finalSlideYaw + newFacingDYaw + 0x200;
        maxIntendedYaw = finalSlideYaw + newFacingDYaw + 0x200;
        validDYaw = true;
    }
    else if (newFacingDYaw > 0x4200 && newFacingDYaw < 0x8000) {
        minIntendedYaw = finalSlideYaw + newFacingDYaw - 0x200;
        maxIntendedYaw = finalSlideYaw + newFacingDYaw - 0x200;
        validDYaw = true;
    }

    int strainCount = 0;
    int collisionCount = 0;

    if (validDYaw) {
        int* nStrainNodesCPU = (int*)std::calloc(8192, sizeof(int));
        struct StrainNode** strainLookupCPU = (struct StrainNode**)std::malloc(8192 * sizeof(struct StrainNode*));
        struct StrainNode* strainLookupStore = (struct StrainNode*)std::malloc(65536 * sizeof(struct StrainNode));

        int minStrainCameraYaw = 0;
        int maxStrainCameraYaw = 0;

        int refCameraYaw = (unsigned short)calculate_camera_yaw({ ch->p->x, -3000.0f, ch->p->z }, lakituPosition, baseCameraYaw, 0, -3071.0f);

        Point* p = ch->p;
        int nSamples = 8;

        for (int i = 0; i < ch->nPoints; i++) {
            for (int j = 0; j < nSamples; j++) {
                for (int k = 0; k < 65536; k += 8192) {
                    int cameraYaw = calculate_camera_yaw({ p->x + 2.0f * maxSpeed * sinf((2.0 * M_PI * j) / nSamples), -3000.0f, p->z + 2.0f * maxSpeed * cosf((2.0 * M_PI * j) / nSamples) }, lakituPosition, baseCameraYaw, k, -3071.0f);
                    cameraYaw = (short)(cameraYaw - refCameraYaw);
                    minStrainCameraYaw = min(minStrainCameraYaw, cameraYaw);
                    maxStrainCameraYaw = max(maxStrainCameraYaw, cameraYaw);
                }
            }

            p = p->next;
        }

        int minCameraIdx = revAtans(minStrainCameraYaw + refCameraYaw);
        int maxCameraIdx = revAtans(maxStrainCameraYaw + refCameraYaw);

        if (minCameraIdx > maxCameraIdx) {
            maxCameraIdx += 8192;
        }

        for (int i = minCameraIdx; i <= maxCameraIdx; i++) {
            int strainCameraYaw = (unsigned short)gArctanTable[i % 8192];

            if (validCameraAngle[strainCameraYaw]) {
                cudaMalloc((void**)&strainLookupCPU[i % 8192], 65536 * sizeof(struct StrainNode));
            }
        }

        struct Polygon* chG;
        copy_polygon_to_gpu(ch, chG);

        for (int s = minFallAngle; s <= maxFallAngle; s += 16) {
            int slideYaw = (unsigned short)s;

            for (int i = minCameraIdx; i <= maxCameraIdx; i++) {
                int strainCameraYaw = (unsigned short)gArctanTable[i % 8192];

                if (validCameraAngle[strainCameraYaw]) {
                    generate_straining_speed_lookup(strainLookupStore, nStrainNodesCPU[i % 8192], slideYaw, strainCameraYaw);

                    cudaMemcpy(strainLookupCPU[i % 8192], strainLookupStore, nStrainNodesCPU[i % 8192] * sizeof(struct StrainNode), cudaMemcpyHostToDevice);
                }
            }

            cudaMemcpy(strainLookupGPU, strainLookupCPU, 8192 * sizeof(struct StrainNode*), cudaMemcpyHostToDevice);
            cudaMemcpy(nStrainNodesGPU, nStrainNodesCPU, 8192 * sizeof(int), cudaMemcpyHostToDevice);

            int minTY = (minIntendedYaw >> 4) << 4;
            int maxTY = (maxIntendedYaw >> 4) << 4;

            for (int ty = minTY; ty <= maxTY; ty += 16) {
                int targetYaw = (unsigned short)ty;

                for (struct StickNode* node = &(stickLookup[targetYaw >> 4]); node->next; node = node->next) {
                    int intendedDYaw = (unsigned short)(node->data.intendedYaw - slideYaw);
                    try_intended_yaw(node->data.x, node->data.y, node->data.mag, intendedDYaw, slideYaw, slideCameraYaw, departureSpeed, xVel0, zVel0, minCollisionAngle, maxCollisionAngle, slopeAngle, accel, steepness, baseCameraYaw, slidingSetupsGPU, strainSetupsGPU, collisionSetupsGPU, stickLookup, sqSetups, sqSetupsGPU, nZones, minSpeed, maxSpeed, minStableFrames, chG, nThreads, wf);
                }

                cudaMemcpyFromSymbol(&strainCount, nStrainSetups, sizeof(int), 0, cudaMemcpyDeviceToHost);
                cudaMemcpyFromSymbol(&collisionCount, nCollisionSetups, sizeof(int), 0, cudaMemcpyDeviceToHost);

                printf("   %d: %d %d\n", slideYaw, strainCount, collisionCount);
            }
        }

        for (int i = minCameraIdx; i <= maxCameraIdx; i++) {
            int strainCameraYaw = (unsigned short)gArctanTable[i % 8192];

            if (validCameraAngle[strainCameraYaw]) {
                cudaFree(strainLookupCPU[i % 8192]);
            }
        }

        std::free(strainLookupCPU);
        std::free(strainLookupStore);
        free_polygonG(chG);
    }
}

void find_collision_zones(struct Polygon* endZone, float xPushVel, float zPushVel, int& minCollisionAngle, int& maxCollisionAngle, Platform* plat, int floorIdx, float maxXPrecision, float maxZPrecision, float maxStartSpeed, float* squishSpots, int nSquishSpots, SquishCancelSetup* sqSetup, int& nZones) {
    const float pushRadius = 115.0f;
    const float bullyHurtbox = 63.0f;

    int angleRange = (unsigned short)(((maxCollisionAngle >> 4) - (minCollisionAngle >> 4)) << 4);

    struct Polygon prevZone;
    copy_polygon(endZone, &prevZone);

    struct Point* p = prevZone.p;

    for (int i = 0; i < prevZone.nPoints; i++) {
        p->x = p->x - plat->triangles[floorIdx].normal[1] * xPushVel / 4.0f;
        p->z = p->z - plat->triangles[floorIdx].normal[1] * zPushVel / 4.0f;
        p = p->next;
    }

    update_polygon(&prevZone, plat);

    if (prevZone.nPoints > 0) {
        int uphillAngle = (unsigned short)atan2s(-plat->normal[2], -plat->normal[0]);

        int* anglePointIdxs = (int*)std::malloc(nSquishSpots * sizeof(int));
        int nAnglePoints;

        for (int i = 0; i < 3; i++) {
            struct Polygon bullyPushZone;
            copy_polygon(&prevZone, &bullyPushZone);

            p = bullyPushZone.p;

            for (int j = 0; j < bullyPushZone.nPoints; j++) {
                p->x = p->x - xPushVel / 4.0f;
                p->z = p->z - zPushVel / 4.0f;
                p = p->next;
            }

            int minAngle = INT_MAX;
            int maxAngle = INT_MIN;
            int refAngle = 65536;

            for (int j = 0; j < bullyPushZone.nPoints; j++) {
                for (int k = 0; k < nSquishSpots; k++) {
                    float signX = sign(squishSpots[2 * k]);
                    float signZ = sign(squishSpots[(2 * k) + 1]);

                    for (int l = 0; l < 4; l++) {
                        float xDist = p->x - (squishSpots[2 * k] + signX * (l % 2));
                        float zDist = p->z - (squishSpots[(2 * k) + 1] + signZ * (l / 2));

                        float dist = sqrtf(xDist * xDist + zDist * zDist);

                        if (dist >= pushRadius - bullyHurtbox && dist <= pushRadius - fmaxf(bullyHurtbox - 2.0f * maxStartSpeed - 1.85f, 0.0f)) {
                            int angle = (unsigned short)atan2s(zDist, xDist);

                            int angleDiff = (short)(angle - uphillAngle);

                            if (angleDiff < -0x4000 || angleDiff > 0x4000) {
                                if (refAngle == 65536) {
                                    refAngle = angle;
                                }

                                minAngle = min(minAngle, (int)(short)(angle - refAngle));
                                maxAngle = max(maxAngle, (int)(short)(angle - refAngle));
                            }
                        }
                    }
                }

                p = p->next;
            }

            if (refAngle != 65536) {
                minAngle = minAngle + refAngle;
                maxAngle = maxAngle + refAngle;

                minAngle = (minAngle >> 4) << 4;
                maxAngle = (maxAngle >> 4) << 4;

                printf("%d: %d %d\n", i, minAngle, maxAngle);

                for (int j = minAngle; j <= maxAngle; j += 16) {
                    int angle = (unsigned short)j;

                    int angleDiff = (unsigned short)(((angle >> 4) - (minCollisionAngle >> 4)) << 4);
                    
                    if (angleDiff >= 0 && angleDiff <= angleRange) {
                        struct Polygon bullyZone;
                        copy_polygon(&bullyPushZone, &bullyZone);

                        p = bullyZone.p;

                        float minX = INFINITY;
                        float maxX = -INFINITY;
                        float minZ = INFINITY;
                        float maxZ = -INFINITY;

                        for (int k = 0; k < bullyZone.nPoints; k++) {
                            p->x = p->x - pushRadius * sins(angle);
                            p->z = p->z - pushRadius * coss(angle);

                            minX = std::min(minX, (maxXPrecision == 0) ? p->x : maxXPrecision * ceilf(p->x / maxXPrecision));
                            maxX = std::max(maxX, (maxXPrecision == 0) ? p->x : maxXPrecision * floorf(p->x / maxXPrecision));
                            minZ = std::min(minZ, (maxZPrecision == 0) ? p->z : maxZPrecision * ceilf(p->z / maxZPrecision));
                            maxZ = std::max(maxZ, (maxZPrecision == 0) ? p->z : maxZPrecision * floorf(p->z / maxZPrecision));

                            p = p->next;
                        }

                        if (maxX >= minX && maxZ >= minZ) {
                            p = bullyZone.p;

                            for (int k = 0; k < bullyZone.nPoints; k++) {
                                p->x = std::max(p->x, minX);
                                p->x = std::min(p->x, maxX);
                                p->z = std::max(p->z, minZ);
                                p->z = std::min(p->z, maxZ);
                                p = p->next;
                            }

                            struct Polygon bullyPushZoneAdj;
                            copy_polygon(&bullyZone, &bullyPushZoneAdj);

                            p = bullyPushZoneAdj.p;

                            for (int k = 0; k < bullyPushZoneAdj.nPoints; k++) {
                                p->x = p->x + pushRadius * sins(angle);
                                p->z = p->z + pushRadius * coss(angle);
                                p = p->next;
                            }

                            nAnglePoints = 0;

                            minX = INFINITY;
                            maxX = -INFINITY;
                            minZ = INFINITY;
                            maxZ = -INFINITY;

                            for (int k = 0; k < nSquishSpots; k++) {
                                float signX = sign(squishSpots[2 * k]);
                                float signZ = sign(squishSpots[(2 * k) + 1]);

                                int minAngleSpot = INT_MAX;
                                int maxAngleSpot = INT_MIN;
                                int refAngleSpot = 65536;

                                float minDistSpot = INFINITY;
                                float maxDistSpot = -INFINITY;

                                for (int l = 0; l < 4; l++) {
                                    p = bullyZone.p;

                                    for (int m = 0; m < bullyZone.nPoints; m++) {
                                        float xDist = (squishSpots[2 * k] + signX * (l % 2)) - p->x;
                                        float zDist = (squishSpots[(2 * k) + 1] + signZ * (l / 2)) - p->z;

                                        float dist = sqrtf(xDist * xDist + zDist * zDist);

                                        int testAngle = (unsigned short)atan2s(zDist, xDist);

                                        int angleDiff = (short)(testAngle - uphillAngle);

                                        if (angleDiff < -0x4000 || angleDiff > 0x4000) {
                                            if (refAngleSpot == 65536) {
                                                refAngleSpot = testAngle;
                                            }

                                            testAngle = (short)(testAngle - refAngleSpot);

                                            minDistSpot = fminf(dist, minDistSpot);
                                            maxDistSpot = fmaxf(dist, maxDistSpot);
                                            minAngleSpot = fminf(testAngle, minAngleSpot);
                                            maxAngleSpot = fmaxf(testAngle, maxAngleSpot);
                                        }

                                        p = p->next;
                                    }
                                }

                                if (refAngleSpot != 65536) {
                                    int angleDiff = (short)(angle - refAngleSpot);

                                    if (minDistSpot <= bullyHurtbox && maxDistSpot >= fmaxf(0.0f, bullyHurtbox - (2.0f * maxStartSpeed + 1.85f)) && minAngleSpot <= angleDiff && maxAngleSpot >= angleDiff) {
                                        anglePointIdxs[nAnglePoints] = k;
                                        nAnglePoints++;

                                        minX = fminf(minX, squishSpots[2 * k] - 0.999f * (squishSpots[2 * k] <= 0));
                                        maxX = fmaxf(maxX, squishSpots[2 * k] + 0.999f * (squishSpots[2 * k] >= 0));
                                        minZ = fminf(minZ, squishSpots[(2 * k) + 1] - 0.999f * (squishSpots[(2 * k) + 1] <= 0));
                                        maxZ = fmaxf(maxZ, squishSpots[(2 * k) + 1] + 0.999f * (squishSpots[(2 * k) + 1] >= 0));
                                    }
                                }
                            }

                            if (nAnglePoints > 0) {
                                int minXI = (int)minX;
                                int maxXI = (int)maxX;
                                int minZI = (int)minZ;
                                int maxZI = (int)maxZ;

                                bool* grid = (bool*)std::calloc((maxXI - minXI + 1) * (maxZI - minZI + 1), sizeof(bool));

                                for (int k = 0; k < nAnglePoints; k++) {
                                    int gridIdx = ((int)squishSpots[(2 * anglePointIdxs[k]) + 1] - minZI) * (maxXI - minXI + 1) + ((int)squishSpots[2 * anglePointIdxs[k]] - minXI);
                                    grid[gridIdx] = true;
                                }

                                struct Polygon* marioZone = (struct Polygon*)std::malloc(sizeof(struct Polygon));
                                create_polygon(grid, minX, maxX, minZ, maxZ, marioZone);

                                std::free(grid);

                                int lowerAngle = (unsigned short)gArctanTable[(j + 8191) % 8192];
                                int upperAngle = (unsigned short)gArctanTable[(j + 1) % 8192];

                                float lowerMidAngle;
                                float upperMidAngle;

                                if (lowerAngle > angle) {
                                    lowerMidAngle = fmodf((float)(lowerAngle + angle + 65536) / 2.0f, 65536.0f);
                                }
                                else {
                                    lowerMidAngle = (float)(lowerAngle + angle) / 2.0f;
                                }

                                if (upperAngle < angle) {
                                    upperMidAngle = fmodf((float)(upperAngle + angle + 65536) / 2.0f, 65536.0f);
                                }
                                else {
                                    upperMidAngle = (float)(upperAngle + angle) / 2.0f;
                                }

                                float lowerX;
                                float lowerZ;
                                float upperX;
                                float upperZ;

                                double minB = INFINITY;
                                double maxB = -INFINITY;

                                double sinLowerMidAngle = sin(2.0 * M_PI * lowerMidAngle / 65536.0);
                                double cosLowerMidAngle = cos(2.0 * M_PI * lowerMidAngle / 65536.0);
                                double sinUpperMidAngle = sin(2.0 * M_PI * upperMidAngle / 65536.0);
                                double cosUpperMidAngle = cos(2.0 * M_PI * upperMidAngle / 65536.0);

                                p = bullyZone.p;

                                for (int k = 0; k < bullyZone.nPoints; k++) {
                                    double lowerB = p->x * cosLowerMidAngle - p->z * sinLowerMidAngle;
                                    double upperB = p->x * cosUpperMidAngle - p->z * sinUpperMidAngle;

                                    if (lowerB < minB) {
                                        minB = lowerB;
                                        lowerX = p->x;
                                        lowerZ = p->z;
                                    }

                                    if (upperB > maxB) {
                                        maxB = upperB;
                                        upperX = p->x;
                                        upperZ = p->z;
                                    }

                                    p = p->next;
                                }

                                cut_polygon_on_line(marioZone, sinLowerMidAngle, cosLowerMidAngle, lowerX, lowerZ, -1);
                                cut_polygon_on_line(marioZone, sinUpperMidAngle, cosUpperMidAngle, upperX, upperZ, 1);

                                if (marioZone->nPoints > 0) {
                                    if (nZones < MAX_ZONES) {
                                        struct Polygon* bpzCopy = (struct Polygon*)std::malloc(sizeof(struct Polygon));
                                        copy_polygon(&bullyPushZoneAdj, bpzCopy);

                                        struct Polygon* bzCopy = (struct Polygon*)std::malloc(sizeof(struct Polygon));
                                        copy_polygon(&bullyZone, bzCopy);

                                        sqSetup[nZones].bullyPushZone = bpzCopy;
                                        sqSetup[nZones].bullyZone = bzCopy;
                                        sqSetup[nZones].marioZone = marioZone;
                                        sqSetup[nZones].pushAngle = angle;
                                        sqSetup[nZones].squishQSteps = i + 1;

                                        /*
                                        printf("Setup #%d:\n    Bully Push Zone: ", nZones);
                                        print_polygon(bpzCopy);
                                        printf("    Bully Zone: ");
                                        print_polygon(bzCopy);
                                        printf("    Mario Zone: ");
                                        print_polygon(marioZone);
                                        printf("\n");
                                        */
                                    }
                                    else if (nZones == MAX_ZONES) {
                                        fprintf(stderr, "Warning: Number of bully collision zones has been exceeded. No more will be recorded. Increase the internal maximum to prevent this from happening.\n");
                                    }

                                    nZones++;
                                }
                                else {
                                    std::free(marioZone);
                                }
                            }

                            free_polygon(&bullyPushZoneAdj);
                        }

                        free_polygon(&bullyZone);
                    }

                }
            }

            p = prevZone.p;

            for (int j = 0; j < prevZone.nPoints; j++) {
                p->x = p->x - plat->triangles[floorIdx].normal[1] * xPushVel / 4.0f;
                p->z = p->z - plat->triangles[floorIdx].normal[1] * zPushVel / 4.0f;
                p = p->next;
            }

            free_polygon(&bullyPushZone);
        }

        std::free(anglePointIdxs);
    }

    free_polygon(&prevZone);
}

void find_squish_spots(Platform* p0, Platform* p1, int ceilIdx, float* squishSpots, int& nSquishSpots) {
    int minX = INT_MAX;
    int maxX = INT_MIN;
    int minZ = INT_MAX;
    int maxZ = INT_MIN;

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 3; j++) {
            minX = min(minX, (int)p1->ceilings[i].vectors[j][0]);
            maxX = max(maxX, (int)p1->ceilings[i].vectors[j][0]);
            minZ = min(minZ, (int)p1->ceilings[i].vectors[j][2]);
            maxZ = max(maxZ, (int)p1->ceilings[i].vectors[j][2]);
        }
    }

    int x0 = (ceilIdx == 0 || ceilIdx == 2) ? p1->ceilings[ceilIdx].vectors[0][0] : p1->ceilings[ceilIdx].vectors[1][0];
    int z0 = (ceilIdx == 0 || ceilIdx == 2) ? p1->ceilings[ceilIdx].vectors[0][2] : p1->ceilings[ceilIdx].vectors[1][2];
    int x1 = ceilIdx == 0 ? p1->ceilings[ceilIdx].vectors[1][0] : p1->ceilings[ceilIdx].vectors[2][0];
    int z1 = ceilIdx == 0 ? p1->ceilings[ceilIdx].vectors[1][2] : p1->ceilings[ceilIdx].vectors[2][2];

    float xDiff = x1 - x0;
    float zDiff = z1 - z0;

    float diffDist = sqrtf(xDiff * xDiff + zDiff * zDiff);

    xDiff = xDiff / diffDist;
    zDiff = zDiff / diffDist;

    for (int x = minX; x <= maxX; x++) {
        for (int z = minZ; z <= maxZ; z++) {
            Vec3f pos = { x, -3071.0f , z };

            float ceilHeight;
            const Surface* ceil = find_ceil(pos, p1->ceilings, &ceilHeight);

            if (ceil && ceil->idx - 2 == ceilIdx && ceilHeight - -3071.0f < 150.0f) {
                float preCeilHeight;
                const Surface* preCeil = find_ceil(pos, p0->ceilings, &preCeilHeight);

                if (!preCeil) {
                    if (nSquishSpots < MAX_SQUISH_SPOTS) {
                        squishSpots[2 * nSquishSpots] = x;
                        squishSpots[(2 * nSquishSpots) + 1] = z;
                        nSquishSpots++;
                    }
                }
            }
        }
    }

    if (nSquishSpots >= MAX_SQUISH_SPOTS) {
        fprintf(stderr, "Warning: The maximum number of squish spots has been exceeded. No more will be recorded. Increase the internal maximum to prevent this from happening.\n");
    }
}

void write_zone_data(float xVel, float zVel, SquishCancelSetup* sqSetups, int nZones, bool& first, ofstream& zn) {
    if (first) {
        first = false;
    }
    else {
        zn << "," << endl;
    }
    zn << "    {" << endl;
    zn << "        \"Post-10K X Velocity\" : " << xVel << ", " << endl;
    zn << "        \"Post-10K Z Velocity\" : " << zVel << ", " << endl;
    zn << "        \"Squish Cancel Zones\" : [" << endl;

    for (int k = 0; k < min(nZones, MAX_ZONES); k++) {
        zn << "            {" << endl;
        zn << "                \"Squish Push Q-Frames\" : " << sqSetups[k].squishQSteps << ", " << endl;
        zn << "                \"Bully Push Angle\" : " << sqSetups[k].pushAngle << ", " << endl;
        zn << "                \"Bully Zone\" : [" << endl;

        Point* p = sqSetups[k].bullyZone->p;

        for (int l = 0; l < sqSetups[k].bullyZone->nPoints; l++) {
            zn << "                    [" << p->x << ", " << p->z << "]";

            if (l != sqSetups[k].bullyZone->nPoints - 1) {
                zn << ",";
            }

            zn << endl;

            p = p->next;
        }

        zn << "                ], " << endl;
        zn << "                \"Mario Zone\" : [" << endl;

        p = sqSetups[k].marioZone->p;

        for (int l = 0; l < sqSetups[k].marioZone->nPoints; l++) {
            zn << "                    [" << p->x << ", " << p->z << "]";

            if (l != sqSetups[k].marioZone->nPoints - 1) {
                zn << ",";
            }

            zn << endl;

            p = p->next;
        }

        zn << "                ], " << endl;
        zn << "                \"Bully Push Zone\" : [" << endl;

        p = sqSetups[k].bullyPushZone->p;

        for (int l = 0; l < sqSetups[k].bullyPushZone->nPoints; l++) {
            zn << "                    [" << p->x << ", " << p->z << "]";

            if (l != sqSetups[k].bullyPushZone->nPoints - 1) {
                zn << ",";
            }

            zn << endl;

            p = p->next;
        }

        zn << "                ]" << endl;
        zn << "            }";

        if (k != nZones - 1) {
            zn << ", ";
        }

        zn << endl;
    }

    zn << "        ]" << endl;
    zn << "    }" << endl;
}

void sort_points(struct Point*& p, int nPoints) {
    if (nPoints > 1) {
        struct Point* leftStart = NULL;
        struct Point* leftEnd = NULL;
        int nLeft = 0;

        struct Point* rightStart = NULL;
        struct Point* rightEnd = NULL;
        int nRight = 0;

        float pivotX = p->x;
        float pivotZ = p->z;

        p = p->next;

        for (int i = 1; i < nPoints; i++) {
            if (p->x < pivotX || (p->x == pivotX && p->z <= pivotZ)) {
                if (leftStart) {
                    leftEnd->next = p;
                    p->prev = leftEnd;
                }
                else {
                    leftStart = p;
                }

                leftEnd = p;
                nLeft++;
            }
            else {
                if (rightStart) {
                    rightEnd->next = p;
                    p->prev = rightEnd;
                }
                else {
                    rightStart = p;
                }

                rightEnd = p;
                nRight++;
            }

            p = p->next;
        }

        if (leftStart) {
            leftEnd->next = leftStart;
            leftStart->prev = leftEnd;
            sort_points(leftStart, nLeft);
        }

        if (rightStart) {
            rightEnd->next = rightStart;
            rightStart->prev = rightEnd;
            sort_points(rightStart, nRight);
        }

        if (leftStart) {
            if (rightStart) {
                leftStart->prev->next = p;
                p->next = rightStart;
                rightStart->prev->next = leftStart;
                p->prev = leftStart->prev;
                leftStart->prev = rightStart->prev;
                rightStart->prev = p;
                p = leftStart;
            }
            else {
                leftStart->prev->next = p;
                p->prev = leftStart->prev;
                p->next = leftStart;
                leftStart->prev = p;
                p = leftStart;
            }
        }
        else if (rightStart) {
            rightStart->prev->next = p;
            p->prev = rightStart->prev;
            p->next = rightStart;
            rightStart->prev = p;
        }
    }
}

void get_mzone_convex_hull(struct SquishCancelSetup* sqSetups, int nZones, struct Polygon* ch) {
    ch->nPoints = 0;

    struct Polygon points;
    points.p = NULL;
    points.nPoints = 0;

    struct Point* p0 = NULL;

    for (int i = 0; i < nZones; i++) {
        struct Point* p = sqSetups[i].marioZone->p;

        for (int j = 0; j < sqSetups[i].marioZone->nPoints; j++) {
            struct Point* p1 = (struct Point*)std::malloc(sizeof(struct Point));
            p1->x = p->x;
            p1->z = p->z;

            if (!points.p) {
                points.p = p1;
            }

            if (p0) {
                p0->next = p1;
            }

            p1->prev = p0;
            points.nPoints++;

            p0 = p1;
            p = p->next;
        }
    }

    p0->next = points.p;
    points.p->prev = p0->next;

    sort_points(points.p, points.nPoints);

    Point* p = points.p;

    Point* chp = (struct Point*)std::malloc(sizeof(struct Point));
    chp->x = p->x;
    chp->z = p->z;
    chp->prev = NULL;

    ch->p = chp;
    ch->nPoints = 1;

    for (int i = 1; i < points.nPoints; i++) {
        p = p->next;

        bool findLoop = true;

        while (findLoop) {
            if (!chp->prev || (chp->x - chp->prev->x) * (p->z - chp->prev->z) - (p->x - chp->prev->x) * (chp->z - chp->prev->z) > 0) {
                struct Point* newChp = (struct Point*)std::malloc(sizeof(struct Point));
                newChp->x = p->x;
                newChp->z = p->z;
                newChp->prev = chp;
                chp->next = newChp;
                chp = newChp;
                ch->nPoints++;
                findLoop = false;
            }
            else {
                chp = chp->prev;
                std::free(chp->next);
                ch->nPoints--;
            }
        }
    }

    for (int i = 1; i < points.nPoints; i++) {
        p = p->prev;

        bool findLoop = true;

        while (findLoop) {
            if (!chp->prev || (chp->x - chp->prev->x) * (p->z - chp->prev->z) - (p->x - chp->prev->x) * (chp->z - chp->prev->z) > 0) {
                struct Point* newChp = (struct Point*)std::malloc(sizeof(struct Point));
                newChp->x = p->x;
                newChp->z = p->z;
                newChp->prev = chp;
                chp->next = newChp;
                chp = newChp;
                ch->nPoints++;
                findLoop = false;
            }
            else {
                chp = chp->prev;
                std::free(chp->next);
                ch->nPoints--;
            }
        }
    }

    if (ch->p->x == chp->x && ch->p->z == chp->z) {
        chp = chp->prev;
        std::free(chp->next);
        ch->nPoints--;
    }

    ch->p->prev = chp;
    chp->next = ch->p;

    free_polygon(&points);
}

void copy_collision_zones_to_gpu(SquishCancelSetup* sqSetups, MiniSquishCancelSetup* sqSetupsGPU, int nZones) {
    struct MiniSquishCancelSetup* sqSetupsCPU = (struct MiniSquishCancelSetup*)std::malloc(nZones * sizeof(struct MiniSquishCancelSetup));

    for (int i = 0; i < nZones; i++) {
        sqSetupsCPU[i].pushAngle = sqSetups[i].pushAngle;
        sqSetupsCPU[i].squishQSteps = sqSetups[i].squishQSteps;
        sqSetupsCPU[i].minBullyX = INFINITY;
        sqSetupsCPU[i].maxBullyX = -INFINITY;
        sqSetupsCPU[i].minBullyZ = INFINITY;
        sqSetupsCPU[i].maxBullyZ = -INFINITY;

        struct Point* p = sqSetups[i].bullyZone->p;

        for (int j = 0; j < sqSetups[i].bullyZone->nPoints; j++) {
            sqSetupsCPU[i].minBullyX = fminf(sqSetupsCPU[i].minBullyX, p->x);
            sqSetupsCPU[i].maxBullyX = fmaxf(sqSetupsCPU[i].maxBullyX, p->x);
            sqSetupsCPU[i].minBullyZ = fminf(sqSetupsCPU[i].minBullyZ, p->z);
            sqSetupsCPU[i].maxBullyZ = fmaxf(sqSetupsCPU[i].maxBullyZ, p->z);

            p = p->next;
        }
    }

    cudaMemcpy(sqSetupsGPU, sqSetupsCPU, nZones * sizeof(MiniSquishCancelSetup), cudaMemcpyHostToDevice);
    std::free(sqSetupsCPU);
}

int main()
{
    int nThreads = 256;

    Vec3f platformPos = { -1945.0f, -3225.0f, -715.0f };
    Vec3f lakituPosition = { -10000.0f, -2918.0f, 5000.0f };

    Vec3f platformNormal = { -0.1985f, 0.86f, 0.375f };
    Vec3f frame1Position = { -526269.0f, -3035.231689f, -2359672.0f };

    float departureSpeed = 2674169.75f;
    float departureXVel = -580422.375f;
    float departureZVel = -2610420.25f;

    int frame2Angle = 34897;

    int baseCameraYaw = -8192;

    int minFallAngle = 0;
    int maxFallAngle = 65535;

    int minCollisionAngle = 0;
    int maxCollisionAngle = 65535;

    float maxXPrecision = 0.0f;
    float maxZPrecision = 0.0f;

    const float accel = 7.0f;
    const float minStartSpeed = 0.0f;
    const float maxStartSpeed = 5.0f;

    const int minBullyHoverFrames = 500;

    string zoneFile = "zoneData.json";
    string strainFile = "strainData.csv";

    minFallAngle = (minFallAngle >> 4) << 4;
    maxFallAngle = (maxFallAngle >> 4) << 4;

    minCollisionAngle = (minCollisionAngle >> 4) << 4;
    maxCollisionAngle = (maxCollisionAngle >> 4) << 4;

    Vec3f beforeNormal = { (platformNormal[0] + (platformNormal[0] > 0 ? 0.01f : -0.01f)) + (platformNormal[0] > 0 ? 0.01f : -0.01f) , (platformNormal[1] - 0.01f) - 0.01f, (platformNormal[2] + (platformNormal[2] > 0 ? 0.01f : -0.01f)) + (platformNormal[2] > 0 ? 0.01f : -0.01f) };
    Vec3f offPlatformPosition = { 0.0f, 0.0f, 0.0f };

    Platform platform0 = Platform(platformPos[0], platformPos[1], platformPos[2], beforeNormal);
    platform0.platform_logic(offPlatformPosition);

    Platform platform1 = Platform(platformPos[0], platformPos[1], platformPos[2], platform0.normal);
    platform1.platform_logic(offPlatformPosition);

    Platform platform2 = Platform(platformPos[0], platformPos[1], platformPos[2], platform1.normal);
    platform2.platform_logic(offPlatformPosition);

    float* squishSpots = (float*)std::malloc(2 * MAX_SQUISH_SPOTS * sizeof(float));
    int nSquishSpots;

    struct SquishCancelSetup* sqSetups = (struct SquishCancelSetup*)std::malloc(MAX_ZONES * sizeof(struct SquishCancelSetup));

    struct MiniSquishCancelSetup* sqSetupsGPU;
    cudaMalloc((void**)&sqSetupsGPU, MAX_ZONES * sizeof(struct MiniSquishCancelSetup));

    struct SlideSetup* slidingSetupsGPU;
    cudaMalloc((void**)&slidingSetupsGPU, MAX_SLIDE_SETUPS * sizeof(struct SlideSetup));

    struct StrainSetup* strainSetupsGPU;
    cudaMalloc((void**)&strainSetupsGPU, MAX_STRAIN_SETUPS * sizeof(struct StrainSetup));

    struct CollisionSetup* collisionSetupsGPU;
    cudaMalloc((void**)&collisionSetupsGPU, MAX_COLLISION_SETUPS * sizeof(struct CollisionSetup));

    struct StrainNode** strainLookupGPU;
    cudaMalloc((void**)&strainLookupGPU, 8192 * sizeof(struct StrainNode*));

    int* nStrainNodesGPU;
    cudaMalloc((void**)&nStrainNodesGPU, 8192 * sizeof(int));

    struct StickNode* stickLookup = (struct StickNode*)std::malloc(4096 * sizeof(struct StickNode));

    bool* validCameraAngle = (bool*)std::calloc(65536, sizeof(bool));

    bool* validCameraAngleGPU;
    cudaMalloc((void**)&validCameraAngleGPU, 65536 * sizeof(bool));

    init_reverse_atan();
    init_camera_angles(validCameraAngle);

    cudaMemcpy(validCameraAngleGPU, validCameraAngle, 65536 * sizeof(bool), cudaMemcpyHostToDevice);

    copy_pointers_to_gpu<<<1, 1>>>(slidingSetupsGPU, strainSetupsGPU, collisionSetupsGPU, strainLookupGPU, nStrainNodesGPU, validCameraAngleGPU);
    init_lakitu_position<<<1, 1>>>(lakituPosition[0], lakituPosition[1], lakituPosition[2]);
    initialise_floors<<<1, 1>>>();
    init_reverse_atanG<<<1, 1>>>();

    minFallAngle = (unsigned short)minFallAngle;
    maxFallAngle = (unsigned short)maxFallAngle;
    maxFallAngle += (maxFallAngle < minFallAngle) * 65536;

    minCollisionAngle = (unsigned short)minCollisionAngle;
    maxCollisionAngle = (unsigned short)maxCollisionAngle;
    maxCollisionAngle += (maxCollisionAngle < minCollisionAngle) * 65536;

    ofstream zn(zoneFile);
    zn << std::fixed << setprecision(10);
    zn << "[" << endl;

    ofstream wf(strainFile);
    wf << std::fixed << setprecision(10);

    wf << "Post 10K Vel X, Post 10K Vel Z, ";
    wf << "Slide Yaw, 10K Stick X, 10K Stick Y, ";
    wf << "Pre-10K Forward Speed, Pre-10K Sliding Vel X, Pre-10K Sliding Vel Z, Pre-10K Camera Yaw, ";
    wf << "Pre-Strain Forward Speed, Strain Stick X, Strain Stick Y, Strain Camera Yaw, ";
    wf << "Post-Strain Forward Speed, Squish Push Q-Steps, Bully Push Angle, ";
    wf << "Bully Collision Angle, Bully Collision Speed, Max Bully Hover Frames, ";
    wf << "Bully Min X, Bully Max X, Bully Min Z, Bully Max Z" << endl;

    bool first = true;

    for (int i = 0; i < 4; i++) {
        if (platform1.ceilings[i].normal[1] > -0.5f) {
            nSquishSpots = 0;

            find_squish_spots(&platform0, &platform1, i, squishSpots, nSquishSpots);
            float ceilingEdge[2][2][2];

            int idx = 0;

            for (int j = 0; j < 3; j++) {
                if (platform1.ceilings[i].vectors[j][0] != platformPos[0] || platform1.ceilings[i].vectors[j][2] != platformPos[2]) {
                    ceilingEdge[0][idx][0] = platform1.ceilings[i].vectors[j][0];
                    ceilingEdge[0][idx][1] = platform1.ceilings[i].vectors[j][2];
                    ceilingEdge[1][idx][0] = platform2.ceilings[i].vectors[j][0];
                    ceilingEdge[1][idx][1] = platform2.ceilings[i].vectors[j][2];
                    idx++;
                }
            }

            int surfAngle = (unsigned short)atan2s(platform1.ceilings[i].normal[2], platform1.ceilings[i].normal[0]);

            float xPushVel = sins(surfAngle) * 10.0f;
            float zPushVel = coss(surfAngle) * 10.0f;

            int floorIdx = (i == 0 || i == 2) ? 0 : 1;
            float floorNormalY1 = platform1.triangles[floorIdx].normal[1];

            float xOffset = floorNormalY1 * (xPushVel / 4.0f);
            float zOffset = floorNormalY1 * (zPushVel / 4.0f);

            Polygon startPolygon;

            if (find_start_polygon(frame1Position, departureXVel, departureZVel, platform2.triangles[floorIdx].normal[1], platform1.triangles, platform2.triangles, &startPolygon)) {
                int slopeAngle = (unsigned short)atan2s(platform2.triangles[floorIdx].normal[2], platform2.triangles[floorIdx].normal[0]);

                float steepness = sqrtf(platform2.triangles[floorIdx].normal[0] * platform2.triangles[floorIdx].normal[0] + platform2.triangles[floorIdx].normal[2] * platform2.triangles[floorIdx].normal[2]);

                int nZones = 0;
                find_collision_zones(&startPolygon, xPushVel, zPushVel, minCollisionAngle, maxCollisionAngle, &platform1, floorIdx, maxXPrecision, maxZPrecision, maxStartSpeed, squishSpots, nSquishSpots, sqSetups, nZones);

                if (nZones > 0) {
                    int baseAngle = sqSetups[0].pushAngle;
                    int minAngle = 0;
                    int maxAngle = 0;

                    for (int k = 0; k < nZones; k++) {
                        minAngle = std::min(minAngle, (int)(short)(sqSetups[k].pushAngle-baseAngle));
                        maxAngle = std::max(maxAngle, (int)(short)(sqSetups[k].pushAngle-baseAngle));
                    }

                    minAngle = (unsigned short)(minAngle + baseAngle);
                    maxAngle = (unsigned short)(maxAngle + baseAngle);

                    write_zone_data(departureXVel, departureZVel, sqSetups, nZones, first, zn);

                    copy_collision_zones_to_gpu(sqSetups, sqSetupsGPU, nZones);

                    struct Polygon ch;
                    get_mzone_convex_hull(sqSetups, nZones, &ch);

                    int minCameraYaw = 0;
                    int maxCameraYaw = 0;

                    int refCameraYaw = (unsigned short)calculate_camera_yaw({ ch.p->x, -3000.0f, ch.p->z }, lakituPosition, baseCameraYaw, 0, -3071.0f);

                    Point* p = ch.p;

                    for (int l = 0; l < ch.nPoints; l++) {
                        for (int m = 0; m < 65536; m = m + 8192) {
                            int cameraYaw = calculate_camera_yaw({ p->x, -3000.0f, p->z }, lakituPosition, baseCameraYaw, m, -3071.0f);
                            cameraYaw = (short)(cameraYaw - refCameraYaw);
                            minCameraYaw = min(minCameraYaw, cameraYaw);
                            maxCameraYaw = max(maxCameraYaw, cameraYaw);
                        }

                        p = p->next;
                    }

                    int minCameraIdx = revAtans(minCameraYaw + refCameraYaw);
                    int maxCameraIdx = revAtans(maxCameraYaw + refCameraYaw);

                    if (minCameraIdx > maxCameraIdx) {
                        maxCameraIdx += 8192;
                    }

                    for (int k = minCameraIdx; k <= maxCameraIdx; k++) {
                        int slideCameraYaw = (unsigned short)gArctanTable[k % 8192];

                        if (validCameraAngle[slideCameraYaw]) {
                            generate_stick_lookup(stickLookup, slideCameraYaw);

                            find_slide_setups(departureXVel, departureZVel, departureSpeed, frame2Angle, minFallAngle, maxFallAngle, minCollisionAngle, maxCollisionAngle, slideCameraYaw, baseCameraYaw, lakituPosition, &ch, validCameraAngle, slopeAngle, accel, steepness, slidingSetupsGPU, strainSetupsGPU, collisionSetupsGPU, strainLookupGPU, nStrainNodesGPU, stickLookup, sqSetups, sqSetupsGPU, nZones, minStartSpeed, maxStartSpeed, minBullyHoverFrames, nThreads, wf);

                            free_stick_lookup(stickLookup);
                        }
                    }
                    free_polygon(&ch);
                }

                for (int k = 0; k < nZones; k++) {
                    free_polygon(sqSetups[k].bullyPushZone);
                    std::free(sqSetups[k].bullyPushZone);
                    free_polygon(sqSetups[k].bullyZone);
                    std::free(sqSetups[k].bullyZone);
                    free_polygon(sqSetups[k].marioZone);
                    std::free(sqSetups[k].marioZone);
                }
            }
        }
    }

    std::free(squishSpots);
    std::free(stickLookup);
    std::free(sqSetups);
    std::free(validCameraAngle);
    cudaFree(collisionSetupsGPU);
    cudaFree(strainSetupsGPU);
    cudaFree(slidingSetupsGPU);
    cudaFree(strainLookupGPU);

    zn << "]";
    zn.close();
    wf.close();
}
